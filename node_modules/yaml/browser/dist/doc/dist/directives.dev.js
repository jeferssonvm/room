"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Directives = void 0;

var _identity = require("../nodes/identity.js");

var _visit = require("../visit.js");

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var escapeChars = {
  '!': '%21',
  ',': '%2C',
  '[': '%5B',
  ']': '%5D',
  '{': '%7B',
  '}': '%7D'
};

var escapeTagName = function escapeTagName(tn) {
  return tn.replace(/[!,[\]{}]/g, function (ch) {
    return escapeChars[ch];
  });
};

var Directives =
/*#__PURE__*/
function () {
  function Directives(yaml, tags) {
    _classCallCheck(this, Directives);

    /**
     * The directives-end/doc-start marker `---`. If `null`, a marker may still be
     * included in the document's stringified representation.
     */
    this.docStart = null;
    /** The doc-end marker `...`.  */

    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }

  _createClass(Directives, [{
    key: "clone",
    value: function clone() {
      var copy = new Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */

  }, {
    key: "atDocument",
    value: function atDocument() {
      var res = new Directives(this.yaml, this.tags);

      switch (this.yaml.version) {
        case '1.1':
          this.atNextDocument = true;
          break;

        case '1.2':
          this.atNextDocument = false;
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: '1.2'
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          break;
      }

      return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */

  }, {
    key: "add",
    value: function add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: '1.1'
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        this.atNextDocument = false;
      }

      var parts = line.trim().split(/[ \t]+/);
      var name = parts.shift();

      switch (name) {
        case '%TAG':
          {
            if (parts.length !== 2) {
              onError(0, '%TAG directive should contain exactly two parts');
              if (parts.length < 2) return false;
            }

            var _parts = _slicedToArray(parts, 2),
                handle = _parts[0],
                prefix = _parts[1];

            this.tags[handle] = prefix;
            return true;
          }

        case '%YAML':
          {
            this.yaml.explicit = true;

            if (parts.length !== 1) {
              onError(0, '%YAML directive should contain exactly one part');
              return false;
            }

            var _parts2 = _slicedToArray(parts, 1),
                version = _parts2[0];

            if (version === '1.1' || version === '1.2') {
              this.yaml.version = version;
              return true;
            } else {
              var isValid = /^\d+\.\d+$/.test(version);
              onError(6, "Unsupported YAML version ".concat(version), isValid);
              return false;
            }
          }

        default:
          onError(0, "Unknown directive ".concat(name), true);
          return false;
      }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */

  }, {
    key: "tagName",
    value: function tagName(source, onError) {
      if (source === '!') return '!'; // non-specific tag

      if (source[0] !== '!') {
        onError("Not a valid tag: ".concat(source));
        return null;
      }

      if (source[1] === '<') {
        var verbatim = source.slice(2, -1);

        if (verbatim === '!' || verbatim === '!!') {
          onError("Verbatim tags aren't resolved, so ".concat(source, " is invalid."));
          return null;
        }

        if (source[source.length - 1] !== '>') onError('Verbatim tags must end with a >');
        return verbatim;
      }

      var _source$match = source.match(/^([\s\S]*!)([\0- "-\uFFFF]*)$/),
          _source$match2 = _slicedToArray(_source$match, 3),
          handle = _source$match2[1],
          suffix = _source$match2[2];

      if (!suffix) onError("The ".concat(source, " tag has no suffix"));
      var prefix = this.tags[handle];

      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error) {
          onError(String(error));
          return null;
        }
      }

      if (handle === '!') return source; // local tag

      onError("Could not resolve tag: ".concat(source));
      return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */

  }, {
    key: "tagString",
    value: function tagString(tag) {
      for (var _i2 = 0, _Object$entries = Object.entries(this.tags); _i2 < _Object$entries.length; _i2++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
            handle = _Object$entries$_i[0],
            prefix = _Object$entries$_i[1];

        if (tag.startsWith(prefix)) return handle + escapeTagName(tag.substring(prefix.length));
      }

      return tag[0] === '!' ? tag : "!<".concat(tag, ">");
    }
  }, {
    key: "toString",
    value: function toString(doc) {
      var lines = this.yaml.explicit ? ["%YAML ".concat(this.yaml.version || '1.2')] : [];
      var tagEntries = Object.entries(this.tags);
      var tagNames;

      if (doc && tagEntries.length > 0 && (0, _identity.isNode)(doc.contents)) {
        var tags = {};
        (0, _visit.visit)(doc.contents, function (_key, node) {
          if ((0, _identity.isNode)(node) && node.tag) tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else tagNames = [];

      var _loop = function _loop() {
        var _tagEntries$_i = _slicedToArray(_tagEntries[_i3], 2),
            handle = _tagEntries$_i[0],
            prefix = _tagEntries$_i[1];

        if (handle === '!!' && prefix === 'tag:yaml.org,2002:') return "continue";
        if (!doc || tagNames.some(function (tn) {
          return tn.startsWith(prefix);
        })) lines.push("%TAG ".concat(handle, " ").concat(prefix));
      };

      for (var _i3 = 0, _tagEntries = tagEntries; _i3 < _tagEntries.length; _i3++) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }

      return lines.join('\n');
    }
  }]);

  return Directives;
}();

exports.Directives = Directives;
Directives.defaultYaml = {
  explicit: false,
  version: '1.2'
};
Directives.defaultTags = {
  '!!': 'tag:yaml.org,2002:'
};