"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.anchorIsValid = anchorIsValid;
exports.anchorNames = anchorNames;
exports.createNodeAnchors = createNodeAnchors;
exports.findNewAnchor = findNewAnchor;

var _identity = require("../nodes/identity.js");

var _visit = require("../visit.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    var sa = JSON.stringify(anchor);
    var msg = "Anchor must not contain whitespace or control characters: ".concat(sa);
    throw new Error(msg);
  }

  return true;
}

function anchorNames(root) {
  var anchors = new Set();
  (0, _visit.visit)(root, {
    Value: function Value(_key, node) {
      if (node.anchor) anchors.add(node.anchor);
    }
  });
  return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */


function findNewAnchor(prefix, exclude) {
  for (var i = 1; true; ++i) {
    var name = "".concat(prefix).concat(i);
    if (!exclude.has(name)) return name;
  }
}

function createNodeAnchors(doc, prefix) {
  var aliasObjects = [];
  var sourceObjects = new Map();
  var prevAnchors = null;
  return {
    onAnchor: function onAnchor(source) {
      aliasObjects.push(source);
      if (!prevAnchors) prevAnchors = anchorNames(doc);
      var anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },

    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: function setAnchors() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = aliasObjects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var source = _step.value;
          var ref = sourceObjects.get(source);

          if (_typeof(ref) === 'object' && ref.anchor && ((0, _identity.isScalar)(ref.node) || (0, _identity.isCollection)(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            var error = new Error('Failed to resolve repeated object (this should not happen)');
            error.source = source;
            throw error;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    },
    sourceObjects: sourceObjects
  };
}