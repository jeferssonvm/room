"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prettyToken = prettyToken;
exports.tokenType = tokenType;
Object.defineProperty(exports, "createScalarToken", {
  enumerable: true,
  get: function get() {
    return _cstScalar.createScalarToken;
  }
});
Object.defineProperty(exports, "resolveAsScalar", {
  enumerable: true,
  get: function get() {
    return _cstScalar.resolveAsScalar;
  }
});
Object.defineProperty(exports, "setScalarValue", {
  enumerable: true,
  get: function get() {
    return _cstScalar.setScalarValue;
  }
});
Object.defineProperty(exports, "stringify", {
  enumerable: true,
  get: function get() {
    return _cstStringify.stringify;
  }
});
Object.defineProperty(exports, "visit", {
  enumerable: true,
  get: function get() {
    return _cstVisit.visit;
  }
});
exports.isScalar = exports.isCollection = exports.SCALAR = exports.FLOW_END = exports.DOCUMENT = exports.BOM = void 0;

var _cstScalar = require("./cst-scalar.js");

var _cstStringify = require("./cst-stringify.js");

var _cstVisit = require("./cst-visit.js");

/** The byte order mark */
var BOM = "\uFEFF";
/** Start of doc-mode */

exports.BOM = BOM;
var DOCUMENT = '\x02'; // C0: Start of Text

/** Unexpected end of flow-mode */

exports.DOCUMENT = DOCUMENT;
var FLOW_END = '\x18'; // C0: Cancel

/** Next token is a scalar value */

exports.FLOW_END = FLOW_END;
var SCALAR = '\x1f'; // C0: Unit Separator

/** @returns `true` if `token` is a flow or block collection */

exports.SCALAR = SCALAR;

var isCollection = function isCollection(token) {
  return !!token && 'items' in token;
};
/** @returns `true` if `token` is a flow or block scalar; not an alias */


exports.isCollection = isCollection;

var isScalar = function isScalar(token) {
  return !!token && (token.type === 'scalar' || token.type === 'single-quoted-scalar' || token.type === 'double-quoted-scalar' || token.type === 'block-scalar');
};
/* istanbul ignore next */

/** Get a printable representation of a lexer token */


exports.isScalar = isScalar;

function prettyToken(token) {
  switch (token) {
    case BOM:
      return '<BOM>';

    case DOCUMENT:
      return '<DOC>';

    case FLOW_END:
      return '<FLOW_END>';

    case SCALAR:
      return '<SCALAR>';

    default:
      return JSON.stringify(token);
  }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */


function tokenType(source) {
  switch (source) {
    case BOM:
      return 'byte-order-mark';

    case DOCUMENT:
      return 'doc-mode';

    case FLOW_END:
      return 'flow-error-end';

    case SCALAR:
      return 'scalar';

    case '---':
      return 'doc-start';

    case '...':
      return 'doc-end';

    case '':
    case '\n':
    case '\r\n':
      return 'newline';

    case '-':
      return 'seq-item-ind';

    case '?':
      return 'explicit-key-ind';

    case ':':
      return 'map-value-ind';

    case '{':
      return 'flow-map-start';

    case '}':
      return 'flow-map-end';

    case '[':
      return 'flow-seq-start';

    case ']':
      return 'flow-seq-end';

    case ',':
      return 'comma';
  }

  switch (source[0]) {
    case ' ':
    case '\t':
      return 'space';

    case '#':
      return 'comment';

    case '%':
      return 'directive-line';

    case '*':
      return 'alias';

    case '&':
      return 'anchor';

    case '!':
      return 'tag';

    case "'":
      return 'single-quoted-scalar';

    case '"':
      return 'double-quoted-scalar';

    case '|':
    case '>':
      return 'block-scalar-header';
  }

  return null;
}