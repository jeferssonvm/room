'use strict';

var Alias = require('../nodes/Alias.js');

var composeCollection = require('./compose-collection.js');

var composeScalar = require('./compose-scalar.js');

var resolveEnd = require('./resolve-end.js');

var utilEmptyScalarPosition = require('./util-empty-scalar-position.js');

var CN = {
  composeNode: composeNode,
  composeEmptyNode: composeEmptyNode
};

function composeNode(ctx, token, props, onError) {
  var spaceBefore = props.spaceBefore,
      comment = props.comment,
      anchor = props.anchor,
      tag = props.tag;
  var node;
  var isSrcToken = true;

  switch (token.type) {
    case 'alias':
      node = composeAlias(ctx, token, onError);
      if (anchor || tag) onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
      break;

    case 'scalar':
    case 'single-quoted-scalar':
    case 'double-quoted-scalar':
    case 'block-scalar':
      node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) node.anchor = anchor.source.substring(1);
      break;

    case 'block-map':
    case 'block-seq':
    case 'flow-collection':
      node = composeCollection.composeCollection(CN, ctx, token, tag, onError);
      if (anchor) node.anchor = anchor.source.substring(1);
      break;

    default:
      {
        var message = token.type === 'error' ? token.message : "Unsupported token (type: ".concat(token.type, ")");
        onError(token, 'UNEXPECTED_TOKEN', message);
        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
        isSrcToken = false;
      }
  }

  if (anchor && node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
  if (spaceBefore) node.spaceBefore = true;

  if (comment) {
    if (token.type === 'scalar' && token.source === '') node.comment = comment;else node.commentBefore = comment;
  } // @ts-expect-error Type checking misses meaning of isSrcToken


  if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
  return node;
}

function composeEmptyNode(ctx, offset, before, pos, _ref, onError) {
  var spaceBefore = _ref.spaceBefore,
      comment = _ref.comment,
      anchor = _ref.anchor,
      tag = _ref.tag,
      end = _ref.end;
  var token = {
    type: 'scalar',
    offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ''
  };
  var node = composeScalar.composeScalar(ctx, token, tag, onError);

  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
  }

  if (spaceBefore) node.spaceBefore = true;

  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }

  return node;
}

function composeAlias(_ref2, _ref3, onError) {
  var options = _ref2.options;
  var offset = _ref3.offset,
      source = _ref3.source,
      end = _ref3.end;
  var alias = new Alias.Alias(source.substring(1));
  if (alias.source === '') onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
  if (alias.source.endsWith(':')) onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
  var valueEnd = offset + source.length;
  var re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment) alias.comment = re.comment;
  return alias;
}

exports.composeEmptyNode = composeEmptyNode;
exports.composeNode = composeNode;