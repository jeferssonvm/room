'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var stringifyNumber = require('../../stringify/stringifyNumber.js');
/** Internal types handle bigint as number, because TS can't figure it out. */


function parseSexagesimal(str, asBigInt) {
  var sign = str[0];
  var parts = sign === '-' || sign === '+' ? str.substring(1) : str;

  var num = function num(n) {
    return asBigInt ? BigInt(n) : Number(n);
  };

  var res = parts.replace(/_/g, '').split(':').reduce(function (res, p) {
    return res * num(60) + num(p);
  }, num(0));
  return sign === '-' ? num(-1) * res : res;
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */


function stringifySexagesimal(node) {
  var value = node.value;

  var num = function num(n) {
    return n;
  };

  if (typeof value === 'bigint') num = function num(n) {
    return BigInt(n);
  };else if (isNaN(value) || !isFinite(value)) return stringifyNumber.stringifyNumber(node);
  var sign = '';

  if (value < 0) {
    sign = '-';
    value *= num(-1);
  }

  var _60 = num(60);

  var parts = [value % _60]; // seconds, including ms

  if (value < 60) {
    parts.unshift(0); // at least one : is required
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60); // minutes

    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value); // hours
    }
  }

  return sign + parts.map(function (n) {
    return String(n).padStart(2, '0');
  }).join(':').replace(/000000\d*$/, '') // % 60 may introduce error
  ;
}

var intTime = {
  identify: function identify(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
  },
  "default": true,
  tag: 'tag:yaml.org,2002:int',
  format: 'TIME',
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: function resolve(str, _onError, _ref) {
    var intAsBigInt = _ref.intAsBigInt;
    return parseSexagesimal(str, intAsBigInt);
  },
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: function identify(value) {
    return typeof value === 'number';
  },
  "default": true,
  tag: 'tag:yaml.org,2002:float',
  format: 'TIME',
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: function resolve(str) {
    return parseSexagesimal(str, false);
  },
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: function identify(value) {
    return value instanceof Date;
  },
  "default": true,
  tag: 'tag:yaml.org,2002:timestamp',
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
  '(?:' + // time is optional
  '(?:t|T|[ \\t]+)' + // t | T | whitespace
  '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
  '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
  ')?$'),
  resolve: function resolve(str) {
    var match = str.match(timestamp.test);
    if (!match) throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');

    var _match$map = match.map(Number),
        _match$map2 = _slicedToArray(_match$map, 7),
        year = _match$map2[1],
        month = _match$map2[2],
        day = _match$map2[3],
        hour = _match$map2[4],
        minute = _match$map2[5],
        second = _match$map2[6];

    var millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
    var date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    var tz = match[8];

    if (tz && tz !== 'Z') {
      var d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30) d *= 60;
      date -= 60000 * d;
    }

    return new Date(date);
  },
  stringify: function stringify(_ref2) {
    var value = _ref2.value;
    return value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '');
  }
};
exports.floatTime = floatTime;
exports.intTime = intTime;
exports.timestamp = timestamp;