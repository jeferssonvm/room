'use strict';

var Scalar = require('../../nodes/Scalar.js');

var stringifyString = require('../../stringify/stringifyString.js');

var binary = {
  identify: function identify(value) {
    return value instanceof Uint8Array;
  },
  "default": false,
  tag: 'tag:yaml.org,2002:binary',

  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve: function resolve(src, onError) {
    if (typeof Buffer === 'function') {
      return Buffer.from(src, 'base64');
    } else if (typeof atob === 'function') {
      // On IE 11, atob() can't handle newlines
      var str = atob(src.replace(/[\n\r]/g, ''));
      var buffer = new Uint8Array(str.length);

      for (var i = 0; i < str.length; ++i) {
        buffer[i] = str.charCodeAt(i);
      }

      return buffer;
    } else {
      onError('This environment does not support reading binary tags; either Buffer or atob is required');
      return src;
    }
  },
  stringify: function stringify(_ref, ctx, onComment, onChompKeep) {
    var comment = _ref.comment,
        type = _ref.type,
        value = _ref.value;
    var buf = value; // checked earlier by binary.identify()

    var str;

    if (typeof Buffer === 'function') {
      str = buf instanceof Buffer ? buf.toString('base64') : Buffer.from(buf.buffer).toString('base64');
    } else if (typeof btoa === 'function') {
      var s = '';

      for (var i = 0; i < buf.length; ++i) {
        s += String.fromCharCode(buf[i]);
      }

      str = btoa(s);
    } else {
      throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
    }

    if (!type) type = Scalar.Scalar.BLOCK_LITERAL;

    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      var lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      var n = Math.ceil(str.length / lineWidth);
      var lines = new Array(n);

      for (var _i = 0, o = 0; _i < n; ++_i, o += lineWidth) {
        lines[_i] = str.substr(o, lineWidth);
      }

      str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\n' : ' ');
    }

    return stringifyString.stringifyString({
      comment: comment,
      type: type,
      value: str
    }, ctx, onComment, onChompKeep);
  }
};
exports.binary = binary;