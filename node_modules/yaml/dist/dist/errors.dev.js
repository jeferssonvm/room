'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var YAMLError =
/*#__PURE__*/
function (_Error) {
  _inherits(YAMLError, _Error);

  function YAMLError(name, pos, code, message) {
    var _this;

    _classCallCheck(this, YAMLError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(YAMLError).call(this));
    _this.name = name;
    _this.code = code;
    _this.message = message;
    _this.pos = pos;
    return _this;
  }

  return YAMLError;
}(_wrapNativeSuper(Error));

var YAMLParseError =
/*#__PURE__*/
function (_YAMLError) {
  _inherits(YAMLParseError, _YAMLError);

  function YAMLParseError(pos, code, message) {
    _classCallCheck(this, YAMLParseError);

    return _possibleConstructorReturn(this, _getPrototypeOf(YAMLParseError).call(this, 'YAMLParseError', pos, code, message));
  }

  return YAMLParseError;
}(YAMLError);

var YAMLWarning =
/*#__PURE__*/
function (_YAMLError2) {
  _inherits(YAMLWarning, _YAMLError2);

  function YAMLWarning(pos, code, message) {
    _classCallCheck(this, YAMLWarning);

    return _possibleConstructorReturn(this, _getPrototypeOf(YAMLWarning).call(this, 'YAMLWarning', pos, code, message));
  }

  return YAMLWarning;
}(YAMLError);

var prettifyError = function prettifyError(src, lc) {
  return function (error) {
    if (error.pos[0] === -1) return;
    error.linePos = error.pos.map(function (pos) {
      return lc.linePos(pos);
    });
    var _error$linePos$ = error.linePos[0],
        line = _error$linePos$.line,
        col = _error$linePos$.col;
    error.message += " at line ".concat(line, ", column ").concat(col);
    var ci = col - 1;
    var lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, ''); // Trim to max 80 chars, keeping col position near the middle

    if (ci >= 60 && lineStr.length > 80) {
      var trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = '…' + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }

    if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + '…'; // Include previous line in context if pointing at line start

    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      // Regexp won't match if start is trimmed
      var prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80) prev = prev.substring(0, 79) + '…\n';
      lineStr = prev + lineStr;
    }

    if (/[^ ]/.test(lineStr)) {
      var count = 1;
      var end = error.linePos[1];

      if (end && end.line === line && end.col > col) {
        count = Math.max(1, Math.min(end.col - col, 80 - ci));
      }

      var pointer = ' '.repeat(ci) + '^'.repeat(count);
      error.message += ":\n\n".concat(lineStr, "\n").concat(pointer, "\n");
    }
  };
};

exports.YAMLError = YAMLError;
exports.YAMLParseError = YAMLParseError;
exports.YAMLWarning = YAMLWarning;
exports.prettifyError = prettifyError;