"use strict";

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keywords = require('./keywords');

var _types = require('./types');

var Scope = function Scope(startTokenIndex, endTokenIndex, isFunctionScope) {
  _classCallCheck(this, Scope);

  this.startTokenIndex = startTokenIndex;
  this.endTokenIndex = endTokenIndex;
  this.isFunctionScope = isFunctionScope;
};

exports.Scope = Scope;

var StateSnapshot = function StateSnapshot(potentialArrowAt, noAnonFunctionType, inDisallowConditionalTypesContext, tokensLength, scopesLength, pos, type, contextualKeyword, start, end, isType, scopeDepth, error) {
  _classCallCheck(this, StateSnapshot);

  ;
  this.potentialArrowAt = potentialArrowAt;
  this.noAnonFunctionType = noAnonFunctionType;
  this.inDisallowConditionalTypesContext = inDisallowConditionalTypesContext;
  this.tokensLength = tokensLength;
  this.scopesLength = scopesLength;
  this.pos = pos;
  this.type = type;
  this.contextualKeyword = contextualKeyword;
  this.start = start;
  this.end = end;
  this.isType = isType;
  this.scopeDepth = scopeDepth;
  this.error = error;
};

exports.StateSnapshot = StateSnapshot;

var State =
/*#__PURE__*/
function () {
  function State() {
    _classCallCheck(this, State);

    State.prototype.__init.call(this);

    State.prototype.__init2.call(this);

    State.prototype.__init3.call(this);

    State.prototype.__init4.call(this);

    State.prototype.__init5.call(this);

    State.prototype.__init6.call(this);

    State.prototype.__init7.call(this);

    State.prototype.__init8.call(this);

    State.prototype.__init9.call(this);

    State.prototype.__init10.call(this);

    State.prototype.__init11.call(this);

    State.prototype.__init12.call(this);

    State.prototype.__init13.call(this);
  } // Used to signify the start of a potential arrow function


  _createClass(State, [{
    key: "__init",
    value: function __init() {
      this.potentialArrowAt = -1;
    } // Used by Flow to handle an edge case involving function type parsing.

  }, {
    key: "__init2",
    value: function __init2() {
      this.noAnonFunctionType = false;
    } // Used by TypeScript to handle ambiguities when parsing conditional types.

  }, {
    key: "__init3",
    value: function __init3() {
      this.inDisallowConditionalTypesContext = false;
    } // Token store.

  }, {
    key: "__init4",
    value: function __init4() {
      this.tokens = [];
    } // Array of all observed scopes, ordered by their ending position.

  }, {
    key: "__init5",
    value: function __init5() {
      this.scopes = [];
    } // The current position of the tokenizer in the input.

  }, {
    key: "__init6",
    value: function __init6() {
      this.pos = 0;
    } // Information about the current token.

  }, {
    key: "__init7",
    value: function __init7() {
      this.type = _types.TokenType.eof;
    }
  }, {
    key: "__init8",
    value: function __init8() {
      this.contextualKeyword = _keywords.ContextualKeyword.NONE;
    }
  }, {
    key: "__init9",
    value: function __init9() {
      this.start = 0;
    }
  }, {
    key: "__init10",
    value: function __init10() {
      this.end = 0;
    }
  }, {
    key: "__init11",
    value: function __init11() {
      this.isType = false;
    }
  }, {
    key: "__init12",
    value: function __init12() {
      this.scopeDepth = 0;
    }
    /**
     * If the parser is in an error state, then the token is always tt.eof and all functions can
     * keep executing but should be written so they don't get into an infinite loop in this situation.
     *
     * This approach, combined with the ability to snapshot and restore state, allows us to implement
     * backtracking without exceptions and without needing to explicitly propagate error states
     * everywhere.
     */

  }, {
    key: "__init13",
    value: function __init13() {
      this.error = null;
    }
  }, {
    key: "snapshot",
    value: function snapshot() {
      return new StateSnapshot(this.potentialArrowAt, this.noAnonFunctionType, this.inDisallowConditionalTypesContext, this.tokens.length, this.scopes.length, this.pos, this.type, this.contextualKeyword, this.start, this.end, this.isType, this.scopeDepth, this.error);
    }
  }, {
    key: "restoreFromSnapshot",
    value: function restoreFromSnapshot(snapshot) {
      this.potentialArrowAt = snapshot.potentialArrowAt;
      this.noAnonFunctionType = snapshot.noAnonFunctionType;
      this.inDisallowConditionalTypesContext = snapshot.inDisallowConditionalTypesContext;
      this.tokens.length = snapshot.tokensLength;
      this.scopes.length = snapshot.scopesLength;
      this.pos = snapshot.pos;
      this.type = snapshot.type;
      this.contextualKeyword = snapshot.contextualKeyword;
      this.start = snapshot.start;
      this.end = snapshot.end;
      this.isType = snapshot.isType;
      this.scopeDepth = snapshot.scopeDepth;
      this.error = snapshot.error;
    }
  }]);

  return State;
}();

exports["default"] = State;