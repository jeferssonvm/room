"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IS_IDENTIFIER_START = exports.IS_IDENTIFIER_CHAR = void 0;

var _charcodes = require("./charcodes");

var _whitespace = require("./whitespace");

function computeIsIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code < 128) return false;
  throw new Error("Should not be called with non-ASCII char code.");
}

var IS_IDENTIFIER_CHAR = new Uint8Array(65536);
exports.IS_IDENTIFIER_CHAR = IS_IDENTIFIER_CHAR;

for (var i = 0; i < 128; i++) {
  IS_IDENTIFIER_CHAR[i] = computeIsIdentifierChar(i) ? 1 : 0;
}

for (var _i = 128; _i < 65536; _i++) {
  IS_IDENTIFIER_CHAR[_i] = 1;
} // Aside from whitespace and newlines, all characters outside the ASCII space are either
// identifier characters or invalid. Since we're not performing code validation, we can just
// treat all invalid characters as identifier characters.


var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = undefined;

try {
  for (var _iterator = _whitespace.WHITESPACE_CHARS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    var whitespaceChar = _step.value;
    IS_IDENTIFIER_CHAR[whitespaceChar] = 0;
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
      _iterator["return"]();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}

IS_IDENTIFIER_CHAR[0x2028] = 0;
IS_IDENTIFIER_CHAR[0x2029] = 0;
var IS_IDENTIFIER_START = IS_IDENTIFIER_CHAR.slice();
exports.IS_IDENTIFIER_START = IS_IDENTIFIER_START;

for (var numChar = _charcodes.charCodes.digit0; numChar <= _charcodes.charCodes.digit9; numChar++) {
  IS_IDENTIFIER_START[numChar] = 0;
}