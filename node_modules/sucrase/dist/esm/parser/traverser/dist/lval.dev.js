"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseSpread = parseSpread;
exports.parseRest = parseRest;
exports.parseBindingIdentifier = parseBindingIdentifier;
exports.parseImportedIdentifier = parseImportedIdentifier;
exports.markPriorBindingIdentifier = markPriorBindingIdentifier;
exports.parseBindingAtom = parseBindingAtom;
exports.parseBindingList = parseBindingList;
exports.parseMaybeDefault = parseMaybeDefault;

var _flow = require("../plugins/flow");

var _typescript = require("../plugins/typescript");

var _index = require("../tokenizer/index");

var _keywords = require("../tokenizer/keywords");

var _types = require("../tokenizer/types");

var _base = require("./base");

var _expression = require("./expression");

var _util = require("./util");

function parseSpread() {
  (0, _index.next)();
  (0, _expression.parseMaybeAssign)(false);
}

function parseRest(isBlockScope) {
  (0, _index.next)();
  parseBindingAtom(isBlockScope);
}

function parseBindingIdentifier(isBlockScope) {
  (0, _expression.parseIdentifier)();
  markPriorBindingIdentifier(isBlockScope);
}

function parseImportedIdentifier() {
  (0, _expression.parseIdentifier)();
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
}

function markPriorBindingIdentifier(isBlockScope) {
  var identifierRole;

  if (_base.state.scopeDepth === 0) {
    identifierRole = _index.IdentifierRole.TopLevelDeclaration;
  } else if (isBlockScope) {
    identifierRole = _index.IdentifierRole.BlockScopedDeclaration;
  } else {
    identifierRole = _index.IdentifierRole.FunctionScopedDeclaration;
  }

  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
} // Parses lvalue (assignable) atom.


function parseBindingAtom(isBlockScope) {
  switch (_base.state.type) {
    case _types.TokenType._this:
      {
        // In TypeScript, "this" may be the name of a parameter, so allow it.
        var oldIsType = (0, _index.pushTypeContext)(0);
        (0, _index.next)();
        (0, _index.popTypeContext)(oldIsType);
        return;
      }

    case _types.TokenType._yield:
    case _types.TokenType.name:
      {
        _base.state.type = _types.TokenType.name;
        parseBindingIdentifier(isBlockScope);
        return;
      }

    case _types.TokenType.bracketL:
      {
        (0, _index.next)();
        parseBindingList(_types.TokenType.bracketR, isBlockScope, true
        /* allowEmpty */
        );
        return;
      }

    case _types.TokenType.braceL:
      (0, _expression.parseObj)(true, isBlockScope);
      return;

    default:
      (0, _util.unexpected)();
  }
}

function parseBindingList(close, isBlockScope) {
  var allowEmpty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var allowModifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var contextId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var first = true;
  var hasRemovedComma = false;
  var firstItemTokenIndex = _base.state.tokens.length;

  while (!(0, _index.eat)(close) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      (0, _util.expect)(_types.TokenType.comma);
      _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId; // After a "this" type in TypeScript, we need to set the following comma (if any) to also be
      // a type token so that it will be removed.

      if (!hasRemovedComma && _base.state.tokens[firstItemTokenIndex].isType) {
        _base.state.tokens[_base.state.tokens.length - 1].isType = true;
        hasRemovedComma = true;
      }
    }

    if (allowEmpty && (0, _index.match)(_types.TokenType.comma)) {// Empty item; nothing further to parse for this item.
    } else if ((0, _index.eat)(close)) {
      break;
    } else if ((0, _index.match)(_types.TokenType.ellipsis)) {
      parseRest(isBlockScope);
      parseAssignableListItemTypes(); // Support rest element trailing commas allowed by TypeScript <2.9.

      (0, _index.eat)(_types.TokenType.comma);
      (0, _util.expect)(close);
      break;
    } else {
      parseAssignableListItem(allowModifiers, isBlockScope);
    }
  }
}

function parseAssignableListItem(allowModifiers, isBlockScope) {
  if (allowModifiers) {
    (0, _typescript.tsParseModifiers)([_keywords.ContextualKeyword._public, _keywords.ContextualKeyword._protected, _keywords.ContextualKeyword._private, _keywords.ContextualKeyword._readonly, _keywords.ContextualKeyword._override]);
  }

  parseMaybeDefault(isBlockScope);
  parseAssignableListItemTypes();
  parseMaybeDefault(isBlockScope, true
  /* leftAlreadyParsed */
  );
}

function parseAssignableListItemTypes() {
  if (_base.isFlowEnabled) {
    (0, _flow.flowParseAssignableListItemTypes)();
  } else if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseAssignableListItemTypes)();
  }
} // Parses assignment pattern around given atom if possible.


function parseMaybeDefault(isBlockScope) {
  var leftAlreadyParsed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!leftAlreadyParsed) {
    parseBindingAtom(isBlockScope);
  }

  if (!(0, _index.eat)(_types.TokenType.eq)) {
    return;
  }

  var eqIndex = _base.state.tokens.length - 1;
  (0, _expression.parseMaybeAssign)();
  _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
}