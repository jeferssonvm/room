"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isContextual = isContextual;
exports.isLookaheadContextual = isLookaheadContextual;
exports.eatContextual = eatContextual;
exports.expectContextual = expectContextual;
exports.canInsertSemicolon = canInsertSemicolon;
exports.hasPrecedingLineBreak = hasPrecedingLineBreak;
exports.hasFollowingLineBreak = hasFollowingLineBreak;
exports.isLineTerminator = isLineTerminator;
exports.semicolon = semicolon;
exports.expect = expect;
exports.unexpected = unexpected;

var _index = require("../tokenizer/index");

var _types = require("../tokenizer/types");

var _charcodes = require("../util/charcodes");

var _base = require("./base");

// ## Parser utilities
// Tests whether parsed token is a contextual keyword.
function isContextual(contextualKeyword) {
  return _base.state.contextualKeyword === contextualKeyword;
}

function isLookaheadContextual(contextualKeyword) {
  var l = (0, _index.lookaheadTypeAndKeyword)();
  return l.type === _types.TokenType.name && l.contextualKeyword === contextualKeyword;
} // Consumes contextual keyword if possible.


function eatContextual(contextualKeyword) {
  return _base.state.contextualKeyword === contextualKeyword && (0, _index.eat)(_types.TokenType.name);
} // Asserts that following token is given contextual keyword.


function expectContextual(contextualKeyword) {
  if (!eatContextual(contextualKeyword)) {
    unexpected();
  }
} // Test whether a semicolon can be inserted at the current position.


function canInsertSemicolon() {
  return (0, _index.match)(_types.TokenType.eof) || (0, _index.match)(_types.TokenType.braceR) || hasPrecedingLineBreak();
}

function hasPrecedingLineBreak() {
  var prevToken = _base.state.tokens[_base.state.tokens.length - 1];
  var lastTokEnd = prevToken ? prevToken.end : 0;

  for (var i = lastTokEnd; i < _base.state.start; i++) {
    var code = _base.input.charCodeAt(i);

    if (code === _charcodes.charCodes.lineFeed || code === _charcodes.charCodes.carriageReturn || code === 0x2028 || code === 0x2029) {
      return true;
    }
  }

  return false;
}

function hasFollowingLineBreak() {
  var nextStart = (0, _index.nextTokenStart)();

  for (var i = _base.state.end; i < nextStart; i++) {
    var code = _base.input.charCodeAt(i);

    if (code === _charcodes.charCodes.lineFeed || code === _charcodes.charCodes.carriageReturn || code === 0x2028 || code === 0x2029) {
      return true;
    }
  }

  return false;
}

function isLineTerminator() {
  return (0, _index.eat)(_types.TokenType.semi) || canInsertSemicolon();
} // Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.


function semicolon() {
  if (!isLineTerminator()) {
    unexpected('Unexpected token, expected ";"');
  }
} // Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error at given pos.


function expect(type) {
  var matched = (0, _index.eat)(type);

  if (!matched) {
    unexpected("Unexpected token, expected \"".concat((0, _types.formatTokenType)(type), "\""));
  }
}
/**
 * Transition the parser to an error state. All code needs to be written to naturally unwind in this
 * state, which allows us to backtrack without exceptions and without error plumbing everywhere.
 */


function unexpected() {
  var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "Unexpected token";
  var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _base.state.start;

  if (_base.state.error) {
    return;
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  var err = new SyntaxError(message);
  err.pos = pos;
  _base.state.error = err;
  _base.state.pos = _base.input.length;
  (0, _index.finishToken)(_types.TokenType.eof);
}