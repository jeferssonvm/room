"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseTopLevel = parseTopLevel;
exports.parseStatement = parseStatement;
exports.parseDecorators = parseDecorators;
exports.baseParseMaybeDecoratorArguments = baseParseMaybeDecoratorArguments;
exports.parseVarStatement = parseVarStatement;
exports.parseBlock = parseBlock;
exports.parseBlockBody = parseBlockBody;
exports.parseFunction = parseFunction;
exports.parseFunctionParams = parseFunctionParams;
exports.parseClass = parseClass;
exports.parseClassPropertyName = parseClassPropertyName;
exports.parsePostMemberNameModifiers = parsePostMemberNameModifiers;
exports.parseClassProperty = parseClassProperty;
exports.parseExport = parseExport;
exports.parseExportFrom = parseExportFrom;
exports.baseParseExportStar = baseParseExportStar;
exports.parseExportSpecifiers = parseExportSpecifiers;
exports.parseImport = parseImport;

var _index = require("../index");

var _flow = require("../plugins/flow");

var _typescript = require("../plugins/typescript");

var _tokenizer = require("../tokenizer");

var _keywords = require("../tokenizer/keywords");

var _state = require("../tokenizer/state");

var _types = require("../tokenizer/types");

var _charcodes = require("../util/charcodes");

var _base = require("./base");

var _expression = require("./expression");

var _lval = require("./lval");

var _util = require("./util");

/* eslint max-len: 0 */
function parseTopLevel() {
  parseBlockBody(_types.TokenType.eof);

  _base.state.scopes.push(new _state.Scope(0, _base.state.tokens.length, true));

  if (_base.state.scopeDepth !== 0) {
    throw new Error("Invalid scope depth at end of file: ".concat(_base.state.scopeDepth));
  }

  return new _index.File(_base.state.tokens, _base.state.scopes);
} // Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.


function parseStatement(declaration) {
  if (_base.isFlowEnabled) {
    if ((0, _flow.flowTryParseStatement)()) {
      return;
    }
  }

  if ((0, _tokenizer.match)(_types.TokenType.at)) {
    parseDecorators();
  }

  parseStatementContent(declaration);
}

function parseStatementContent(declaration) {
  if (_base.isTypeScriptEnabled) {
    if ((0, _typescript.tsTryParseStatementContent)()) {
      return;
    }
  }

  var starttype = _base.state.type; // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case _types.TokenType._break:
    case _types.TokenType._continue:
      parseBreakContinueStatement();
      return;

    case _types.TokenType._debugger:
      parseDebuggerStatement();
      return;

    case _types.TokenType._do:
      parseDoStatement();
      return;

    case _types.TokenType._for:
      parseForStatement();
      return;

    case _types.TokenType._function:
      if ((0, _tokenizer.lookaheadType)() === _types.TokenType.dot) break;
      if (!declaration) (0, _util.unexpected)();
      parseFunctionStatement();
      return;

    case _types.TokenType._class:
      if (!declaration) (0, _util.unexpected)();
      parseClass(true);
      return;

    case _types.TokenType._if:
      parseIfStatement();
      return;

    case _types.TokenType._return:
      parseReturnStatement();
      return;

    case _types.TokenType._switch:
      parseSwitchStatement();
      return;

    case _types.TokenType._throw:
      parseThrowStatement();
      return;

    case _types.TokenType._try:
      parseTryStatement();
      return;

    case _types.TokenType._let:
    case _types.TokenType._const:
      if (!declaration) (0, _util.unexpected)();
    // NOTE: falls through to _var

    case _types.TokenType._var:
      parseVarStatement(starttype !== _types.TokenType._var);
      return;

    case _types.TokenType._while:
      parseWhileStatement();
      return;

    case _types.TokenType.braceL:
      parseBlock();
      return;

    case _types.TokenType.semi:
      parseEmptyStatement();
      return;

    case _types.TokenType._export:
    case _types.TokenType._import:
      {
        var nextType = (0, _tokenizer.lookaheadType)();

        if (nextType === _types.TokenType.parenL || nextType === _types.TokenType.dot) {
          break;
        }

        (0, _tokenizer.next)();

        if (starttype === _types.TokenType._import) {
          parseImport();
        } else {
          parseExport();
        }

        return;
      }

    case _types.TokenType.name:
      if (_base.state.contextualKeyword === _keywords.ContextualKeyword._async) {
        var functionStart = _base.state.start; // peek ahead and see if next token is a function

        var snapshot = _base.state.snapshot();

        (0, _tokenizer.next)();

        if ((0, _tokenizer.match)(_types.TokenType._function) && !(0, _util.canInsertSemicolon)()) {
          (0, _util.expect)(_types.TokenType._function);
          parseFunction(functionStart, true);
          return;
        } else {
          _base.state.restoreFromSnapshot(snapshot);
        }
      } else if (_base.state.contextualKeyword === _keywords.ContextualKeyword._using && !(0, _util.hasFollowingLineBreak)() && // Statements like `using[0]` and `using in foo` aren't actual using
      // declarations.
      (0, _tokenizer.lookaheadType)() === _types.TokenType.name) {
        parseVarStatement(true);
        return;
      } else if (startsAwaitUsing()) {
        (0, _util.expectContextual)(_keywords.ContextualKeyword._await);
        parseVarStatement(true);
        return;
      }

    default:
      // Do nothing.
      break;
  } // If the statement does not start with a statement keyword or a
  // brace, it's an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.


  var initialTokensLength = _base.state.tokens.length;
  (0, _expression.parseExpression)();
  var simpleName = null;

  if (_base.state.tokens.length === initialTokensLength + 1) {
    var token = _base.state.tokens[_base.state.tokens.length - 1];

    if (token.type === _types.TokenType.name) {
      simpleName = token.contextualKeyword;
    }
  }

  if (simpleName == null) {
    (0, _util.semicolon)();
    return;
  }

  if ((0, _tokenizer.eat)(_types.TokenType.colon)) {
    parseLabeledStatement();
  } else {
    // This was an identifier, so we might want to handle flow/typescript-specific cases.
    parseIdentifierStatement(simpleName);
  }
}
/**
 * Determine if we're positioned at an `await using` declaration.
 *
 * Note that this can happen either in place of a regular variable declaration
 * or in a loop body, and in both places, there are similar-looking cases where
 * we need to return false.
 *
 * Examples returning true:
 * await using foo = bar();
 * for (await using a of b) {}
 *
 * Examples returning false:
 * await using
 * await using + 1
 * await using instanceof T
 * for (await using;;) {}
 *
 * For now, we early return if we don't see `await`, then do a simple
 * backtracking-based lookahead for the `using` and identifier tokens. In the
 * future, this could be optimized with a character-based approach.
 */


function startsAwaitUsing() {
  if (!(0, _util.isContextual)(_keywords.ContextualKeyword._await)) {
    return false;
  }

  var snapshot = _base.state.snapshot(); // await


  (0, _tokenizer.next)();

  if (!(0, _util.isContextual)(_keywords.ContextualKeyword._using) || (0, _util.hasPrecedingLineBreak)()) {
    _base.state.restoreFromSnapshot(snapshot);

    return false;
  } // using


  (0, _tokenizer.next)();

  if (!(0, _tokenizer.match)(_types.TokenType.name) || (0, _util.hasPrecedingLineBreak)()) {
    _base.state.restoreFromSnapshot(snapshot);

    return false;
  }

  _base.state.restoreFromSnapshot(snapshot);

  return true;
}

function parseDecorators() {
  while ((0, _tokenizer.match)(_types.TokenType.at)) {
    parseDecorator();
  }
}

function parseDecorator() {
  (0, _tokenizer.next)();

  if ((0, _tokenizer.eat)(_types.TokenType.parenL)) {
    (0, _expression.parseExpression)();
    (0, _util.expect)(_types.TokenType.parenR);
  } else {
    (0, _expression.parseIdentifier)();

    while ((0, _tokenizer.eat)(_types.TokenType.dot)) {
      (0, _expression.parseIdentifier)();
    }

    parseMaybeDecoratorArguments();
  }
}

function parseMaybeDecoratorArguments() {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseMaybeDecoratorArguments)();
  } else {
    baseParseMaybeDecoratorArguments();
  }
}

function baseParseMaybeDecoratorArguments() {
  if ((0, _tokenizer.eat)(_types.TokenType.parenL)) {
    (0, _expression.parseCallExpressionArguments)();
  }
}

function parseBreakContinueStatement() {
  (0, _tokenizer.next)();

  if (!(0, _util.isLineTerminator)()) {
    (0, _expression.parseIdentifier)();
    (0, _util.semicolon)();
  }
}

function parseDebuggerStatement() {
  (0, _tokenizer.next)();
  (0, _util.semicolon)();
}

function parseDoStatement() {
  (0, _tokenizer.next)();
  parseStatement(false);
  (0, _util.expect)(_types.TokenType._while);
  (0, _expression.parseParenExpression)();
  (0, _tokenizer.eat)(_types.TokenType.semi);
}

function parseForStatement() {
  _base.state.scopeDepth++;
  var startTokenIndex = _base.state.tokens.length;
  parseAmbiguousForStatement();
  var endTokenIndex = _base.state.tokens.length;

  _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, false));

  _base.state.scopeDepth--;
}
/**
 * Determine if this token is a `using` declaration (explicit resource
 * management) as part of a loop.
 * https://github.com/tc39/proposal-explicit-resource-management
 */


function isUsingInLoop() {
  if (!(0, _util.isContextual)(_keywords.ContextualKeyword._using)) {
    return false;
  } // This must be `for (using of`, where `using` is the name of the loop
  // variable.


  if ((0, _util.isLookaheadContextual)(_keywords.ContextualKeyword._of)) {
    return false;
  }

  return true;
} // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.


function parseAmbiguousForStatement() {
  (0, _tokenizer.next)();
  var forAwait = false;

  if ((0, _util.isContextual)(_keywords.ContextualKeyword._await)) {
    forAwait = true;
    (0, _tokenizer.next)();
  }

  (0, _util.expect)(_types.TokenType.parenL);

  if ((0, _tokenizer.match)(_types.TokenType.semi)) {
    if (forAwait) {
      (0, _util.unexpected)();
    }

    parseFor();
    return;
  }

  var isAwaitUsing = startsAwaitUsing();

  if (isAwaitUsing || (0, _tokenizer.match)(_types.TokenType._var) || (0, _tokenizer.match)(_types.TokenType._let) || (0, _tokenizer.match)(_types.TokenType._const) || isUsingInLoop()) {
    if (isAwaitUsing) {
      (0, _util.expectContextual)(_keywords.ContextualKeyword._await);
    }

    (0, _tokenizer.next)();
    parseVar(true, _base.state.type !== _types.TokenType._var);

    if ((0, _tokenizer.match)(_types.TokenType._in) || (0, _util.isContextual)(_keywords.ContextualKeyword._of)) {
      parseForIn(forAwait);
      return;
    }

    parseFor();
    return;
  }

  (0, _expression.parseExpression)(true);

  if ((0, _tokenizer.match)(_types.TokenType._in) || (0, _util.isContextual)(_keywords.ContextualKeyword._of)) {
    parseForIn(forAwait);
    return;
  }

  if (forAwait) {
    (0, _util.unexpected)();
  }

  parseFor();
}

function parseFunctionStatement() {
  var functionStart = _base.state.start;
  (0, _tokenizer.next)();
  parseFunction(functionStart, true);
}

function parseIfStatement() {
  (0, _tokenizer.next)();
  (0, _expression.parseParenExpression)();
  parseStatement(false);

  if ((0, _tokenizer.eat)(_types.TokenType._else)) {
    parseStatement(false);
  }
}

function parseReturnStatement() {
  (0, _tokenizer.next)(); // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (!(0, _util.isLineTerminator)()) {
    (0, _expression.parseExpression)();
    (0, _util.semicolon)();
  }
}

function parseSwitchStatement() {
  (0, _tokenizer.next)();
  (0, _expression.parseParenExpression)();
  _base.state.scopeDepth++;
  var startTokenIndex = _base.state.tokens.length;
  (0, _util.expect)(_types.TokenType.braceL); // Don't bother validation; just go through any sequence of cases, defaults, and statements.

  while (!(0, _tokenizer.match)(_types.TokenType.braceR) && !_base.state.error) {
    if ((0, _tokenizer.match)(_types.TokenType._case) || (0, _tokenizer.match)(_types.TokenType._default)) {
      var isCase = (0, _tokenizer.match)(_types.TokenType._case);
      (0, _tokenizer.next)();

      if (isCase) {
        (0, _expression.parseExpression)();
      }

      (0, _util.expect)(_types.TokenType.colon);
    } else {
      parseStatement(true);
    }
  }

  (0, _tokenizer.next)(); // Closing brace

  var endTokenIndex = _base.state.tokens.length;

  _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, false));

  _base.state.scopeDepth--;
}

function parseThrowStatement() {
  (0, _tokenizer.next)();
  (0, _expression.parseExpression)();
  (0, _util.semicolon)();
}

function parseCatchClauseParam() {
  (0, _lval.parseBindingAtom)(true
  /* isBlockScope */
  );

  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsTryParseTypeAnnotation)();
  }
}

function parseTryStatement() {
  (0, _tokenizer.next)();
  parseBlock();

  if ((0, _tokenizer.match)(_types.TokenType._catch)) {
    (0, _tokenizer.next)();
    var catchBindingStartTokenIndex = null;

    if ((0, _tokenizer.match)(_types.TokenType.parenL)) {
      _base.state.scopeDepth++;
      catchBindingStartTokenIndex = _base.state.tokens.length;
      (0, _util.expect)(_types.TokenType.parenL);
      parseCatchClauseParam();
      (0, _util.expect)(_types.TokenType.parenR);
    }

    parseBlock();

    if (catchBindingStartTokenIndex != null) {
      // We need a special scope for the catch binding which includes the binding itself and the
      // catch block.
      var endTokenIndex = _base.state.tokens.length;

      _base.state.scopes.push(new _state.Scope(catchBindingStartTokenIndex, endTokenIndex, false));

      _base.state.scopeDepth--;
    }
  }

  if ((0, _tokenizer.eat)(_types.TokenType._finally)) {
    parseBlock();
  }
}

function parseVarStatement(isBlockScope) {
  (0, _tokenizer.next)();
  parseVar(false, isBlockScope);
  (0, _util.semicolon)();
}

function parseWhileStatement() {
  (0, _tokenizer.next)();
  (0, _expression.parseParenExpression)();
  parseStatement(false);
}

function parseEmptyStatement() {
  (0, _tokenizer.next)();
}

function parseLabeledStatement() {
  parseStatement(true);
}
/**
 * Parse a statement starting with an identifier of the given name. Subclasses match on the name
 * to handle statements like "declare".
 */


function parseIdentifierStatement(contextualKeyword) {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseIdentifierStatement)(contextualKeyword);
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowParseIdentifierStatement)(contextualKeyword);
  } else {
    (0, _util.semicolon)();
  }
} // Parse a semicolon-enclosed block of statements.


function parseBlock() {
  var isFunctionScope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var contextId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var startTokenIndex = _base.state.tokens.length;
  _base.state.scopeDepth++;
  (0, _util.expect)(_types.TokenType.braceL);

  if (contextId) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
  }

  parseBlockBody(_types.TokenType.braceR);

  if (contextId) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
  }

  var endTokenIndex = _base.state.tokens.length;

  _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, isFunctionScope));

  _base.state.scopeDepth--;
}

function parseBlockBody(end) {
  while (!(0, _tokenizer.eat)(end) && !_base.state.error) {
    parseStatement(true);
  }
} // Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.


function parseFor() {
  (0, _util.expect)(_types.TokenType.semi);

  if (!(0, _tokenizer.match)(_types.TokenType.semi)) {
    (0, _expression.parseExpression)();
  }

  (0, _util.expect)(_types.TokenType.semi);

  if (!(0, _tokenizer.match)(_types.TokenType.parenR)) {
    (0, _expression.parseExpression)();
  }

  (0, _util.expect)(_types.TokenType.parenR);
  parseStatement(false);
} // Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.


function parseForIn(forAwait) {
  if (forAwait) {
    (0, _util.eatContextual)(_keywords.ContextualKeyword._of);
  } else {
    (0, _tokenizer.next)();
  }

  (0, _expression.parseExpression)();
  (0, _util.expect)(_types.TokenType.parenR);
  parseStatement(false);
} // Parse a list of variable declarations.


function parseVar(isFor, isBlockScope) {
  while (true) {
    parseVarHead(isBlockScope);

    if ((0, _tokenizer.eat)(_types.TokenType.eq)) {
      var eqIndex = _base.state.tokens.length - 1;
      (0, _expression.parseMaybeAssign)(isFor);
      _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
    }

    if (!(0, _tokenizer.eat)(_types.TokenType.comma)) {
      break;
    }
  }
}

function parseVarHead(isBlockScope) {
  (0, _lval.parseBindingAtom)(isBlockScope);

  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsAfterParseVarHead)();
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowAfterParseVarHead)();
  }
} // Parse a function declaration or literal (depending on the
// `isStatement` parameter).


function parseFunction(functionStart, isStatement) {
  var optionalId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if ((0, _tokenizer.match)(_types.TokenType.star)) {
    (0, _tokenizer.next)();
  }

  if (isStatement && !optionalId && !(0, _tokenizer.match)(_types.TokenType.name) && !(0, _tokenizer.match)(_types.TokenType._yield)) {
    (0, _util.unexpected)();
  }

  var nameScopeStartTokenIndex = null;

  if ((0, _tokenizer.match)(_types.TokenType.name)) {
    // Expression-style functions should limit their name's scope to the function body, so we make
    // a new function scope to enforce that.
    if (!isStatement) {
      nameScopeStartTokenIndex = _base.state.tokens.length;
      _base.state.scopeDepth++;
    }

    (0, _lval.parseBindingIdentifier)(false);
  }

  var startTokenIndex = _base.state.tokens.length;
  _base.state.scopeDepth++;
  parseFunctionParams();
  (0, _expression.parseFunctionBodyAndFinish)(functionStart);
  var endTokenIndex = _base.state.tokens.length; // In addition to the block scope of the function body, we need a separate function-style scope
  // that includes the params.

  _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, true));

  _base.state.scopeDepth--;

  if (nameScopeStartTokenIndex !== null) {
    _base.state.scopes.push(new _state.Scope(nameScopeStartTokenIndex, endTokenIndex, true));

    _base.state.scopeDepth--;
  }
}

function parseFunctionParams() {
  var allowModifiers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var funcContextId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsStartParseFunctionParams)();
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowStartParseFunctionParams)();
  }

  (0, _util.expect)(_types.TokenType.parenL);

  if (funcContextId) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = funcContextId;
  }

  (0, _lval.parseBindingList)(_types.TokenType.parenR, false
  /* isBlockScope */
  , false
  /* allowEmpty */
  , allowModifiers, funcContextId);

  if (funcContextId) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = funcContextId;
  }
} // Parse a class declaration or literal (depending on the
// `isStatement` parameter).


function parseClass(isStatement) {
  var optionalId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  // Put a context ID on the class keyword, the open-brace, and the close-brace, so that later
  // code can easily navigate to meaningful points on the class.
  var contextId = (0, _base.getNextContextId)();
  (0, _tokenizer.next)();
  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
  _base.state.tokens[_base.state.tokens.length - 1].isExpression = !isStatement; // Like with functions, we declare a special "name scope" from the start of the name to the end
  // of the class, but only with expression-style classes, to represent the fact that the name is
  // available to the body of the class but not an outer declaration.

  var nameScopeStartTokenIndex = null;

  if (!isStatement) {
    nameScopeStartTokenIndex = _base.state.tokens.length;
    _base.state.scopeDepth++;
  }

  parseClassId(isStatement, optionalId);
  parseClassSuper();
  var openBraceIndex = _base.state.tokens.length;
  parseClassBody(contextId);

  if (_base.state.error) {
    return;
  }

  _base.state.tokens[openBraceIndex].contextId = contextId;
  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;

  if (nameScopeStartTokenIndex !== null) {
    var endTokenIndex = _base.state.tokens.length;

    _base.state.scopes.push(new _state.Scope(nameScopeStartTokenIndex, endTokenIndex, false));

    _base.state.scopeDepth--;
  }
}

function isClassProperty() {
  return (0, _tokenizer.match)(_types.TokenType.eq) || (0, _tokenizer.match)(_types.TokenType.semi) || (0, _tokenizer.match)(_types.TokenType.braceR) || (0, _tokenizer.match)(_types.TokenType.bang) || (0, _tokenizer.match)(_types.TokenType.colon);
}

function isClassMethod() {
  return (0, _tokenizer.match)(_types.TokenType.parenL) || (0, _tokenizer.match)(_types.TokenType.lessThan);
}

function parseClassBody(classContextId) {
  (0, _util.expect)(_types.TokenType.braceL);

  while (!(0, _tokenizer.eat)(_types.TokenType.braceR) && !_base.state.error) {
    if ((0, _tokenizer.eat)(_types.TokenType.semi)) {
      continue;
    }

    if ((0, _tokenizer.match)(_types.TokenType.at)) {
      parseDecorator();
      continue;
    }

    var memberStart = _base.state.start;
    parseClassMember(memberStart, classContextId);
  }
}

function parseClassMember(memberStart, classContextId) {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseModifiers)([_keywords.ContextualKeyword._declare, _keywords.ContextualKeyword._public, _keywords.ContextualKeyword._protected, _keywords.ContextualKeyword._private, _keywords.ContextualKeyword._override]);
  }

  var isStatic = false;

  if ((0, _tokenizer.match)(_types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._static) {
    (0, _expression.parseIdentifier)(); // eats 'static'

    if (isClassMethod()) {
      parseClassMethod(memberStart,
      /* isConstructor */
      false);
      return;
    } else if (isClassProperty()) {
      parseClassProperty();
      return;
    } // otherwise something static


    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._static;
    isStatic = true;

    if ((0, _tokenizer.match)(_types.TokenType.braceL)) {
      // This is a static block. Mark the word "static" with the class context ID for class element
      // detection and parse as a regular block.
      _base.state.tokens[_base.state.tokens.length - 1].contextId = classContextId;
      parseBlock();
      return;
    }
  }

  parseClassMemberWithIsStatic(memberStart, isStatic, classContextId);
}

function parseClassMemberWithIsStatic(memberStart, isStatic, classContextId) {
  if (_base.isTypeScriptEnabled) {
    if ((0, _typescript.tsTryParseClassMemberWithIsStatic)(isStatic)) {
      return;
    }
  }

  if ((0, _tokenizer.eat)(_types.TokenType.star)) {
    // a generator
    parseClassPropertyName(classContextId);
    parseClassMethod(memberStart,
    /* isConstructor */
    false);
    return;
  } // Get the identifier name so we can tell if it's actually a keyword like "async", "get", or
  // "set".


  parseClassPropertyName(classContextId);
  var isConstructor = false;
  var token = _base.state.tokens[_base.state.tokens.length - 1]; // We allow "constructor" as either an identifier or a string.

  if (token.contextualKeyword === _keywords.ContextualKeyword._constructor) {
    isConstructor = true;
  }

  parsePostMemberNameModifiers();

  if (isClassMethod()) {
    parseClassMethod(memberStart, isConstructor);
  } else if (isClassProperty()) {
    parseClassProperty();
  } else if (token.contextualKeyword === _keywords.ContextualKeyword._async && !(0, _util.isLineTerminator)()) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._async; // an async method

    var isGenerator = (0, _tokenizer.match)(_types.TokenType.star);

    if (isGenerator) {
      (0, _tokenizer.next)();
    } // The so-called parsed name would have been "async": get the real name.


    parseClassPropertyName(classContextId);
    parsePostMemberNameModifiers();
    parseClassMethod(memberStart, false
    /* isConstructor */
    );
  } else if ((token.contextualKeyword === _keywords.ContextualKeyword._get || token.contextualKeyword === _keywords.ContextualKeyword._set) && !((0, _util.isLineTerminator)() && (0, _tokenizer.match)(_types.TokenType.star))) {
    if (token.contextualKeyword === _keywords.ContextualKeyword._get) {
      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._get;
    } else {
      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._set;
    } // `get\n*` is an uninitialized property named 'get' followed by a generator.
    // a getter or setter
    // The so-called parsed name would have been "get/set": get the real name.


    parseClassPropertyName(classContextId);
    parseClassMethod(memberStart,
    /* isConstructor */
    false);
  } else if (token.contextualKeyword === _keywords.ContextualKeyword._accessor && !(0, _util.isLineTerminator)()) {
    parseClassPropertyName(classContextId);
    parseClassProperty();
  } else if ((0, _util.isLineTerminator)()) {
    // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
    parseClassProperty();
  } else {
    (0, _util.unexpected)();
  }
}

function parseClassMethod(functionStart, isConstructor) {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsTryParseTypeParameters)();
  } else if (_base.isFlowEnabled) {
    if ((0, _tokenizer.match)(_types.TokenType.lessThan)) {
      (0, _flow.flowParseTypeParameterDeclaration)();
    }
  }

  (0, _expression.parseMethod)(functionStart, isConstructor);
} // Return the name of the class property, if it is a simple identifier.


function parseClassPropertyName(classContextId) {
  (0, _expression.parsePropertyName)(classContextId);
}

function parsePostMemberNameModifiers() {
  if (_base.isTypeScriptEnabled) {
    var oldIsType = (0, _tokenizer.pushTypeContext)(0);
    (0, _tokenizer.eat)(_types.TokenType.question);
    (0, _tokenizer.popTypeContext)(oldIsType);
  }
}

function parseClassProperty() {
  if (_base.isTypeScriptEnabled) {
    (0, _tokenizer.eatTypeToken)(_types.TokenType.bang);
    (0, _typescript.tsTryParseTypeAnnotation)();
  } else if (_base.isFlowEnabled) {
    if ((0, _tokenizer.match)(_types.TokenType.colon)) {
      (0, _flow.flowParseTypeAnnotation)();
    }
  }

  if ((0, _tokenizer.match)(_types.TokenType.eq)) {
    var equalsTokenIndex = _base.state.tokens.length;
    (0, _tokenizer.next)();
    (0, _expression.parseMaybeAssign)();
    _base.state.tokens[equalsTokenIndex].rhsEndIndex = _base.state.tokens.length;
  }

  (0, _util.semicolon)();
}

function parseClassId(isStatement) {
  var optionalId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (_base.isTypeScriptEnabled && (!isStatement || optionalId) && (0, _util.isContextual)(_keywords.ContextualKeyword._implements)) {
    return;
  }

  if ((0, _tokenizer.match)(_types.TokenType.name)) {
    (0, _lval.parseBindingIdentifier)(true);
  }

  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsTryParseTypeParameters)();
  } else if (_base.isFlowEnabled) {
    if ((0, _tokenizer.match)(_types.TokenType.lessThan)) {
      (0, _flow.flowParseTypeParameterDeclaration)();
    }
  }
} // Returns true if there was a superclass.


function parseClassSuper() {
  var hasSuper = false;

  if ((0, _tokenizer.eat)(_types.TokenType._extends)) {
    (0, _expression.parseExprSubscripts)();
    hasSuper = true;
  } else {
    hasSuper = false;
  }

  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsAfterParseClassSuper)(hasSuper);
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowAfterParseClassSuper)(hasSuper);
  }
} // Parses module export declaration.


function parseExport() {
  var exportIndex = _base.state.tokens.length - 1;

  if (_base.isTypeScriptEnabled) {
    if ((0, _typescript.tsTryParseExport)()) {
      return;
    }
  } // export * from '...'


  if (shouldParseExportStar()) {
    parseExportStar();
  } else if (isExportDefaultSpecifier()) {
    // export default from
    (0, _expression.parseIdentifier)();

    if ((0, _tokenizer.match)(_types.TokenType.comma) && (0, _tokenizer.lookaheadType)() === _types.TokenType.star) {
      (0, _util.expect)(_types.TokenType.comma);
      (0, _util.expect)(_types.TokenType.star);
      (0, _util.expectContextual)(_keywords.ContextualKeyword._as);
      (0, _expression.parseIdentifier)();
    } else {
      parseExportSpecifiersMaybe();
    }

    parseExportFrom();
  } else if ((0, _tokenizer.eat)(_types.TokenType._default)) {
    // export default ...
    parseExportDefaultExpression();
  } else if (shouldParseExportDeclaration()) {
    parseExportDeclaration();
  } else {
    // export { x, y as z } [from '...']
    parseExportSpecifiers();
    parseExportFrom();
  }

  _base.state.tokens[exportIndex].rhsEndIndex = _base.state.tokens.length;
}

function parseExportDefaultExpression() {
  if (_base.isTypeScriptEnabled) {
    if ((0, _typescript.tsTryParseExportDefaultExpression)()) {
      return;
    }
  }

  if (_base.isFlowEnabled) {
    if ((0, _flow.flowTryParseExportDefaultExpression)()) {
      return;
    }
  }

  var functionStart = _base.state.start;

  if ((0, _tokenizer.eat)(_types.TokenType._function)) {
    parseFunction(functionStart, true, true);
  } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._async) && (0, _tokenizer.lookaheadType)() === _types.TokenType._function) {
    // async function declaration
    (0, _util.eatContextual)(_keywords.ContextualKeyword._async);
    (0, _tokenizer.eat)(_types.TokenType._function);
    parseFunction(functionStart, true, true);
  } else if ((0, _tokenizer.match)(_types.TokenType._class)) {
    parseClass(true, true);
  } else if ((0, _tokenizer.match)(_types.TokenType.at)) {
    parseDecorators();
    parseClass(true, true);
  } else {
    (0, _expression.parseMaybeAssign)();
    (0, _util.semicolon)();
  }
}

function parseExportDeclaration() {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseExportDeclaration)();
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowParseExportDeclaration)();
  } else {
    parseStatement(true);
  }
}

function isExportDefaultSpecifier() {
  if (_base.isTypeScriptEnabled && (0, _typescript.tsIsDeclarationStart)()) {
    return false;
  } else if (_base.isFlowEnabled && (0, _flow.flowShouldDisallowExportDefaultSpecifier)()) {
    return false;
  }

  if ((0, _tokenizer.match)(_types.TokenType.name)) {
    return _base.state.contextualKeyword !== _keywords.ContextualKeyword._async;
  }

  if (!(0, _tokenizer.match)(_types.TokenType._default)) {
    return false;
  }

  var _next = (0, _tokenizer.nextTokenStart)();

  var lookahead = (0, _tokenizer.lookaheadTypeAndKeyword)();
  var hasFrom = lookahead.type === _types.TokenType.name && lookahead.contextualKeyword === _keywords.ContextualKeyword._from;

  if (lookahead.type === _types.TokenType.comma) {
    return true;
  } // lookahead again when `export default from` is seen


  if (hasFrom) {
    var nextAfterFrom = _base.input.charCodeAt((0, _tokenizer.nextTokenStartSince)(_next + 4));

    return nextAfterFrom === _charcodes.charCodes.quotationMark || nextAfterFrom === _charcodes.charCodes.apostrophe;
  }

  return false;
}

function parseExportSpecifiersMaybe() {
  if ((0, _tokenizer.eat)(_types.TokenType.comma)) {
    parseExportSpecifiers();
  }
}

function parseExportFrom() {
  if ((0, _util.eatContextual)(_keywords.ContextualKeyword._from)) {
    (0, _expression.parseExprAtom)();
    maybeParseImportAttributes();
  }

  (0, _util.semicolon)();
}

function shouldParseExportStar() {
  if (_base.isFlowEnabled) {
    return (0, _flow.flowShouldParseExportStar)();
  } else {
    return (0, _tokenizer.match)(_types.TokenType.star);
  }
}

function parseExportStar() {
  if (_base.isFlowEnabled) {
    (0, _flow.flowParseExportStar)();
  } else {
    baseParseExportStar();
  }
}

function baseParseExportStar() {
  (0, _util.expect)(_types.TokenType.star);

  if ((0, _util.isContextual)(_keywords.ContextualKeyword._as)) {
    parseExportNamespace();
  } else {
    parseExportFrom();
  }
}

function parseExportNamespace() {
  (0, _tokenizer.next)();
  _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._as;
  (0, _expression.parseIdentifier)();
  parseExportSpecifiersMaybe();
  parseExportFrom();
}

function shouldParseExportDeclaration() {
  return _base.isTypeScriptEnabled && (0, _typescript.tsIsDeclarationStart)() || _base.isFlowEnabled && (0, _flow.flowShouldParseExportDeclaration)() || _base.state.type === _types.TokenType._var || _base.state.type === _types.TokenType._const || _base.state.type === _types.TokenType._let || _base.state.type === _types.TokenType._function || _base.state.type === _types.TokenType._class || (0, _util.isContextual)(_keywords.ContextualKeyword._async) || (0, _tokenizer.match)(_types.TokenType.at);
} // Parses a comma-separated list of module exports.


function parseExportSpecifiers() {
  var first = true; // export { x, y as z } [from '...']

  (0, _util.expect)(_types.TokenType.braceL);

  while (!(0, _tokenizer.eat)(_types.TokenType.braceR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      (0, _util.expect)(_types.TokenType.comma);

      if ((0, _tokenizer.eat)(_types.TokenType.braceR)) {
        break;
      }
    }

    parseExportSpecifier();
  }
}

function parseExportSpecifier() {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseExportSpecifier)();
    return;
  }

  (0, _expression.parseIdentifier)();
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ExportAccess;

  if ((0, _util.eatContextual)(_keywords.ContextualKeyword._as)) {
    (0, _expression.parseIdentifier)();
  }
}
/**
 * Starting at the `module` token in an import, determine if it was truly an
 * import reflection token or just looks like one.
 *
 * Returns true for:
 * import module foo from "foo";
 * import module from from "foo";
 *
 * Returns false for:
 * import module from "foo";
 * import module, {bar} from "foo";
 */


function isImportReflection() {
  var snapshot = _base.state.snapshot();

  (0, _util.expectContextual)(_keywords.ContextualKeyword._module);

  if ((0, _util.eatContextual)(_keywords.ContextualKeyword._from)) {
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._from)) {
      _base.state.restoreFromSnapshot(snapshot);

      return true;
    } else {
      _base.state.restoreFromSnapshot(snapshot);

      return false;
    }
  } else if ((0, _tokenizer.match)(_types.TokenType.comma)) {
    _base.state.restoreFromSnapshot(snapshot);

    return false;
  } else {
    _base.state.restoreFromSnapshot(snapshot);

    return true;
  }
}
/**
 * Eat the "module" token from the import reflection proposal.
 * https://github.com/tc39/proposal-import-reflection
 */


function parseMaybeImportReflection() {
  // isImportReflection does snapshot/restore, so only run it if we see the word
  // "module".
  if ((0, _util.isContextual)(_keywords.ContextualKeyword._module) && isImportReflection()) {
    (0, _tokenizer.next)();
  }
} // Parses import declaration.


function parseImport() {
  if (_base.isTypeScriptEnabled && (0, _tokenizer.match)(_types.TokenType.name) && (0, _tokenizer.lookaheadType)() === _types.TokenType.eq) {
    (0, _typescript.tsParseImportEqualsDeclaration)();
    return;
  }

  if (_base.isTypeScriptEnabled && (0, _util.isContextual)(_keywords.ContextualKeyword._type)) {
    var lookahead = (0, _tokenizer.lookaheadTypeAndKeyword)();

    if (lookahead.type === _types.TokenType.name && lookahead.contextualKeyword !== _keywords.ContextualKeyword._from) {
      // One of these `import type` cases:
      // import type T = require('T');
      // import type A from 'A';
      (0, _util.expectContextual)(_keywords.ContextualKeyword._type);

      if ((0, _tokenizer.lookaheadType)() === _types.TokenType.eq) {
        (0, _typescript.tsParseImportEqualsDeclaration)();
        return;
      } // If this is an `import type...from` statement, then we already ate the
      // type token, so proceed to the regular import parser.

    } else if (lookahead.type === _types.TokenType.star || lookahead.type === _types.TokenType.braceL) {
      // One of these `import type` cases, in which case we can eat the type token
      // and proceed as normal:
      // import type * as A from 'A';
      // import type {a} from 'A';
      (0, _util.expectContextual)(_keywords.ContextualKeyword._type);
    } // Otherwise, we are importing the name "type".

  } // import '...'


  if ((0, _tokenizer.match)(_types.TokenType.string)) {
    (0, _expression.parseExprAtom)();
  } else {
    parseMaybeImportReflection();
    parseImportSpecifiers();
    (0, _util.expectContextual)(_keywords.ContextualKeyword._from);
    (0, _expression.parseExprAtom)();
  }

  maybeParseImportAttributes();
  (0, _util.semicolon)();
} // eslint-disable-next-line no-unused-vars


function shouldParseDefaultImport() {
  return (0, _tokenizer.match)(_types.TokenType.name);
}

function parseImportSpecifierLocal() {
  (0, _lval.parseImportedIdentifier)();
} // Parses a comma-separated list of module imports.


function parseImportSpecifiers() {
  if (_base.isFlowEnabled) {
    (0, _flow.flowStartParseImportSpecifiers)();
  }

  var first = true;

  if (shouldParseDefaultImport()) {
    // import defaultObj, { x, y as z } from '...'
    parseImportSpecifierLocal();
    if (!(0, _tokenizer.eat)(_types.TokenType.comma)) return;
  }

  if ((0, _tokenizer.match)(_types.TokenType.star)) {
    (0, _tokenizer.next)();
    (0, _util.expectContextual)(_keywords.ContextualKeyword._as);
    parseImportSpecifierLocal();
    return;
  }

  (0, _util.expect)(_types.TokenType.braceL);

  while (!(0, _tokenizer.eat)(_types.TokenType.braceR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      // Detect an attempt to deep destructure
      if ((0, _tokenizer.eat)(_types.TokenType.colon)) {
        (0, _util.unexpected)("ES2015 named imports do not destructure. Use another statement for destructuring after the import.");
      }

      (0, _util.expect)(_types.TokenType.comma);

      if ((0, _tokenizer.eat)(_types.TokenType.braceR)) {
        break;
      }
    }

    parseImportSpecifier();
  }
}

function parseImportSpecifier() {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseImportSpecifier)();
    return;
  }

  if (_base.isFlowEnabled) {
    (0, _flow.flowParseImportSpecifier)();
    return;
  }

  (0, _lval.parseImportedIdentifier)();

  if ((0, _util.isContextual)(_keywords.ContextualKeyword._as)) {
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _tokenizer.IdentifierRole.ImportAccess;
    (0, _tokenizer.next)();
    (0, _lval.parseImportedIdentifier)();
  }
}
/**
 * Parse import attributes like `with {type: "json"}`, or the legacy form
 * `assert {type: "json"}`.
 *
 * Import attributes technically have their own syntax, but are always parseable
 * as a plain JS object, so just do that for simplicity.
 */


function maybeParseImportAttributes() {
  if ((0, _tokenizer.match)(_types.TokenType._with) || (0, _util.isContextual)(_keywords.ContextualKeyword._assert) && !(0, _util.hasPrecedingLineBreak)()) {
    (0, _tokenizer.next)();
    (0, _expression.parseObj)(false, false);
  }
}