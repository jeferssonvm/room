"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseExpression = parseExpression;
exports.parseMaybeAssign = parseMaybeAssign;
exports.baseParseMaybeAssign = baseParseMaybeAssign;
exports.baseParseConditional = baseParseConditional;
exports.parseMaybeUnary = parseMaybeUnary;
exports.parseExprSubscripts = parseExprSubscripts;
exports.baseParseSubscripts = baseParseSubscripts;
exports.baseParseSubscript = baseParseSubscript;
exports.atPossibleAsync = atPossibleAsync;
exports.parseCallExpressionArguments = parseCallExpressionArguments;
exports.parseExprAtom = parseExprAtom;
exports.parseLiteral = parseLiteral;
exports.parseParenExpression = parseParenExpression;
exports.parseArrow = parseArrow;
exports.parseTemplate = parseTemplate;
exports.parseObj = parseObj;
exports.parsePropertyName = parsePropertyName;
exports.parseMethod = parseMethod;
exports.parseArrowExpression = parseArrowExpression;
exports.parseFunctionBodyAndFinish = parseFunctionBodyAndFinish;
exports.parseFunctionBody = parseFunctionBody;
exports.parseIdentifier = parseIdentifier;
exports.StopState = void 0;

var _flow = require("../plugins/flow");

var _index = require("../plugins/jsx/index");

var _types = require("../plugins/types");

var _typescript = require("../plugins/typescript");

var _index2 = require("../tokenizer/index");

var _keywords = require("../tokenizer/keywords");

var _state = require("../tokenizer/state");

var _types2 = require("../tokenizer/types");

var _charcodes = require("../util/charcodes");

var _identifier = require("../util/identifier");

var _base = require("./base");

var _lval = require("./lval");

var _statement = require("./statement");

var _util = require("./util");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StopState = function StopState(stop) {
  _classCallCheck(this, StopState);

  this.stop = stop;
}; // ### Expression parsing
// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.


exports.StopState = StopState;

function parseExpression() {
  var noIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  parseMaybeAssign(noIn);

  if ((0, _index2.match)(_types2.TokenType.comma)) {
    while ((0, _index2.eat)(_types2.TokenType.comma)) {
      parseMaybeAssign(noIn);
    }
  }
}
/**
 * noIn is used when parsing a for loop so that we don't interpret a following "in" as the binary
 * operatior.
 * isWithinParens is used to indicate that we're parsing something that might be a comma expression
 * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).
 * In these cases, we should allow : and ?: after the initial "left" part.
 */


function parseMaybeAssign() {
  var noIn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var isWithinParens = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (_base.isTypeScriptEnabled) {
    return (0, _typescript.tsParseMaybeAssign)(noIn, isWithinParens);
  } else if (_base.isFlowEnabled) {
    return (0, _flow.flowParseMaybeAssign)(noIn, isWithinParens);
  } else {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
} // Parse an assignment expression. This includes applications of
// operators like `+=`.
// Returns true if the expression was an arrow function.


function baseParseMaybeAssign(noIn, isWithinParens) {
  if ((0, _index2.match)(_types2.TokenType._yield)) {
    parseYield();
    return false;
  }

  if ((0, _index2.match)(_types2.TokenType.parenL) || (0, _index2.match)(_types2.TokenType.name) || (0, _index2.match)(_types2.TokenType._yield)) {
    _base.state.potentialArrowAt = _base.state.start;
  }

  var wasArrow = parseMaybeConditional(noIn);

  if (isWithinParens) {
    parseParenItem();
  }

  if (_base.state.type & _types2.TokenType.IS_ASSIGN) {
    (0, _index2.next)();
    parseMaybeAssign(noIn);
    return false;
  }

  return wasArrow;
} // Parse a ternary conditional (`?:`) operator.
// Returns true if the expression was an arrow function.


function parseMaybeConditional(noIn) {
  var wasArrow = parseExprOps(noIn);

  if (wasArrow) {
    return true;
  }

  parseConditional(noIn);
  return false;
}

function parseConditional(noIn) {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    (0, _types.typedParseConditional)(noIn);
  } else {
    baseParseConditional(noIn);
  }
}

function baseParseConditional(noIn) {
  if ((0, _index2.eat)(_types2.TokenType.question)) {
    parseMaybeAssign();
    (0, _util.expect)(_types2.TokenType.colon);
    parseMaybeAssign(noIn);
  }
} // Start the precedence parser.
// Returns true if this was an arrow function


function parseExprOps(noIn) {
  var startTokenIndex = _base.state.tokens.length;
  var wasArrow = parseMaybeUnary();

  if (wasArrow) {
    return true;
  }

  parseExprOp(startTokenIndex, -1, noIn);
  return false;
} // Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.


function parseExprOp(startTokenIndex, minPrec, noIn) {
  if (_base.isTypeScriptEnabled && (_types2.TokenType._in & _types2.TokenType.PRECEDENCE_MASK) > minPrec && !(0, _util.hasPrecedingLineBreak)() && ((0, _util.eatContextual)(_keywords.ContextualKeyword._as) || (0, _util.eatContextual)(_keywords.ContextualKeyword._satisfies))) {
    var oldIsType = (0, _index2.pushTypeContext)(1);
    (0, _typescript.tsParseType)();
    (0, _index2.popTypeContext)(oldIsType);
    (0, _index2.rescan_gt)();
    parseExprOp(startTokenIndex, minPrec, noIn);
    return;
  }

  var prec = _base.state.type & _types2.TokenType.PRECEDENCE_MASK;

  if (prec > 0 && (!noIn || !(0, _index2.match)(_types2.TokenType._in))) {
    if (prec > minPrec) {
      var op = _base.state.type;
      (0, _index2.next)();

      if (op === _types2.TokenType.nullishCoalescing) {
        _base.state.tokens[_base.state.tokens.length - 1].nullishStartIndex = startTokenIndex;
      }

      var rhsStartTokenIndex = _base.state.tokens.length;
      parseMaybeUnary(); // Extend the right operand of this operator if possible.

      parseExprOp(rhsStartTokenIndex, op & _types2.TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);

      if (op === _types2.TokenType.nullishCoalescing) {
        _base.state.tokens[startTokenIndex].numNullishCoalesceStarts++;
        _base.state.tokens[_base.state.tokens.length - 1].numNullishCoalesceEnds++;
      } // Continue with any future operator holding this expression as the left operand.


      parseExprOp(startTokenIndex, minPrec, noIn);
    }
  }
} // Parse unary operators, both prefix and postfix.
// Returns true if this was an arrow function.


function parseMaybeUnary() {
  if (_base.isTypeScriptEnabled && !_base.isJSXEnabled && (0, _index2.eat)(_types2.TokenType.lessThan)) {
    (0, _typescript.tsParseTypeAssertion)();
    return false;
  }

  if ((0, _util.isContextual)(_keywords.ContextualKeyword._module) && (0, _index2.lookaheadCharCode)() === _charcodes.charCodes.leftCurlyBrace && !(0, _util.hasFollowingLineBreak)()) {
    parseModuleExpression();
    return false;
  }

  if (_base.state.type & _types2.TokenType.IS_PREFIX) {
    (0, _index2.next)();
    parseMaybeUnary();
    return false;
  }

  var wasArrow = parseExprSubscripts();

  if (wasArrow) {
    return true;
  }

  while (_base.state.type & _types2.TokenType.IS_POSTFIX && !(0, _util.canInsertSemicolon)()) {
    // The tokenizer calls everything a preincrement, so make it a postincrement when
    // we see it in that context.
    if (_base.state.type === _types2.TokenType.preIncDec) {
      _base.state.type = _types2.TokenType.postIncDec;
    }

    (0, _index2.next)();
  }

  return false;
} // Parse call, dot, and `[]`-subscript expressions.
// Returns true if this was an arrow function.


function parseExprSubscripts() {
  var startTokenIndex = _base.state.tokens.length;
  var wasArrow = parseExprAtom();

  if (wasArrow) {
    return true;
  }

  parseSubscripts(startTokenIndex); // If there was any optional chain operation, the start token would be marked
  // as such, so also mark the end now.

  if (_base.state.tokens.length > startTokenIndex && _base.state.tokens[startTokenIndex].isOptionalChainStart) {
    _base.state.tokens[_base.state.tokens.length - 1].isOptionalChainEnd = true;
  }

  return false;
}

function parseSubscripts(startTokenIndex) {
  var noCalls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (_base.isFlowEnabled) {
    (0, _flow.flowParseSubscripts)(startTokenIndex, noCalls);
  } else {
    baseParseSubscripts(startTokenIndex, noCalls);
  }
}

function baseParseSubscripts(startTokenIndex) {
  var noCalls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var stopState = new StopState(false);

  do {
    parseSubscript(startTokenIndex, noCalls, stopState);
  } while (!stopState.stop && !_base.state.error);
}

function parseSubscript(startTokenIndex, noCalls, stopState) {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseSubscript)(startTokenIndex, noCalls, stopState);
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowParseSubscript)(startTokenIndex, noCalls, stopState);
  } else {
    baseParseSubscript(startTokenIndex, noCalls, stopState);
  }
}
/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */


function baseParseSubscript(startTokenIndex, noCalls, stopState) {
  if (!noCalls && (0, _index2.eat)(_types2.TokenType.doubleColon)) {
    parseNoCallExpr();
    stopState.stop = true; // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want
    // to revisit this in the future when fully supporting bind syntax.

    parseSubscripts(startTokenIndex, noCalls);
  } else if ((0, _index2.match)(_types2.TokenType.questionDot)) {
    _base.state.tokens[startTokenIndex].isOptionalChainStart = true;

    if (noCalls && (0, _index2.lookaheadType)() === _types2.TokenType.parenL) {
      stopState.stop = true;
      return;
    }

    (0, _index2.next)();
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;

    if ((0, _index2.eat)(_types2.TokenType.bracketL)) {
      parseExpression();
      (0, _util.expect)(_types2.TokenType.bracketR);
    } else if ((0, _index2.eat)(_types2.TokenType.parenL)) {
      parseCallExpressionArguments();
    } else {
      parseMaybePrivateName();
    }
  } else if ((0, _index2.eat)(_types2.TokenType.dot)) {
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseMaybePrivateName();
  } else if ((0, _index2.eat)(_types2.TokenType.bracketL)) {
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseExpression();
    (0, _util.expect)(_types2.TokenType.bracketR);
  } else if (!noCalls && (0, _index2.match)(_types2.TokenType.parenL)) {
    if (atPossibleAsync()) {
      // We see "async", but it's possible it's a usage of the name "async". Parse as if it's a
      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.
      var snapshot = _base.state.snapshot();

      var asyncStartTokenIndex = _base.state.tokens.length;
      (0, _index2.next)();
      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      var callContextId = (0, _base.getNextContextId)();
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      _base.state.tokens[_base.state.tokens.length - 1].contextId = callContextId;

      if (shouldParseAsyncArrow()) {
        // We hit an arrow, so backtrack and start again parsing function parameters.
        _base.state.restoreFromSnapshot(snapshot);

        stopState.stop = true;
        _base.state.scopeDepth++;
        (0, _statement.parseFunctionParams)();
        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);
      }
    } else {
      (0, _index2.next)();
      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;

      var _callContextId = (0, _base.getNextContextId)();

      _base.state.tokens[_base.state.tokens.length - 1].contextId = _callContextId;
      parseCallExpressionArguments();
      _base.state.tokens[_base.state.tokens.length - 1].contextId = _callContextId;
    }
  } else if ((0, _index2.match)(_types2.TokenType.backQuote)) {
    // Tagged template expression.
    parseTemplate();
  } else {
    stopState.stop = true;
  }
}

function atPossibleAsync() {
  // This was made less strict than the original version to avoid passing around nodes, but it
  // should be safe to have rare false positives here.
  return _base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async && !(0, _util.canInsertSemicolon)();
}

function parseCallExpressionArguments() {
  var first = true;

  while (!(0, _index2.eat)(_types2.TokenType.parenR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      (0, _util.expect)(_types2.TokenType.comma);

      if ((0, _index2.eat)(_types2.TokenType.parenR)) {
        break;
      }
    }

    parseExprListItem(false);
  }
}

function shouldParseAsyncArrow() {
  return (0, _index2.match)(_types2.TokenType.colon) || (0, _index2.match)(_types2.TokenType.arrow);
}

function parseAsyncArrowFromCallExpression(startTokenIndex) {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsStartParseAsyncArrowFromCallExpression)();
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowStartParseAsyncArrowFromCallExpression)();
  }

  (0, _util.expect)(_types2.TokenType.arrow);
  parseArrowExpression(startTokenIndex);
} // Parse a no-call expression (like argument of `new` or `::` operators).


function parseNoCallExpr() {
  var startTokenIndex = _base.state.tokens.length;
  parseExprAtom();
  parseSubscripts(startTokenIndex, true);
} // Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.
// Returns true if the parsed expression was an arrow function.


function parseExprAtom() {
  if ((0, _index2.eat)(_types2.TokenType.modulo)) {
    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed
    // naturally.
    parseIdentifier();
    return false;
  }

  if ((0, _index2.match)(_types2.TokenType.jsxText) || (0, _index2.match)(_types2.TokenType.jsxEmptyText)) {
    parseLiteral();
    return false;
  } else if ((0, _index2.match)(_types2.TokenType.lessThan) && _base.isJSXEnabled) {
    _base.state.type = _types2.TokenType.jsxTagStart;
    (0, _index.jsxParseElement)();
    (0, _index2.next)();
    return false;
  }

  var canBeArrow = _base.state.potentialArrowAt === _base.state.start;

  switch (_base.state.type) {
    case _types2.TokenType.slash:
    case _types2.TokenType.assign:
      (0, _index2.retokenizeSlashAsRegex)();
    // Fall through.

    case _types2.TokenType._super:
    case _types2.TokenType._this:
    case _types2.TokenType.regexp:
    case _types2.TokenType.num:
    case _types2.TokenType.bigint:
    case _types2.TokenType.decimal:
    case _types2.TokenType.string:
    case _types2.TokenType._null:
    case _types2.TokenType._true:
    case _types2.TokenType._false:
      (0, _index2.next)();
      return false;

    case _types2.TokenType._import:
      (0, _index2.next)();

      if ((0, _index2.match)(_types2.TokenType.dot)) {
        // import.meta
        _base.state.tokens[_base.state.tokens.length - 1].type = _types2.TokenType.name;
        (0, _index2.next)();
        parseIdentifier();
      }

      return false;

    case _types2.TokenType.name:
      {
        var startTokenIndex = _base.state.tokens.length;
        var functionStart = _base.state.start;
        var contextualKeyword = _base.state.contextualKeyword;
        parseIdentifier();

        if (contextualKeyword === _keywords.ContextualKeyword._await) {
          parseAwait();
          return false;
        } else if (contextualKeyword === _keywords.ContextualKeyword._async && (0, _index2.match)(_types2.TokenType._function) && !(0, _util.canInsertSemicolon)()) {
          (0, _index2.next)();
          (0, _statement.parseFunction)(functionStart, false);
          return false;
        } else if (canBeArrow && contextualKeyword === _keywords.ContextualKeyword._async && !(0, _util.canInsertSemicolon)() && (0, _index2.match)(_types2.TokenType.name)) {
          _base.state.scopeDepth++;
          (0, _lval.parseBindingIdentifier)(false);
          (0, _util.expect)(_types2.TokenType.arrow); // let foo = async bar => {};

          parseArrowExpression(startTokenIndex);
          return true;
        } else if ((0, _index2.match)(_types2.TokenType._do) && !(0, _util.canInsertSemicolon)()) {
          (0, _index2.next)();
          (0, _statement.parseBlock)();
          return false;
        }

        if (canBeArrow && !(0, _util.canInsertSemicolon)() && (0, _index2.match)(_types2.TokenType.arrow)) {
          _base.state.scopeDepth++;
          (0, _lval.markPriorBindingIdentifier)(false);
          (0, _util.expect)(_types2.TokenType.arrow);
          parseArrowExpression(startTokenIndex);
          return true;
        }

        _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index2.IdentifierRole.Access;
        return false;
      }

    case _types2.TokenType._do:
      {
        (0, _index2.next)();
        (0, _statement.parseBlock)();
        return false;
      }

    case _types2.TokenType.parenL:
      {
        var wasArrow = parseParenAndDistinguishExpression(canBeArrow);
        return wasArrow;
      }

    case _types2.TokenType.bracketL:
      (0, _index2.next)();
      parseExprList(_types2.TokenType.bracketR, true);
      return false;

    case _types2.TokenType.braceL:
      parseObj(false, false);
      return false;

    case _types2.TokenType._function:
      parseFunctionExpression();
      return false;

    case _types2.TokenType.at:
      (0, _statement.parseDecorators)();
    // Fall through.

    case _types2.TokenType._class:
      (0, _statement.parseClass)(false);
      return false;

    case _types2.TokenType._new:
      parseNew();
      return false;

    case _types2.TokenType.backQuote:
      parseTemplate();
      return false;

    case _types2.TokenType.doubleColon:
      {
        (0, _index2.next)();
        parseNoCallExpr();
        return false;
      }

    case _types2.TokenType.hash:
      {
        var code = (0, _index2.lookaheadCharCode)();

        if (_identifier.IS_IDENTIFIER_START[code] || code === _charcodes.charCodes.backslash) {
          parseMaybePrivateName();
        } else {
          (0, _index2.next)();
        } // Smart pipeline topic reference.


        return false;
      }

    default:
      (0, _util.unexpected)();
      return false;
  }
}

function parseMaybePrivateName() {
  (0, _index2.eat)(_types2.TokenType.hash);
  parseIdentifier();
}

function parseFunctionExpression() {
  var functionStart = _base.state.start;
  parseIdentifier();

  if ((0, _index2.eat)(_types2.TokenType.dot)) {
    // function.sent
    parseIdentifier();
  }

  (0, _statement.parseFunction)(functionStart, false);
}

function parseLiteral() {
  (0, _index2.next)();
}

function parseParenExpression() {
  (0, _util.expect)(_types2.TokenType.parenL);
  parseExpression();
  (0, _util.expect)(_types2.TokenType.parenR);
} // Returns true if this was an arrow expression.


function parseParenAndDistinguishExpression(canBeArrow) {
  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and
  // start over as a parameter list.
  var snapshot = _base.state.snapshot();

  var startTokenIndex = _base.state.tokens.length;
  (0, _util.expect)(_types2.TokenType.parenL);
  var first = true;

  while (!(0, _index2.match)(_types2.TokenType.parenR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      (0, _util.expect)(_types2.TokenType.comma);

      if ((0, _index2.match)(_types2.TokenType.parenR)) {
        break;
      }
    }

    if ((0, _index2.match)(_types2.TokenType.ellipsis)) {
      (0, _lval.parseRest)(false
      /* isBlockScope */
      );
      parseParenItem();
      break;
    } else {
      parseMaybeAssign(false, true);
    }
  }

  (0, _util.expect)(_types2.TokenType.parenR);

  if (canBeArrow && shouldParseArrow()) {
    var wasArrow = parseArrow();

    if (wasArrow) {
      // It was an arrow function this whole time, so start over and parse it as params so that we
      // get proper token annotations.
      _base.state.restoreFromSnapshot(snapshot);

      _base.state.scopeDepth++; // Don't specify a context ID because arrow functions don't need a context ID.

      (0, _statement.parseFunctionParams)();
      parseArrow();
      parseArrowExpression(startTokenIndex);

      if (_base.state.error) {
        // Nevermind! This must have been something that looks very much like an
        // arrow function but where its "parameter list" isn't actually a valid
        // parameter list. Force non-arrow parsing.
        // See https://github.com/alangpierce/sucrase/issues/666 for an example.
        _base.state.restoreFromSnapshot(snapshot);

        parseParenAndDistinguishExpression(false);
        return false;
      }

      return true;
    }
  }

  return false;
}

function shouldParseArrow() {
  return (0, _index2.match)(_types2.TokenType.colon) || !(0, _util.canInsertSemicolon)();
} // Returns whether there was an arrow token.


function parseArrow() {
  if (_base.isTypeScriptEnabled) {
    return (0, _typescript.tsParseArrow)();
  } else if (_base.isFlowEnabled) {
    return (0, _flow.flowParseArrow)();
  } else {
    return (0, _index2.eat)(_types2.TokenType.arrow);
  }
}

function parseParenItem() {
  if (_base.isTypeScriptEnabled || _base.isFlowEnabled) {
    (0, _types.typedParseParenItem)();
  }
} // New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.


function parseNew() {
  (0, _util.expect)(_types2.TokenType._new);

  if ((0, _index2.eat)(_types2.TokenType.dot)) {
    // new.target
    parseIdentifier();
    return;
  }

  parseNewCallee();

  if (_base.isFlowEnabled) {
    (0, _flow.flowStartParseNewArguments)();
  }

  if ((0, _index2.eat)(_types2.TokenType.parenL)) {
    parseExprList(_types2.TokenType.parenR);
  }
}

function parseNewCallee() {
  parseNoCallExpr();
  (0, _index2.eat)(_types2.TokenType.questionDot);
}

function parseTemplate() {
  // Finish `, read quasi
  (0, _index2.nextTemplateToken)(); // Finish quasi, read ${

  (0, _index2.nextTemplateToken)();

  while (!(0, _index2.match)(_types2.TokenType.backQuote) && !_base.state.error) {
    (0, _util.expect)(_types2.TokenType.dollarBraceL);
    parseExpression(); // Finish }, read quasi

    (0, _index2.nextTemplateToken)(); // Finish quasi, read either ${ or `

    (0, _index2.nextTemplateToken)();
  }

  (0, _index2.next)();
} // Parse an object literal or binding pattern.


function parseObj(isPattern, isBlockScope) {
  // Attach a context ID to the object open and close brace and each object key.
  var contextId = (0, _base.getNextContextId)();
  var first = true;
  (0, _index2.next)();
  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;

  while (!(0, _index2.eat)(_types2.TokenType.braceR) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      (0, _util.expect)(_types2.TokenType.comma);

      if ((0, _index2.eat)(_types2.TokenType.braceR)) {
        break;
      }
    }

    var isGenerator = false;

    if ((0, _index2.match)(_types2.TokenType.ellipsis)) {
      var previousIndex = _base.state.tokens.length;
      (0, _lval.parseSpread)();

      if (isPattern) {
        // Mark role when the only thing being spread over is an identifier.
        if (_base.state.tokens.length === previousIndex + 2) {
          (0, _lval.markPriorBindingIdentifier)(isBlockScope);
        }

        if ((0, _index2.eat)(_types2.TokenType.braceR)) {
          break;
        }
      }

      continue;
    }

    if (!isPattern) {
      isGenerator = (0, _index2.eat)(_types2.TokenType.star);
    }

    if (!isPattern && (0, _util.isContextual)(_keywords.ContextualKeyword._async)) {
      if (isGenerator) (0, _util.unexpected)();
      parseIdentifier();

      if ((0, _index2.match)(_types2.TokenType.colon) || (0, _index2.match)(_types2.TokenType.parenL) || (0, _index2.match)(_types2.TokenType.braceR) || (0, _index2.match)(_types2.TokenType.eq) || (0, _index2.match)(_types2.TokenType.comma)) {// This is a key called "async" rather than an async function.
      } else {
        if ((0, _index2.match)(_types2.TokenType.star)) {
          (0, _index2.next)();
          isGenerator = true;
        }

        parsePropertyName(contextId);
      }
    } else {
      parsePropertyName(contextId);
    }

    parseObjPropValue(isPattern, isBlockScope, contextId);
  }

  _base.state.tokens[_base.state.tokens.length - 1].contextId = contextId;
}

function isGetterOrSetterMethod(isPattern) {
  // We go off of the next and don't bother checking if the node key is actually "get" or "set".
  // This lets us avoid generating a node, and should only make the validation worse.
  return !isPattern && ((0, _index2.match)(_types2.TokenType.string) || // get "string"() {}
  (0, _index2.match)(_types2.TokenType.num) || // get 1() {}
  (0, _index2.match)(_types2.TokenType.bracketL) || // get ["string"]() {}
  (0, _index2.match)(_types2.TokenType.name) || // get foo() {}
  !!(_base.state.type & _types2.TokenType.IS_KEYWORD)) // get debugger() {}
  ;
} // Returns true if this was a method.


function parseObjectMethod(isPattern, objectContextId) {
  // We don't need to worry about modifiers because object methods can't have optional bodies, so
  // the start will never be used.
  var functionStart = _base.state.start;

  if ((0, _index2.match)(_types2.TokenType.parenL)) {
    if (isPattern) (0, _util.unexpected)();
    parseMethod(functionStart,
    /* isConstructor */
    false);
    return true;
  }

  if (isGetterOrSetterMethod(isPattern)) {
    parsePropertyName(objectContextId);
    parseMethod(functionStart,
    /* isConstructor */
    false);
    return true;
  }

  return false;
}

function parseObjectProperty(isPattern, isBlockScope) {
  if ((0, _index2.eat)(_types2.TokenType.colon)) {
    if (isPattern) {
      (0, _lval.parseMaybeDefault)(isBlockScope);
    } else {
      parseMaybeAssign(false);
    }

    return;
  } // Since there's no colon, we assume this is an object shorthand.
  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so
  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to
  // transform it on access, so mark it as a normal object shorthand.


  var identifierRole;

  if (isPattern) {
    if (_base.state.scopeDepth === 0) {
      identifierRole = _index2.IdentifierRole.ObjectShorthandTopLevelDeclaration;
    } else if (isBlockScope) {
      identifierRole = _index2.IdentifierRole.ObjectShorthandBlockScopedDeclaration;
    } else {
      identifierRole = _index2.IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
    }
  } else {
    identifierRole = _index2.IdentifierRole.ObjectShorthand;
  }

  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole; // Regardless of whether we know this to be a pattern or if we're in an ambiguous context, allow
  // parsing as if there's a default value.

  (0, _lval.parseMaybeDefault)(isBlockScope, true);
}

function parseObjPropValue(isPattern, isBlockScope, objectContextId) {
  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsStartParseObjPropValue)();
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowStartParseObjPropValue)();
  }

  var wasMethod = parseObjectMethod(isPattern, objectContextId);

  if (!wasMethod) {
    parseObjectProperty(isPattern, isBlockScope);
  }
}

function parsePropertyName(objectContextId) {
  if (_base.isFlowEnabled) {
    (0, _flow.flowParseVariance)();
  }

  if ((0, _index2.eat)(_types2.TokenType.bracketL)) {
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
    parseMaybeAssign();
    (0, _util.expect)(_types2.TokenType.bracketR);
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
  } else {
    if ((0, _index2.match)(_types2.TokenType.num) || (0, _index2.match)(_types2.TokenType.string) || (0, _index2.match)(_types2.TokenType.bigint) || (0, _index2.match)(_types2.TokenType.decimal)) {
      parseExprAtom();
    } else {
      parseMaybePrivateName();
    }

    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index2.IdentifierRole.ObjectKey;
    _base.state.tokens[_base.state.tokens.length - 1].contextId = objectContextId;
  }
} // Parse object or class method.


function parseMethod(functionStart, isConstructor) {
  var funcContextId = (0, _base.getNextContextId)();
  _base.state.scopeDepth++;
  var startTokenIndex = _base.state.tokens.length;
  var allowModifiers = isConstructor; // For TypeScript parameter properties

  (0, _statement.parseFunctionParams)(allowModifiers, funcContextId);
  parseFunctionBodyAndFinish(functionStart, funcContextId);
  var endTokenIndex = _base.state.tokens.length;

  _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, true));

  _base.state.scopeDepth--;
} // Parse arrow function expression.
// If the parameters are provided, they will be converted to an
// assignable list.


function parseArrowExpression(startTokenIndex) {
  parseFunctionBody(true);
  var endTokenIndex = _base.state.tokens.length;

  _base.state.scopes.push(new _state.Scope(startTokenIndex, endTokenIndex, true));

  _base.state.scopeDepth--;
}

function parseFunctionBodyAndFinish(functionStart) {
  var funcContextId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsParseFunctionBodyAndFinish)(functionStart, funcContextId);
  } else if (_base.isFlowEnabled) {
    (0, _flow.flowParseFunctionBodyAndFinish)(funcContextId);
  } else {
    parseFunctionBody(false, funcContextId);
  }
}

function parseFunctionBody(allowExpression) {
  var funcContextId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var isExpression = allowExpression && !(0, _index2.match)(_types2.TokenType.braceL);

  if (isExpression) {
    parseMaybeAssign();
  } else {
    (0, _statement.parseBlock)(true
    /* isFunctionScope */
    , funcContextId);
  }
} // Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).


function parseExprList(close) {
  var allowEmpty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var first = true;

  while (!(0, _index2.eat)(close) && !_base.state.error) {
    if (first) {
      first = false;
    } else {
      (0, _util.expect)(_types2.TokenType.comma);
      if ((0, _index2.eat)(close)) break;
    }

    parseExprListItem(allowEmpty);
  }
}

function parseExprListItem(allowEmpty) {
  if (allowEmpty && (0, _index2.match)(_types2.TokenType.comma)) {// Empty item; nothing more to parse for this item.
  } else if ((0, _index2.match)(_types2.TokenType.ellipsis)) {
    (0, _lval.parseSpread)();
    parseParenItem();
  } else if ((0, _index2.match)(_types2.TokenType.question)) {
    // Partial function application proposal.
    (0, _index2.next)();
  } else {
    parseMaybeAssign(false, true);
  }
} // Parse the next token as an identifier.


function parseIdentifier() {
  (0, _index2.next)();
  _base.state.tokens[_base.state.tokens.length - 1].type = _types2.TokenType.name;
} // Parses await expression inside async function.


function parseAwait() {
  parseMaybeUnary();
} // Parses yield expression inside generator.


function parseYield() {
  (0, _index2.next)();

  if (!(0, _index2.match)(_types2.TokenType.semi) && !(0, _util.canInsertSemicolon)()) {
    (0, _index2.eat)(_types2.TokenType.star);
    parseMaybeAssign();
  }
} // https://github.com/tc39/proposal-js-module-blocks


function parseModuleExpression() {
  (0, _util.expectContextual)(_keywords.ContextualKeyword._module);
  (0, _util.expect)(_types2.TokenType.braceL); // For now, just call parseBlockBody to parse the block. In the future when we
  // implement full support, we'll want to emit scopes and possibly other
  // information.

  (0, _statement.parseBlockBody)(_types2.TokenType.braceR);
}