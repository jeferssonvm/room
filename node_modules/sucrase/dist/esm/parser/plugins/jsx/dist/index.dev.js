"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.jsxParseElement = jsxParseElement;
exports.nextJSXTagToken = nextJSXTagToken;

var _index = require("../../tokenizer/index");

var _types = require("../../tokenizer/types");

var _base = require("../../traverser/base");

var _expression = require("../../traverser/expression");

var _util = require("../../traverser/util");

var _charcodes = require("../../util/charcodes");

var _identifier = require("../../util/identifier");

var _typescript = require("../typescript");

/**
 * Read token with JSX contents.
 *
 * In addition to detecting jsxTagStart and also regular tokens that might be
 * part of an expression, this code detects the start and end of text ranges
 * within JSX children. In order to properly count the number of children, we
 * distinguish jsxText from jsxEmptyText, which is a text range that simplifies
 * to the empty string after JSX whitespace trimming.
 *
 * It turns out that a JSX text range will simplify to the empty string if and
 * only if both of these conditions hold:
 * - The range consists entirely of whitespace characters (only counting space,
 *   tab, \r, and \n).
 * - The range has at least one newline.
 * This can be proven by analyzing any implementation of whitespace trimming,
 * e.g. formatJSXTextLiteral in Sucrase or cleanJSXElementLiteralChild in Babel.
 */
function jsxReadToken() {
  var sawNewline = false;
  var sawNonWhitespace = false;

  while (true) {
    if (_base.state.pos >= _base.input.length) {
      (0, _util.unexpected)("Unterminated JSX contents");
      return;
    }

    var ch = _base.input.charCodeAt(_base.state.pos);

    if (ch === _charcodes.charCodes.lessThan || ch === _charcodes.charCodes.leftCurlyBrace) {
      if (_base.state.pos === _base.state.start) {
        if (ch === _charcodes.charCodes.lessThan) {
          _base.state.pos++;
          (0, _index.finishToken)(_types.TokenType.jsxTagStart);
          return;
        }

        (0, _index.getTokenFromCode)(ch);
        return;
      }

      if (sawNewline && !sawNonWhitespace) {
        (0, _index.finishToken)(_types.TokenType.jsxEmptyText);
      } else {
        (0, _index.finishToken)(_types.TokenType.jsxText);
      }

      return;
    } // This is part of JSX text.


    if (ch === _charcodes.charCodes.lineFeed) {
      sawNewline = true;
    } else if (ch !== _charcodes.charCodes.space && ch !== _charcodes.charCodes.carriageReturn && ch !== _charcodes.charCodes.tab) {
      sawNonWhitespace = true;
    }

    _base.state.pos++;
  }
}

function jsxReadString(quote) {
  _base.state.pos++;

  for (;;) {
    if (_base.state.pos >= _base.input.length) {
      (0, _util.unexpected)("Unterminated string constant");
      return;
    }

    var ch = _base.input.charCodeAt(_base.state.pos);

    if (ch === quote) {
      _base.state.pos++;
      break;
    }

    _base.state.pos++;
  }

  (0, _index.finishToken)(_types.TokenType.string);
} // Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can't contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.


function jsxReadWord() {
  var ch;

  do {
    if (_base.state.pos > _base.input.length) {
      (0, _util.unexpected)("Unexpectedly reached the end of input.");
      return;
    }

    ch = _base.input.charCodeAt(++_base.state.pos);
  } while (_identifier.IS_IDENTIFIER_CHAR[ch] || ch === _charcodes.charCodes.dash);

  (0, _index.finishToken)(_types.TokenType.jsxName);
} // Parse next token as JSX identifier


function jsxParseIdentifier() {
  nextJSXTagToken();
} // Parse namespaced identifier.


function jsxParseNamespacedName(identifierRole) {
  jsxParseIdentifier();

  if (!(0, _index.eat)(_types.TokenType.colon)) {
    // Plain identifier, so this is an access.
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
    return;
  } // Process the second half of the namespaced name.


  jsxParseIdentifier();
} // Parses element name in any form - namespaced, member
// or single identifier.


function jsxParseElementName() {
  var firstTokenIndex = _base.state.tokens.length;
  jsxParseNamespacedName(_index.IdentifierRole.Access);
  var hadDot = false;

  while ((0, _index.match)(_types.TokenType.dot)) {
    hadDot = true;
    nextJSXTagToken();
    jsxParseIdentifier();
  } // For tags like <div> with a lowercase letter and no dots, the name is
  // actually *not* an identifier access, since it's referring to a built-in
  // tag name. Remove the identifier role in this case so that it's not
  // accidentally transformed by the imports transform when preserving JSX.


  if (!hadDot) {
    var firstToken = _base.state.tokens[firstTokenIndex];

    var firstChar = _base.input.charCodeAt(firstToken.start);

    if (firstChar >= _charcodes.charCodes.lowercaseA && firstChar <= _charcodes.charCodes.lowercaseZ) {
      firstToken.identifierRole = null;
    }
  }
} // Parses any type of JSX attribute value.


function jsxParseAttributeValue() {
  switch (_base.state.type) {
    case _types.TokenType.braceL:
      (0, _index.next)();
      (0, _expression.parseExpression)();
      nextJSXTagToken();
      return;

    case _types.TokenType.jsxTagStart:
      jsxParseElement();
      nextJSXTagToken();
      return;

    case _types.TokenType.string:
      nextJSXTagToken();
      return;

    default:
      (0, _util.unexpected)("JSX value should be either an expression or a quoted JSX text");
  }
} // Parse JSX spread child, after already processing the {
// Does not parse the closing }


function jsxParseSpreadChild() {
  (0, _util.expect)(_types.TokenType.ellipsis);
  (0, _expression.parseExpression)();
} // Parses JSX opening tag starting after "<".
// Returns true if the tag was self-closing.
// Does not parse the last token.


function jsxParseOpeningElement(initialTokenIndex) {
  if ((0, _index.match)(_types.TokenType.jsxTagEnd)) {
    // This is an open-fragment.
    return false;
  }

  jsxParseElementName();

  if (_base.isTypeScriptEnabled) {
    (0, _typescript.tsTryParseJSXTypeArgument)();
  }

  var hasSeenPropSpread = false;

  while (!(0, _index.match)(_types.TokenType.slash) && !(0, _index.match)(_types.TokenType.jsxTagEnd) && !_base.state.error) {
    if ((0, _index.eat)(_types.TokenType.braceL)) {
      hasSeenPropSpread = true;
      (0, _util.expect)(_types.TokenType.ellipsis);
      (0, _expression.parseMaybeAssign)(); // }

      nextJSXTagToken();
      continue;
    }

    if (hasSeenPropSpread && _base.state.end - _base.state.start === 3 && _base.input.charCodeAt(_base.state.start) === _charcodes.charCodes.lowercaseK && _base.input.charCodeAt(_base.state.start + 1) === _charcodes.charCodes.lowercaseE && _base.input.charCodeAt(_base.state.start + 2) === _charcodes.charCodes.lowercaseY) {
      _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.KeyAfterPropSpread;
    }

    jsxParseNamespacedName(_index.IdentifierRole.ObjectKey);

    if ((0, _index.match)(_types.TokenType.eq)) {
      nextJSXTagToken();
      jsxParseAttributeValue();
    }
  }

  var isSelfClosing = (0, _index.match)(_types.TokenType.slash);

  if (isSelfClosing) {
    // /
    nextJSXTagToken();
  }

  return isSelfClosing;
} // Parses JSX closing tag starting after "</".
// Does not parse the last token.


function jsxParseClosingElement() {
  if ((0, _index.match)(_types.TokenType.jsxTagEnd)) {
    // Fragment syntax, so we immediately have a tag end.
    return;
  }

  jsxParseElementName();
} // Parses entire JSX element, including its opening tag
// (starting after "<"), attributes, contents and closing tag.
// Does not parse the last token.


function jsxParseElementAt() {
  var initialTokenIndex = _base.state.tokens.length - 1;
  _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.NoChildren;
  var numExplicitChildren = 0;
  var isSelfClosing = jsxParseOpeningElement(initialTokenIndex);

  if (!isSelfClosing) {
    nextJSXExprToken();

    while (true) {
      switch (_base.state.type) {
        case _types.TokenType.jsxTagStart:
          nextJSXTagToken();

          if ((0, _index.match)(_types.TokenType.slash)) {
            nextJSXTagToken();
            jsxParseClosingElement(); // Key after prop spread takes precedence over number of children,
            // since it means we switch to createElement, which doesn't care
            // about number of children.

            if (_base.state.tokens[initialTokenIndex].jsxRole !== _index.JSXRole.KeyAfterPropSpread) {
              if (numExplicitChildren === 1) {
                _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.OneChild;
              } else if (numExplicitChildren > 1) {
                _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.StaticChildren;
              }
            }

            return;
          }

          numExplicitChildren++;
          jsxParseElementAt();
          nextJSXExprToken();
          break;

        case _types.TokenType.jsxText:
          numExplicitChildren++;
          nextJSXExprToken();
          break;

        case _types.TokenType.jsxEmptyText:
          nextJSXExprToken();
          break;

        case _types.TokenType.braceL:
          (0, _index.next)();

          if ((0, _index.match)(_types.TokenType.ellipsis)) {
            jsxParseSpreadChild();
            nextJSXExprToken(); // Spread children are a mechanism to explicitly mark children as
            // static, so count it as 2 children to satisfy the "more than one
            // child" condition.

            numExplicitChildren += 2;
          } else {
            // If we see {}, this is an empty pseudo-expression that doesn't
            // count as a child.
            if (!(0, _index.match)(_types.TokenType.braceR)) {
              numExplicitChildren++;
              (0, _expression.parseExpression)();
            }

            nextJSXExprToken();
          }

          break;
        // istanbul ignore next - should never happen

        default:
          (0, _util.unexpected)();
          return;
      }
    }
  }
} // Parses entire JSX element from current position.
// Does not parse the last token.


function jsxParseElement() {
  nextJSXTagToken();
  jsxParseElementAt();
} // ==================================
// Overrides
// ==================================


function nextJSXTagToken() {
  _base.state.tokens.push(new _index.Token());

  (0, _index.skipSpace)();
  _base.state.start = _base.state.pos;

  var code = _base.input.charCodeAt(_base.state.pos);

  if (_identifier.IS_IDENTIFIER_START[code]) {
    jsxReadWord();
  } else if (code === _charcodes.charCodes.quotationMark || code === _charcodes.charCodes.apostrophe) {
    jsxReadString(code);
  } else {
    // The following tokens are just one character each.
    ++_base.state.pos;

    switch (code) {
      case _charcodes.charCodes.greaterThan:
        (0, _index.finishToken)(_types.TokenType.jsxTagEnd);
        break;

      case _charcodes.charCodes.lessThan:
        (0, _index.finishToken)(_types.TokenType.jsxTagStart);
        break;

      case _charcodes.charCodes.slash:
        (0, _index.finishToken)(_types.TokenType.slash);
        break;

      case _charcodes.charCodes.equalsTo:
        (0, _index.finishToken)(_types.TokenType.eq);
        break;

      case _charcodes.charCodes.leftCurlyBrace:
        (0, _index.finishToken)(_types.TokenType.braceL);
        break;

      case _charcodes.charCodes.dot:
        (0, _index.finishToken)(_types.TokenType.dot);
        break;

      case _charcodes.charCodes.colon:
        (0, _index.finishToken)(_types.TokenType.colon);
        break;

      default:
        (0, _util.unexpected)();
    }
  }
}

function nextJSXExprToken() {
  _base.state.tokens.push(new _index.Token());

  _base.state.start = _base.state.pos;
  jsxReadToken();
}