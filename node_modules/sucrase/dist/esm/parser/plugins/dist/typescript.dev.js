"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tsParseModifiers = tsParseModifiers;
exports.tsParseModifier = tsParseModifier;
exports.tsTryParseTypeParameters = tsTryParseTypeParameters;
exports.tsTryParseTypeAnnotation = tsTryParseTypeAnnotation;
exports.tsParseTypeAnnotation = tsParseTypeAnnotation;
exports.tsParseType = tsParseType;
exports.tsParseNonConditionalType = tsParseNonConditionalType;
exports.tsParseTypeAssertion = tsParseTypeAssertion;
exports.tsTryParseJSXTypeArgument = tsTryParseJSXTypeArgument;
exports.tsParseImportEqualsDeclaration = tsParseImportEqualsDeclaration;
exports.tsIsDeclarationStart = tsIsDeclarationStart;
exports.tsParseFunctionBodyAndFinish = tsParseFunctionBodyAndFinish;
exports.tsParseSubscript = tsParseSubscript;
exports.tsTryParseExport = tsTryParseExport;
exports.tsParseImportSpecifier = tsParseImportSpecifier;
exports.tsParseExportSpecifier = tsParseExportSpecifier;
exports.tsTryParseExportDefaultExpression = tsTryParseExportDefaultExpression;
exports.tsTryParseStatementContent = tsTryParseStatementContent;
exports.tsTryParseClassMemberWithIsStatic = tsTryParseClassMemberWithIsStatic;
exports.tsParseIdentifierStatement = tsParseIdentifierStatement;
exports.tsParseExportDeclaration = tsParseExportDeclaration;
exports.tsAfterParseClassSuper = tsAfterParseClassSuper;
exports.tsStartParseObjPropValue = tsStartParseObjPropValue;
exports.tsStartParseFunctionParams = tsStartParseFunctionParams;
exports.tsAfterParseVarHead = tsAfterParseVarHead;
exports.tsStartParseAsyncArrowFromCallExpression = tsStartParseAsyncArrowFromCallExpression;
exports.tsParseMaybeAssign = tsParseMaybeAssign;
exports.tsParseMaybeAssignWithJSX = tsParseMaybeAssignWithJSX;
exports.tsParseMaybeAssignWithoutJSX = tsParseMaybeAssignWithoutJSX;
exports.tsParseArrow = tsParseArrow;
exports.tsParseAssignableListItemTypes = tsParseAssignableListItemTypes;
exports.tsParseMaybeDecoratorArguments = tsParseMaybeDecoratorArguments;

var _index = require("../tokenizer/index");

var _keywords = require("../tokenizer/keywords");

var _types = require("../tokenizer/types");

var _base = require("../traverser/base");

var _expression = require("../traverser/expression");

var _lval = require("../traverser/lval");

var _statement = require("../traverser/statement");

var _util = require("../traverser/util");

var _jsx = require("./jsx");

function tsIsIdentifier() {
  // TODO: actually a bit more complex in TypeScript, but shouldn't matter.
  // See https://github.com/Microsoft/TypeScript/issues/15008
  return (0, _index.match)(_types.TokenType.name);
}

function isLiteralPropertyName() {
  return (0, _index.match)(_types.TokenType.name) || Boolean(_base.state.type & _types.TokenType.IS_KEYWORD) || (0, _index.match)(_types.TokenType.string) || (0, _index.match)(_types.TokenType.num) || (0, _index.match)(_types.TokenType.bigint) || (0, _index.match)(_types.TokenType.decimal);
}

function tsNextTokenCanFollowModifier() {
  // Note: TypeScript's implementation is much more complicated because
  // more things are considered modifiers there.
  // This implementation only handles modifiers not handled by babylon itself. And "static".
  // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
  var snapshot = _base.state.snapshot();

  (0, _index.next)();
  var canFollowModifier = ((0, _index.match)(_types.TokenType.bracketL) || (0, _index.match)(_types.TokenType.braceL) || (0, _index.match)(_types.TokenType.star) || (0, _index.match)(_types.TokenType.ellipsis) || (0, _index.match)(_types.TokenType.hash) || isLiteralPropertyName()) && !(0, _util.hasPrecedingLineBreak)();

  if (canFollowModifier) {
    return true;
  } else {
    _base.state.restoreFromSnapshot(snapshot);

    return false;
  }
}

function tsParseModifiers(allowedModifiers) {
  while (true) {
    var modifier = tsParseModifier(allowedModifiers);

    if (modifier === null) {
      break;
    }
  }
}
/** Parses a modifier matching one the given modifier names. */


function tsParseModifier(allowedModifiers) {
  if (!(0, _index.match)(_types.TokenType.name)) {
    return null;
  }

  var modifier = _base.state.contextualKeyword;

  if (allowedModifiers.indexOf(modifier) !== -1 && tsNextTokenCanFollowModifier()) {
    switch (modifier) {
      case _keywords.ContextualKeyword._readonly:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._readonly;
        break;

      case _keywords.ContextualKeyword._abstract:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;
        break;

      case _keywords.ContextualKeyword._static:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._static;
        break;

      case _keywords.ContextualKeyword._public:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._public;
        break;

      case _keywords.ContextualKeyword._private:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._private;
        break;

      case _keywords.ContextualKeyword._protected:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._protected;
        break;

      case _keywords.ContextualKeyword._override:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._override;
        break;

      case _keywords.ContextualKeyword._declare:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;
        break;

      default:
        break;
    }

    return modifier;
  }

  return null;
}

function tsParseEntityName() {
  (0, _expression.parseIdentifier)();

  while ((0, _index.eat)(_types.TokenType.dot)) {
    (0, _expression.parseIdentifier)();
  }
}

function tsParseTypeReference() {
  tsParseEntityName();

  if (!(0, _util.hasPrecedingLineBreak)() && (0, _index.match)(_types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}

function tsParseThisTypePredicate() {
  (0, _index.next)();
  tsParseTypeAnnotation();
}

function tsParseThisTypeNode() {
  (0, _index.next)();
}

function tsParseTypeQuery() {
  (0, _util.expect)(_types.TokenType._typeof);

  if ((0, _index.match)(_types.TokenType._import)) {
    tsParseImportType();
  } else {
    tsParseEntityName();
  }

  if (!(0, _util.hasPrecedingLineBreak)() && (0, _index.match)(_types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}

function tsParseImportType() {
  (0, _util.expect)(_types.TokenType._import);
  (0, _util.expect)(_types.TokenType.parenL);
  (0, _util.expect)(_types.TokenType.string);
  (0, _util.expect)(_types.TokenType.parenR);

  if ((0, _index.eat)(_types.TokenType.dot)) {
    tsParseEntityName();
  }

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}

function tsParseTypeParameter() {
  (0, _index.eat)(_types.TokenType._const);
  var hadIn = (0, _index.eat)(_types.TokenType._in);
  var hadOut = (0, _util.eatContextual)(_keywords.ContextualKeyword._out);
  (0, _index.eat)(_types.TokenType._const);

  if ((hadIn || hadOut) && !(0, _index.match)(_types.TokenType.name)) {
    // The "in" or "out" keyword must have actually been the type parameter
    // name, so set it as the name.
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
  } else {
    (0, _expression.parseIdentifier)();
  }

  if ((0, _index.eat)(_types.TokenType._extends)) {
    tsParseType();
  }

  if ((0, _index.eat)(_types.TokenType.eq)) {
    tsParseType();
  }
}

function tsTryParseTypeParameters() {
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    tsParseTypeParameters();
  }
}

function tsParseTypeParameters() {
  var oldIsType = (0, _index.pushTypeContext)(0);

  if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.typeParameterStart)) {
    (0, _index.next)();
  } else {
    (0, _util.unexpected)();
  }

  while (!(0, _index.eat)(_types.TokenType.greaterThan) && !_base.state.error) {
    tsParseTypeParameter();
    (0, _index.eat)(_types.TokenType.comma);
  }

  (0, _index.popTypeContext)(oldIsType);
} // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
// but here it's always false, because this is only used for types.


function tsFillSignature(returnToken) {
  // Arrow fns *must* have return token (`=>`). Normal functions can omit it.
  var returnTokenRequired = returnToken === _types.TokenType.arrow;
  tsTryParseTypeParameters();
  (0, _util.expect)(_types.TokenType.parenL); // Create a scope even though we're doing type parsing so we don't accidentally
  // treat params as top-level bindings.

  _base.state.scopeDepth++;
  tsParseBindingListForSignature(false
  /* isBlockScope */
  );
  _base.state.scopeDepth--;

  if (returnTokenRequired) {
    tsParseTypeOrTypePredicateAnnotation(returnToken);
  } else if ((0, _index.match)(returnToken)) {
    tsParseTypeOrTypePredicateAnnotation(returnToken);
  }
}

function tsParseBindingListForSignature(isBlockScope) {
  (0, _lval.parseBindingList)(_types.TokenType.parenR, isBlockScope);
}

function tsParseTypeMemberSemicolon() {
  if (!(0, _index.eat)(_types.TokenType.comma)) {
    (0, _util.semicolon)();
  }
}

function tsParseSignatureMember() {
  tsFillSignature(_types.TokenType.colon);
  tsParseTypeMemberSemicolon();
}

function tsIsUnambiguouslyIndexSignature() {
  var snapshot = _base.state.snapshot();

  (0, _index.next)(); // Skip '{'

  var isIndexSignature = (0, _index.eat)(_types.TokenType.name) && (0, _index.match)(_types.TokenType.colon);

  _base.state.restoreFromSnapshot(snapshot);

  return isIndexSignature;
}

function tsTryParseIndexSignature() {
  if (!((0, _index.match)(_types.TokenType.bracketL) && tsIsUnambiguouslyIndexSignature())) {
    return false;
  }

  var oldIsType = (0, _index.pushTypeContext)(0);
  (0, _util.expect)(_types.TokenType.bracketL);
  (0, _expression.parseIdentifier)();
  tsParseTypeAnnotation();
  (0, _util.expect)(_types.TokenType.bracketR);
  tsTryParseTypeAnnotation();
  tsParseTypeMemberSemicolon();
  (0, _index.popTypeContext)(oldIsType);
  return true;
}

function tsParsePropertyOrMethodSignature(isReadonly) {
  (0, _index.eat)(_types.TokenType.question);

  if (!isReadonly && ((0, _index.match)(_types.TokenType.parenL) || (0, _index.match)(_types.TokenType.lessThan))) {
    tsFillSignature(_types.TokenType.colon);
    tsParseTypeMemberSemicolon();
  } else {
    tsTryParseTypeAnnotation();
    tsParseTypeMemberSemicolon();
  }
}

function tsParseTypeMember() {
  if ((0, _index.match)(_types.TokenType.parenL) || (0, _index.match)(_types.TokenType.lessThan)) {
    // call signature
    tsParseSignatureMember();
    return;
  }

  if ((0, _index.match)(_types.TokenType._new)) {
    (0, _index.next)();

    if ((0, _index.match)(_types.TokenType.parenL) || (0, _index.match)(_types.TokenType.lessThan)) {
      // constructor signature
      tsParseSignatureMember();
    } else {
      tsParsePropertyOrMethodSignature(false);
    }

    return;
  }

  var readonly = !!tsParseModifier([_keywords.ContextualKeyword._readonly]);
  var found = tsTryParseIndexSignature();

  if (found) {
    return;
  }

  if (((0, _util.isContextual)(_keywords.ContextualKeyword._get) || (0, _util.isContextual)(_keywords.ContextualKeyword._set)) && tsNextTokenCanFollowModifier()) {// This is a getter/setter on a type. The tsNextTokenCanFollowModifier
    // function already called next() for us, so continue parsing the name.
  }

  (0, _expression.parsePropertyName)(-1
  /* Types don't need context IDs. */
  );
  tsParsePropertyOrMethodSignature(readonly);
}

function tsParseTypeLiteral() {
  tsParseObjectTypeMembers();
}

function tsParseObjectTypeMembers() {
  (0, _util.expect)(_types.TokenType.braceL);

  while (!(0, _index.eat)(_types.TokenType.braceR) && !_base.state.error) {
    tsParseTypeMember();
  }
}

function tsLookaheadIsStartOfMappedType() {
  var snapshot = _base.state.snapshot();

  var isStartOfMappedType = tsIsStartOfMappedType();

  _base.state.restoreFromSnapshot(snapshot);

  return isStartOfMappedType;
}

function tsIsStartOfMappedType() {
  (0, _index.next)();

  if ((0, _index.eat)(_types.TokenType.plus) || (0, _index.eat)(_types.TokenType.minus)) {
    return (0, _util.isContextual)(_keywords.ContextualKeyword._readonly);
  }

  if ((0, _util.isContextual)(_keywords.ContextualKeyword._readonly)) {
    (0, _index.next)();
  }

  if (!(0, _index.match)(_types.TokenType.bracketL)) {
    return false;
  }

  (0, _index.next)();

  if (!tsIsIdentifier()) {
    return false;
  }

  (0, _index.next)();
  return (0, _index.match)(_types.TokenType._in);
}

function tsParseMappedTypeParameter() {
  (0, _expression.parseIdentifier)();
  (0, _util.expect)(_types.TokenType._in);
  tsParseType();
}

function tsParseMappedType() {
  (0, _util.expect)(_types.TokenType.braceL);

  if ((0, _index.match)(_types.TokenType.plus) || (0, _index.match)(_types.TokenType.minus)) {
    (0, _index.next)();
    (0, _util.expectContextual)(_keywords.ContextualKeyword._readonly);
  } else {
    (0, _util.eatContextual)(_keywords.ContextualKeyword._readonly);
  }

  (0, _util.expect)(_types.TokenType.bracketL);
  tsParseMappedTypeParameter();

  if ((0, _util.eatContextual)(_keywords.ContextualKeyword._as)) {
    tsParseType();
  }

  (0, _util.expect)(_types.TokenType.bracketR);

  if ((0, _index.match)(_types.TokenType.plus) || (0, _index.match)(_types.TokenType.minus)) {
    (0, _index.next)();
    (0, _util.expect)(_types.TokenType.question);
  } else {
    (0, _index.eat)(_types.TokenType.question);
  }

  tsTryParseType();
  (0, _util.semicolon)();
  (0, _util.expect)(_types.TokenType.braceR);
}

function tsParseTupleType() {
  (0, _util.expect)(_types.TokenType.bracketL);

  while (!(0, _index.eat)(_types.TokenType.bracketR) && !_base.state.error) {
    // Do not validate presence of either none or only labeled elements
    tsParseTupleElementType();
    (0, _index.eat)(_types.TokenType.comma);
  }
}

function tsParseTupleElementType() {
  // parses `...TsType[]`
  if ((0, _index.eat)(_types.TokenType.ellipsis)) {
    tsParseType();
  } else {
    // parses `TsType?`
    tsParseType();
    (0, _index.eat)(_types.TokenType.question);
  } // The type we parsed above was actually a label


  if ((0, _index.eat)(_types.TokenType.colon)) {
    // Labeled tuple types must affix the label with `...` or `?`, so no need to handle those here
    tsParseType();
  }
}

function tsParseParenthesizedType() {
  (0, _util.expect)(_types.TokenType.parenL);
  tsParseType();
  (0, _util.expect)(_types.TokenType.parenR);
}

function tsParseTemplateLiteralType() {
  // Finish `, read quasi
  (0, _index.nextTemplateToken)(); // Finish quasi, read ${

  (0, _index.nextTemplateToken)();

  while (!(0, _index.match)(_types.TokenType.backQuote) && !_base.state.error) {
    (0, _util.expect)(_types.TokenType.dollarBraceL);
    tsParseType(); // Finish }, read quasi

    (0, _index.nextTemplateToken)(); // Finish quasi, read either ${ or `

    (0, _index.nextTemplateToken)();
  }

  (0, _index.next)();
}

var FunctionType;

(function (FunctionType) {
  var TSFunctionType = 0;
  FunctionType[FunctionType["TSFunctionType"] = TSFunctionType] = "TSFunctionType";
  var TSConstructorType = TSFunctionType + 1;
  FunctionType[FunctionType["TSConstructorType"] = TSConstructorType] = "TSConstructorType";
  var TSAbstractConstructorType = TSConstructorType + 1;
  FunctionType[FunctionType["TSAbstractConstructorType"] = TSAbstractConstructorType] = "TSAbstractConstructorType";
})(FunctionType || (FunctionType = {}));

function tsParseFunctionOrConstructorType(type) {
  if (type === FunctionType.TSAbstractConstructorType) {
    (0, _util.expectContextual)(_keywords.ContextualKeyword._abstract);
  }

  if (type === FunctionType.TSConstructorType || type === FunctionType.TSAbstractConstructorType) {
    (0, _util.expect)(_types.TokenType._new);
  }

  var oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
  _base.state.inDisallowConditionalTypesContext = false;
  tsFillSignature(_types.TokenType.arrow);
  _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
}

function tsParseNonArrayType() {
  switch (_base.state.type) {
    case _types.TokenType.name:
      tsParseTypeReference();
      return;

    case _types.TokenType._void:
    case _types.TokenType._null:
      (0, _index.next)();
      return;

    case _types.TokenType.string:
    case _types.TokenType.num:
    case _types.TokenType.bigint:
    case _types.TokenType.decimal:
    case _types.TokenType._true:
    case _types.TokenType._false:
      (0, _expression.parseLiteral)();
      return;

    case _types.TokenType.minus:
      (0, _index.next)();
      (0, _expression.parseLiteral)();
      return;

    case _types.TokenType._this:
      {
        tsParseThisTypeNode();

        if ((0, _util.isContextual)(_keywords.ContextualKeyword._is) && !(0, _util.hasPrecedingLineBreak)()) {
          tsParseThisTypePredicate();
        }

        return;
      }

    case _types.TokenType._typeof:
      tsParseTypeQuery();
      return;

    case _types.TokenType._import:
      tsParseImportType();
      return;

    case _types.TokenType.braceL:
      if (tsLookaheadIsStartOfMappedType()) {
        tsParseMappedType();
      } else {
        tsParseTypeLiteral();
      }

      return;

    case _types.TokenType.bracketL:
      tsParseTupleType();
      return;

    case _types.TokenType.parenL:
      tsParseParenthesizedType();
      return;

    case _types.TokenType.backQuote:
      tsParseTemplateLiteralType();
      return;

    default:
      if (_base.state.type & _types.TokenType.IS_KEYWORD) {
        (0, _index.next)();
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
        return;
      }

      break;
  }

  (0, _util.unexpected)();
}

function tsParseArrayTypeOrHigher() {
  tsParseNonArrayType();

  while (!(0, _util.hasPrecedingLineBreak)() && (0, _index.eat)(_types.TokenType.bracketL)) {
    if (!(0, _index.eat)(_types.TokenType.bracketR)) {
      // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.
      tsParseType();
      (0, _util.expect)(_types.TokenType.bracketR);
    }
  }
}

function tsParseInferType() {
  (0, _util.expectContextual)(_keywords.ContextualKeyword._infer);
  (0, _expression.parseIdentifier)();

  if ((0, _index.match)(_types.TokenType._extends)) {
    // Infer type constraints introduce an ambiguity about whether the "extends"
    // is a constraint for this infer type or is another conditional type.
    var snapshot = _base.state.snapshot();

    (0, _util.expect)(_types.TokenType._extends);
    var oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
    _base.state.inDisallowConditionalTypesContext = true;
    tsParseType();
    _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;

    if (_base.state.error || !_base.state.inDisallowConditionalTypesContext && (0, _index.match)(_types.TokenType.question)) {
      _base.state.restoreFromSnapshot(snapshot);
    }
  }
}

function tsParseTypeOperatorOrHigher() {
  if ((0, _util.isContextual)(_keywords.ContextualKeyword._keyof) || (0, _util.isContextual)(_keywords.ContextualKeyword._unique) || (0, _util.isContextual)(_keywords.ContextualKeyword._readonly)) {
    (0, _index.next)();
    tsParseTypeOperatorOrHigher();
  } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._infer)) {
    tsParseInferType();
  } else {
    var oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
    _base.state.inDisallowConditionalTypesContext = false;
    tsParseArrayTypeOrHigher();
    _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
  }
}

function tsParseIntersectionTypeOrHigher() {
  (0, _index.eat)(_types.TokenType.bitwiseAND);
  tsParseTypeOperatorOrHigher();

  if ((0, _index.match)(_types.TokenType.bitwiseAND)) {
    while ((0, _index.eat)(_types.TokenType.bitwiseAND)) {
      tsParseTypeOperatorOrHigher();
    }
  }
}

function tsParseUnionTypeOrHigher() {
  (0, _index.eat)(_types.TokenType.bitwiseOR);
  tsParseIntersectionTypeOrHigher();

  if ((0, _index.match)(_types.TokenType.bitwiseOR)) {
    while ((0, _index.eat)(_types.TokenType.bitwiseOR)) {
      tsParseIntersectionTypeOrHigher();
    }
  }
}

function tsIsStartOfFunctionType() {
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    return true;
  }

  return (0, _index.match)(_types.TokenType.parenL) && tsLookaheadIsUnambiguouslyStartOfFunctionType();
}

function tsSkipParameterStart() {
  if ((0, _index.match)(_types.TokenType.name) || (0, _index.match)(_types.TokenType._this)) {
    (0, _index.next)();
    return true;
  } // If this is a possible array/object destructure, walk to the matching bracket/brace.
  // The next token after will tell us definitively whether this is a function param.


  if ((0, _index.match)(_types.TokenType.braceL) || (0, _index.match)(_types.TokenType.bracketL)) {
    var depth = 1;
    (0, _index.next)();

    while (depth > 0 && !_base.state.error) {
      if ((0, _index.match)(_types.TokenType.braceL) || (0, _index.match)(_types.TokenType.bracketL)) {
        depth++;
      } else if ((0, _index.match)(_types.TokenType.braceR) || (0, _index.match)(_types.TokenType.bracketR)) {
        depth--;
      }

      (0, _index.next)();
    }

    return true;
  }

  return false;
}

function tsLookaheadIsUnambiguouslyStartOfFunctionType() {
  var snapshot = _base.state.snapshot();

  var isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();

  _base.state.restoreFromSnapshot(snapshot);

  return isUnambiguouslyStartOfFunctionType;
}

function tsIsUnambiguouslyStartOfFunctionType() {
  (0, _index.next)();

  if ((0, _index.match)(_types.TokenType.parenR) || (0, _index.match)(_types.TokenType.ellipsis)) {
    // ( )
    // ( ...
    return true;
  }

  if (tsSkipParameterStart()) {
    if ((0, _index.match)(_types.TokenType.colon) || (0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.question) || (0, _index.match)(_types.TokenType.eq)) {
      // ( xxx :
      // ( xxx ,
      // ( xxx ?
      // ( xxx =
      return true;
    }

    if ((0, _index.match)(_types.TokenType.parenR)) {
      (0, _index.next)();

      if ((0, _index.match)(_types.TokenType.arrow)) {
        // ( xxx ) =>
        return true;
      }
    }
  }

  return false;
}

function tsParseTypeOrTypePredicateAnnotation(returnToken) {
  var oldIsType = (0, _index.pushTypeContext)(0);
  (0, _util.expect)(returnToken);
  var finishedReturn = tsParseTypePredicateOrAssertsPrefix();

  if (!finishedReturn) {
    tsParseType();
  }

  (0, _index.popTypeContext)(oldIsType);
}

function tsTryParseTypeOrTypePredicateAnnotation() {
  if ((0, _index.match)(_types.TokenType.colon)) {
    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
  }
}

function tsTryParseTypeAnnotation() {
  if ((0, _index.match)(_types.TokenType.colon)) {
    tsParseTypeAnnotation();
  }
}

function tsTryParseType() {
  if ((0, _index.eat)(_types.TokenType.colon)) {
    tsParseType();
  }
}
/**
 * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,
 * `asserts this is T`.
 *
 * Returns true if we parsed the return type, false if there's still a type to be parsed.
 */


function tsParseTypePredicateOrAssertsPrefix() {
  var snapshot = _base.state.snapshot();

  if ((0, _util.isContextual)(_keywords.ContextualKeyword._asserts)) {
    // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-
    // defined type guard on the `asserts` variable) or just a type called `asserts`.
    (0, _index.next)();

    if ((0, _util.eatContextual)(_keywords.ContextualKeyword._is)) {
      // If we see `asserts is`, then this must be of the form `asserts is T`, since
      // `asserts is is T` isn't valid.
      tsParseType();
      return true;
    } else if (tsIsIdentifier() || (0, _index.match)(_types.TokenType._this)) {
      (0, _index.next)();

      if ((0, _util.eatContextual)(_keywords.ContextualKeyword._is)) {
        // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.
        tsParseType();
      }

      return true;
    } else {
      // Regular type, so bail out and start type parsing from scratch.
      _base.state.restoreFromSnapshot(snapshot);

      return false;
    }
  } else if (tsIsIdentifier() || (0, _index.match)(_types.TokenType._this)) {
    // This is a regular identifier, which may or may not have "is" after it.
    (0, _index.next)();

    if ((0, _util.isContextual)(_keywords.ContextualKeyword._is) && !(0, _util.hasPrecedingLineBreak)()) {
      (0, _index.next)();
      tsParseType();
      return true;
    } else {
      // Regular type, so bail out and start type parsing from scratch.
      _base.state.restoreFromSnapshot(snapshot);

      return false;
    }
  }

  return false;
}

function tsParseTypeAnnotation() {
  var oldIsType = (0, _index.pushTypeContext)(0);
  (0, _util.expect)(_types.TokenType.colon);
  tsParseType();
  (0, _index.popTypeContext)(oldIsType);
}

function tsParseType() {
  tsParseNonConditionalType();

  if (_base.state.inDisallowConditionalTypesContext || (0, _util.hasPrecedingLineBreak)() || !(0, _index.eat)(_types.TokenType._extends)) {
    return;
  } // extends type


  var oldInDisallowConditionalTypesContext = _base.state.inDisallowConditionalTypesContext;
  _base.state.inDisallowConditionalTypesContext = true;
  tsParseNonConditionalType();
  _base.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
  (0, _util.expect)(_types.TokenType.question); // true type

  tsParseType();
  (0, _util.expect)(_types.TokenType.colon); // false type

  tsParseType();
}

function isAbstractConstructorSignature() {
  return (0, _util.isContextual)(_keywords.ContextualKeyword._abstract) && (0, _index.lookaheadType)() === _types.TokenType._new;
}

function tsParseNonConditionalType() {
  if (tsIsStartOfFunctionType()) {
    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);
    return;
  }

  if ((0, _index.match)(_types.TokenType._new)) {
    // As in `new () => Date`
    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);
    return;
  } else if (isAbstractConstructorSignature()) {
    // As in `abstract new () => Date`
    tsParseFunctionOrConstructorType(FunctionType.TSAbstractConstructorType);
    return;
  }

  tsParseUnionTypeOrHigher();
}

function tsParseTypeAssertion() {
  var oldIsType = (0, _index.pushTypeContext)(1);
  tsParseType();
  (0, _util.expect)(_types.TokenType.greaterThan);
  (0, _index.popTypeContext)(oldIsType);
  (0, _expression.parseMaybeUnary)();
}

function tsTryParseJSXTypeArgument() {
  if ((0, _index.eat)(_types.TokenType.jsxTagStart)) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.typeParameterStart;
    var oldIsType = (0, _index.pushTypeContext)(1);

    while (!(0, _index.match)(_types.TokenType.greaterThan) && !_base.state.error) {
      tsParseType();
      (0, _index.eat)(_types.TokenType.comma);
    } // Process >, but the one after needs to be parsed JSX-style.


    (0, _jsx.nextJSXTagToken)();
    (0, _index.popTypeContext)(oldIsType);
  }
}

function tsParseHeritageClause() {
  while (!(0, _index.match)(_types.TokenType.braceL) && !_base.state.error) {
    tsParseExpressionWithTypeArguments();
    (0, _index.eat)(_types.TokenType.comma);
  }
}

function tsParseExpressionWithTypeArguments() {
  // Note: TS uses parseLeftHandSideExpressionOrHigher,
  // then has grammar errors later if it's not an EntityName.
  tsParseEntityName();

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}

function tsParseInterfaceDeclaration() {
  (0, _lval.parseBindingIdentifier)(false);
  tsTryParseTypeParameters();

  if ((0, _index.eat)(_types.TokenType._extends)) {
    tsParseHeritageClause();
  }

  tsParseObjectTypeMembers();
}

function tsParseTypeAliasDeclaration() {
  (0, _lval.parseBindingIdentifier)(false);
  tsTryParseTypeParameters();
  (0, _util.expect)(_types.TokenType.eq);
  tsParseType();
  (0, _util.semicolon)();
}

function tsParseEnumMember() {
  // Computed property names are grammar errors in an enum, so accept just string literal or identifier.
  if ((0, _index.match)(_types.TokenType.string)) {
    (0, _expression.parseLiteral)();
  } else {
    (0, _expression.parseIdentifier)();
  }

  if ((0, _index.eat)(_types.TokenType.eq)) {
    var eqIndex = _base.state.tokens.length - 1;
    (0, _expression.parseMaybeAssign)();
    _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
  }
}

function tsParseEnumDeclaration() {
  (0, _lval.parseBindingIdentifier)(false);
  (0, _util.expect)(_types.TokenType.braceL);

  while (!(0, _index.eat)(_types.TokenType.braceR) && !_base.state.error) {
    tsParseEnumMember();
    (0, _index.eat)(_types.TokenType.comma);
  }
}

function tsParseModuleBlock() {
  (0, _util.expect)(_types.TokenType.braceL);
  (0, _statement.parseBlockBody)(
  /* end */
  _types.TokenType.braceR);
}

function tsParseModuleOrNamespaceDeclaration() {
  (0, _lval.parseBindingIdentifier)(false);

  if ((0, _index.eat)(_types.TokenType.dot)) {
    tsParseModuleOrNamespaceDeclaration();
  } else {
    tsParseModuleBlock();
  }
}

function tsParseAmbientExternalModuleDeclaration() {
  if ((0, _util.isContextual)(_keywords.ContextualKeyword._global)) {
    (0, _expression.parseIdentifier)();
  } else if ((0, _index.match)(_types.TokenType.string)) {
    (0, _expression.parseExprAtom)();
  } else {
    (0, _util.unexpected)();
  }

  if ((0, _index.match)(_types.TokenType.braceL)) {
    tsParseModuleBlock();
  } else {
    (0, _util.semicolon)();
  }
}

function tsParseImportEqualsDeclaration() {
  (0, _lval.parseImportedIdentifier)();
  (0, _util.expect)(_types.TokenType.eq);
  tsParseModuleReference();
  (0, _util.semicolon)();
}

function tsIsExternalModuleReference() {
  return (0, _util.isContextual)(_keywords.ContextualKeyword._require) && (0, _index.lookaheadType)() === _types.TokenType.parenL;
}

function tsParseModuleReference() {
  if (tsIsExternalModuleReference()) {
    tsParseExternalModuleReference();
  } else {
    tsParseEntityName();
  }
}

function tsParseExternalModuleReference() {
  (0, _util.expectContextual)(_keywords.ContextualKeyword._require);
  (0, _util.expect)(_types.TokenType.parenL);

  if (!(0, _index.match)(_types.TokenType.string)) {
    (0, _util.unexpected)();
  }

  (0, _expression.parseLiteral)();
  (0, _util.expect)(_types.TokenType.parenR);
} // Utilities
// Returns true if a statement matched.


function tsTryParseDeclare() {
  if ((0, _util.isLineTerminator)()) {
    return false;
  }

  switch (_base.state.type) {
    case _types.TokenType._function:
      {
        var oldIsType = (0, _index.pushTypeContext)(1);
        (0, _index.next)(); // We don't need to precisely get the function start here, since it's only used to mark
        // the function as a type if it's bodiless, and it's already a type here.

        var functionStart = _base.state.start;
        (0, _statement.parseFunction)(functionStart,
        /* isStatement */
        true);
        (0, _index.popTypeContext)(oldIsType);
        return true;
      }

    case _types.TokenType._class:
      {
        var _oldIsType = (0, _index.pushTypeContext)(1);

        (0, _statement.parseClass)(
        /* isStatement */
        true,
        /* optionalId */
        false);
        (0, _index.popTypeContext)(_oldIsType);
        return true;
      }

    case _types.TokenType._const:
      {
        if ((0, _index.match)(_types.TokenType._const) && (0, _util.isLookaheadContextual)(_keywords.ContextualKeyword._enum)) {
          var _oldIsType2 = (0, _index.pushTypeContext)(1); // `const enum = 0;` not allowed because "enum" is a strict mode reserved word.


          (0, _util.expect)(_types.TokenType._const);
          (0, _util.expectContextual)(_keywords.ContextualKeyword._enum);
          _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
          tsParseEnumDeclaration();
          (0, _index.popTypeContext)(_oldIsType2);
          return true;
        }
      }
    // falls through

    case _types.TokenType._var:
    case _types.TokenType._let:
      {
        var _oldIsType3 = (0, _index.pushTypeContext)(1);

        (0, _statement.parseVarStatement)(_base.state.type !== _types.TokenType._var);
        (0, _index.popTypeContext)(_oldIsType3);
        return true;
      }

    case _types.TokenType.name:
      {
        var _oldIsType4 = (0, _index.pushTypeContext)(1);

        var contextualKeyword = _base.state.contextualKeyword;
        var matched = false;

        if (contextualKeyword === _keywords.ContextualKeyword._global) {
          tsParseAmbientExternalModuleDeclaration();
          matched = true;
        } else {
          matched = tsParseDeclaration(contextualKeyword,
          /* isBeforeToken */
          true);
        }

        (0, _index.popTypeContext)(_oldIsType4);
        return matched;
      }

    default:
      return false;
  }
} // Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.
// Returns true if it matched a declaration.


function tsTryParseExportDeclaration() {
  return tsParseDeclaration(_base.state.contextualKeyword,
  /* isBeforeToken */
  true);
} // Returns true if it matched a statement.


function tsParseExpressionStatement(contextualKeyword) {
  switch (contextualKeyword) {
    case _keywords.ContextualKeyword._declare:
      {
        var declareTokenIndex = _base.state.tokens.length - 1;
        var matched = tsTryParseDeclare();

        if (matched) {
          _base.state.tokens[declareTokenIndex].type = _types.TokenType._declare;
          return true;
        }

        break;
      }

    case _keywords.ContextualKeyword._global:
      // `global { }` (with no `declare`) may appear inside an ambient module declaration.
      // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past "global".
      if ((0, _index.match)(_types.TokenType.braceL)) {
        tsParseModuleBlock();
        return true;
      }

      break;

    default:
      return tsParseDeclaration(contextualKeyword,
      /* isBeforeToken */
      false);
  }

  return false;
}
/**
 * Common code for parsing a declaration.
 *
 * isBeforeToken indicates that the current parser state is at the contextual
 * keyword (and that it is not yet emitted) rather than reading the token after
 * it. When isBeforeToken is true, we may be preceded by an `export` token and
 * should include that token in a type context we create, e.g. to handle
 * `export interface` or `export type`. (This is a bit of a hack and should be
 * cleaned up at some point.)
 *
 * Returns true if it matched a declaration.
 */


function tsParseDeclaration(contextualKeyword, isBeforeToken) {
  switch (contextualKeyword) {
    case _keywords.ContextualKeyword._abstract:
      if (tsCheckLineTerminator(isBeforeToken) && (0, _index.match)(_types.TokenType._class)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;
        (0, _statement.parseClass)(
        /* isStatement */
        true,
        /* optionalId */
        false);
        return true;
      }

      break;

    case _keywords.ContextualKeyword._enum:
      if (tsCheckLineTerminator(isBeforeToken) && (0, _index.match)(_types.TokenType.name)) {
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
        tsParseEnumDeclaration();
        return true;
      }

      break;

    case _keywords.ContextualKeyword._interface:
      if (tsCheckLineTerminator(isBeforeToken) && (0, _index.match)(_types.TokenType.name)) {
        // `next` is true in "export" and "declare" contexts, so we want to remove that token
        // as well.
        var oldIsType = (0, _index.pushTypeContext)(isBeforeToken ? 2 : 1);
        tsParseInterfaceDeclaration();
        (0, _index.popTypeContext)(oldIsType);
        return true;
      }

      break;

    case _keywords.ContextualKeyword._module:
      if (tsCheckLineTerminator(isBeforeToken)) {
        if ((0, _index.match)(_types.TokenType.string)) {
          var _oldIsType5 = (0, _index.pushTypeContext)(isBeforeToken ? 2 : 1);

          tsParseAmbientExternalModuleDeclaration();
          (0, _index.popTypeContext)(_oldIsType5);
          return true;
        } else if ((0, _index.match)(_types.TokenType.name)) {
          var _oldIsType6 = (0, _index.pushTypeContext)(isBeforeToken ? 2 : 1);

          tsParseModuleOrNamespaceDeclaration();
          (0, _index.popTypeContext)(_oldIsType6);
          return true;
        }
      }

      break;

    case _keywords.ContextualKeyword._namespace:
      if (tsCheckLineTerminator(isBeforeToken) && (0, _index.match)(_types.TokenType.name)) {
        var _oldIsType7 = (0, _index.pushTypeContext)(isBeforeToken ? 2 : 1);

        tsParseModuleOrNamespaceDeclaration();
        (0, _index.popTypeContext)(_oldIsType7);
        return true;
      }

      break;

    case _keywords.ContextualKeyword._type:
      if (tsCheckLineTerminator(isBeforeToken) && (0, _index.match)(_types.TokenType.name)) {
        var _oldIsType8 = (0, _index.pushTypeContext)(isBeforeToken ? 2 : 1);

        tsParseTypeAliasDeclaration();
        (0, _index.popTypeContext)(_oldIsType8);
        return true;
      }

      break;

    default:
      break;
  }

  return false;
}

function tsCheckLineTerminator(isBeforeToken) {
  if (isBeforeToken) {
    // Babel checks hasFollowingLineBreak here and returns false, but this
    // doesn't actually come up, e.g. `export interface` can never be on its own
    // line in valid code.
    (0, _index.next)();
    return true;
  } else {
    return !(0, _util.isLineTerminator)();
  }
} // Returns true if there was a generic async arrow function.


function tsTryParseGenericAsyncArrowFunction() {
  var snapshot = _base.state.snapshot();

  tsParseTypeParameters();
  (0, _statement.parseFunctionParams)();
  tsTryParseTypeOrTypePredicateAnnotation();
  (0, _util.expect)(_types.TokenType.arrow);

  if (_base.state.error) {
    _base.state.restoreFromSnapshot(snapshot);

    return false;
  }

  (0, _expression.parseFunctionBody)(true);
  return true;
}
/**
 * If necessary, hack the tokenizer state so that this bitshift was actually a
 * less-than token, then keep parsing. This should only be used in situations
 * where we restore from snapshot on error (which reverts this change) or
 * where bitshift would be illegal anyway (e.g. in a class "extends" clause).
 *
 * This hack is useful to handle situations like foo<<T>() => void>() where
 * there can legitimately be two open-angle-brackets in a row in TS.
 */


function tsParseTypeArgumentsWithPossibleBitshift() {
  if (_base.state.type === _types.TokenType.bitShiftL) {
    _base.state.pos -= 1;
    (0, _index.finishToken)(_types.TokenType.lessThan);
  }

  tsParseTypeArguments();
}

function tsParseTypeArguments() {
  var oldIsType = (0, _index.pushTypeContext)(0);
  (0, _util.expect)(_types.TokenType.lessThan);

  while (!(0, _index.match)(_types.TokenType.greaterThan) && !_base.state.error) {
    tsParseType();
    (0, _index.eat)(_types.TokenType.comma);
  }

  if (!oldIsType) {
    // If the type arguments are present in an expression context, e.g.
    // f<number>(), then the > sign should be tokenized as a non-type token.
    // In particular, f(a < b, c >= d) should parse the >= as a single token,
    // resulting in a syntax error and fallback to the non-type-args
    // interpretation. In the success case, even though the > is tokenized as a
    // non-type token, it still must be marked as a type token so that it is
    // erased.
    (0, _index.popTypeContext)(oldIsType);
    (0, _index.rescan_gt)();
    (0, _util.expect)(_types.TokenType.greaterThan);
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
  } else {
    (0, _util.expect)(_types.TokenType.greaterThan);
    (0, _index.popTypeContext)(oldIsType);
  }
}

function tsIsDeclarationStart() {
  if ((0, _index.match)(_types.TokenType.name)) {
    switch (_base.state.contextualKeyword) {
      case _keywords.ContextualKeyword._abstract:
      case _keywords.ContextualKeyword._declare:
      case _keywords.ContextualKeyword._enum:
      case _keywords.ContextualKeyword._interface:
      case _keywords.ContextualKeyword._module:
      case _keywords.ContextualKeyword._namespace:
      case _keywords.ContextualKeyword._type:
        return true;

      default:
        break;
    }
  }

  return false;
} // ======================================================
// OVERRIDES
// ======================================================


function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if ((0, _index.match)(_types.TokenType.colon)) {
    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
  } // The original code checked the node type to make sure this function type allows a missing
  // body, but we skip that to avoid sending around the node type. We instead just use the
  // allowExpressionBody boolean to make sure it's not an arrow function.


  if (!(0, _index.match)(_types.TokenType.braceL) && (0, _util.isLineTerminator)()) {
    // Retroactively mark the function declaration as a type.
    var i = _base.state.tokens.length - 1;

    while (i >= 0 && (_base.state.tokens[i].start >= functionStart || _base.state.tokens[i].type === _types.TokenType._default || _base.state.tokens[i].type === _types.TokenType._export)) {
      _base.state.tokens[i].isType = true;
      i--;
    }

    return;
  }

  (0, _expression.parseFunctionBody)(false, funcContextId);
}

function tsParseSubscript(startTokenIndex, noCalls, stopState) {
  if (!(0, _util.hasPrecedingLineBreak)() && (0, _index.eat)(_types.TokenType.bang)) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.nonNullAssertion;
    return;
  }

  if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.bitShiftL)) {
    // There are number of things we are going to "maybe" parse, like type arguments on
    // tagged template expressions. If any of them fail, walk it back and continue.
    var snapshot = _base.state.snapshot();

    if (!noCalls && (0, _expression.atPossibleAsync)()) {
      // Almost certainly this is a generic async function `async <T>() => ...
      // But it might be a call with a type argument `async<T>();`
      var asyncArrowFn = tsTryParseGenericAsyncArrowFunction();

      if (asyncArrowFn) {
        return;
      }
    }

    tsParseTypeArgumentsWithPossibleBitshift();

    if (!noCalls && (0, _index.eat)(_types.TokenType.parenL)) {
      // With f<T>(), the subscriptStartIndex marker is on the ( token.
      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      (0, _expression.parseCallExpressionArguments)();
    } else if ((0, _index.match)(_types.TokenType.backQuote)) {
      // Tagged template with a type argument.
      (0, _expression.parseTemplate)();
    } else if ( // The remaining possible case is an instantiation expression, e.g.
    // Array<number> . Check for a few cases that would disqualify it and
    // cause us to bail out.
    // a<b>>c is not (a<b>)>c, but a<(b>>c)
    _base.state.type === _types.TokenType.greaterThan || // a<b>c is (a<b)>c
    _base.state.type !== _types.TokenType.parenL && Boolean(_base.state.type & _types.TokenType.IS_EXPRESSION_START) && !(0, _util.hasPrecedingLineBreak)()) {
      // Bail out. We have something like a<b>c, which is not an expression with
      // type arguments but an (a < b) > c comparison.
      (0, _util.unexpected)();
    }

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  } else if (!noCalls && (0, _index.match)(_types.TokenType.questionDot) && (0, _index.lookaheadType)() === _types.TokenType.lessThan) {
    // If we see f?.<, then this must be an optional call with a type argument.
    (0, _index.next)();
    _base.state.tokens[startTokenIndex].isOptionalChainStart = true; // With f?.<T>(), the subscriptStartIndex marker is on the ?. token.

    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    tsParseTypeArguments();
    (0, _util.expect)(_types.TokenType.parenL);
    (0, _expression.parseCallExpressionArguments)();
  }

  (0, _expression.baseParseSubscript)(startTokenIndex, noCalls, stopState);
}

function tsTryParseExport() {
  if ((0, _index.eat)(_types.TokenType._import)) {
    // One of these cases:
    // export import A = B;
    // export import type A = require("A");
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._type) && (0, _index.lookaheadType)() !== _types.TokenType.eq) {
      // Eat a `type` token, unless it's actually an identifier name.
      (0, _util.expectContextual)(_keywords.ContextualKeyword._type);
    }

    tsParseImportEqualsDeclaration();
    return true;
  } else if ((0, _index.eat)(_types.TokenType.eq)) {
    // `export = x;`
    (0, _expression.parseExpression)();
    (0, _util.semicolon)();
    return true;
  } else if ((0, _util.eatContextual)(_keywords.ContextualKeyword._as)) {
    // `export as namespace A;`
    // See `parseNamespaceExportDeclaration` in TypeScript's own parser
    (0, _util.expectContextual)(_keywords.ContextualKeyword._namespace);
    (0, _expression.parseIdentifier)();
    (0, _util.semicolon)();
    return true;
  } else {
    if ((0, _util.isContextual)(_keywords.ContextualKeyword._type)) {
      var nextType = (0, _index.lookaheadType)(); // export type {foo} from 'a';
      // export type * from 'a';'
      // export type * as ns from 'a';'

      if (nextType === _types.TokenType.braceL || nextType === _types.TokenType.star) {
        (0, _index.next)();
      }
    }

    return false;
  }
}
/**
 * Parse a TS import specifier, which may be prefixed with "type" and may be of
 * the form `foo as bar`.
 *
 * The number of identifier-like tokens we see happens to be enough to uniquely
 * identify the form, so simply count the number of identifiers rather than
 * matching the words `type` or `as`. This is particularly important because
 * `type` and `as` could each actually be plain identifiers rather than
 * keywords.
 */


function tsParseImportSpecifier() {
  (0, _expression.parseIdentifier)();

  if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
    // import {foo}
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
    return;
  }

  (0, _expression.parseIdentifier)();

  if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
    // import {type foo}
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
    _base.state.tokens[_base.state.tokens.length - 2].isType = true;
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
    return;
  }

  (0, _expression.parseIdentifier)();

  if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
    // import {foo as bar}
    _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ImportAccess;
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
    return;
  }

  (0, _expression.parseIdentifier)(); // import {type foo as bar}

  _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ImportAccess;
  _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ImportDeclaration;
  _base.state.tokens[_base.state.tokens.length - 4].isType = true;
  _base.state.tokens[_base.state.tokens.length - 3].isType = true;
  _base.state.tokens[_base.state.tokens.length - 2].isType = true;
  _base.state.tokens[_base.state.tokens.length - 1].isType = true;
}
/**
 * Just like named import specifiers, export specifiers can have from 1 to 4
 * tokens, inclusive, and the number of tokens determines the role of each token.
 */


function tsParseExportSpecifier() {
  (0, _expression.parseIdentifier)();

  if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
    // export {foo}
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ExportAccess;
    return;
  }

  (0, _expression.parseIdentifier)();

  if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
    // export {type foo}
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = _index.IdentifierRole.ExportAccess;
    _base.state.tokens[_base.state.tokens.length - 2].isType = true;
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
    return;
  }

  (0, _expression.parseIdentifier)();

  if ((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.braceR)) {
    // export {foo as bar}
    _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ExportAccess;
    return;
  }

  (0, _expression.parseIdentifier)(); // export {type foo as bar}

  _base.state.tokens[_base.state.tokens.length - 3].identifierRole = _index.IdentifierRole.ExportAccess;
  _base.state.tokens[_base.state.tokens.length - 4].isType = true;
  _base.state.tokens[_base.state.tokens.length - 3].isType = true;
  _base.state.tokens[_base.state.tokens.length - 2].isType = true;
  _base.state.tokens[_base.state.tokens.length - 1].isType = true;
}

function tsTryParseExportDefaultExpression() {
  if ((0, _util.isContextual)(_keywords.ContextualKeyword._abstract) && (0, _index.lookaheadType)() === _types.TokenType._class) {
    _base.state.type = _types.TokenType._abstract;
    (0, _index.next)(); // Skip "abstract"

    (0, _statement.parseClass)(true, true);
    return true;
  }

  if ((0, _util.isContextual)(_keywords.ContextualKeyword._interface)) {
    // Make sure "export default" are considered type tokens so the whole thing is removed.
    var oldIsType = (0, _index.pushTypeContext)(2);
    tsParseDeclaration(_keywords.ContextualKeyword._interface, true);
    (0, _index.popTypeContext)(oldIsType);
    return true;
  }

  return false;
}

function tsTryParseStatementContent() {
  if (_base.state.type === _types.TokenType._const) {
    var ahead = (0, _index.lookaheadTypeAndKeyword)();

    if (ahead.type === _types.TokenType.name && ahead.contextualKeyword === _keywords.ContextualKeyword._enum) {
      (0, _util.expect)(_types.TokenType._const);
      (0, _util.expectContextual)(_keywords.ContextualKeyword._enum);
      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
      tsParseEnumDeclaration();
      return true;
    }
  }

  return false;
}

function tsTryParseClassMemberWithIsStatic(isStatic) {
  var memberStartIndexAfterStatic = _base.state.tokens.length;
  tsParseModifiers([_keywords.ContextualKeyword._abstract, _keywords.ContextualKeyword._readonly, _keywords.ContextualKeyword._declare, _keywords.ContextualKeyword._static, _keywords.ContextualKeyword._override]);
  var modifiersEndIndex = _base.state.tokens.length;
  var found = tsTryParseIndexSignature();

  if (found) {
    // Index signatures are type declarations, so set the modifier tokens as
    // type tokens. Most tokens could be assumed to be type tokens, but `static`
    // is ambiguous unless we set it explicitly here.
    var memberStartIndex = isStatic ? memberStartIndexAfterStatic - 1 : memberStartIndexAfterStatic;

    for (var i = memberStartIndex; i < modifiersEndIndex; i++) {
      _base.state.tokens[i].isType = true;
    }

    return true;
  }

  return false;
} // Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`
// is that e.g. `type()` is valid JS, so we must try parsing that first.
// If it's really a type, we will parse `type` as the statement, and can correct it here
// by parsing the rest.


function tsParseIdentifierStatement(contextualKeyword) {
  var matched = tsParseExpressionStatement(contextualKeyword);

  if (!matched) {
    (0, _util.semicolon)();
  }
}

function tsParseExportDeclaration() {
  // "export declare" is equivalent to just "export".
  var isDeclare = (0, _util.eatContextual)(_keywords.ContextualKeyword._declare);

  if (isDeclare) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;
  }

  var matchedDeclaration = false;

  if ((0, _index.match)(_types.TokenType.name)) {
    if (isDeclare) {
      var oldIsType = (0, _index.pushTypeContext)(2);
      matchedDeclaration = tsTryParseExportDeclaration();
      (0, _index.popTypeContext)(oldIsType);
    } else {
      matchedDeclaration = tsTryParseExportDeclaration();
    }
  }

  if (!matchedDeclaration) {
    if (isDeclare) {
      var _oldIsType9 = (0, _index.pushTypeContext)(2);

      (0, _statement.parseStatement)(true);
      (0, _index.popTypeContext)(_oldIsType9);
    } else {
      (0, _statement.parseStatement)(true);
    }
  }
}

function tsAfterParseClassSuper(hasSuper) {
  if (hasSuper && ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.bitShiftL))) {
    tsParseTypeArgumentsWithPossibleBitshift();
  }

  if ((0, _util.eatContextual)(_keywords.ContextualKeyword._implements)) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;
    var oldIsType = (0, _index.pushTypeContext)(1);
    tsParseHeritageClause();
    (0, _index.popTypeContext)(oldIsType);
  }
}

function tsStartParseObjPropValue() {
  tsTryParseTypeParameters();
}

function tsStartParseFunctionParams() {
  tsTryParseTypeParameters();
} // `let x: number;`


function tsAfterParseVarHead() {
  var oldIsType = (0, _index.pushTypeContext)(0);

  if (!(0, _util.hasPrecedingLineBreak)()) {
    (0, _index.eat)(_types.TokenType.bang);
  }

  tsTryParseTypeAnnotation();
  (0, _index.popTypeContext)(oldIsType);
} // parse the return type of an async arrow function - let foo = (async (): number => {});


function tsStartParseAsyncArrowFromCallExpression() {
  if ((0, _index.match)(_types.TokenType.colon)) {
    tsParseTypeAnnotation();
  }
} // Returns true if the expression was an arrow function.


function tsParseMaybeAssign(noIn, isWithinParens) {
  // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.
  if (_base.isJSXEnabled) {
    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);
  } else {
    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);
  }
}

function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {
  if (!(0, _index.match)(_types.TokenType.lessThan)) {
    return (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
  } // Prefer to parse JSX if possible. But may be an arrow fn.


  var snapshot = _base.state.snapshot();

  var wasArrow = (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);

  if (_base.state.error) {
    _base.state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  } // Otherwise, try as type-parameterized arrow function.


  _base.state.type = _types.TokenType.typeParameterStart; // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.

  tsParseTypeParameters();
  wasArrow = (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);

  if (!wasArrow) {
    (0, _util.unexpected)();
  }

  return wasArrow;
}

function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {
  if (!(0, _index.match)(_types.TokenType.lessThan)) {
    return (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
  }

  var snapshot = _base.state.snapshot(); // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.


  tsParseTypeParameters();
  var wasArrow = (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);

  if (!wasArrow) {
    (0, _util.unexpected)();
  }

  if (_base.state.error) {
    _base.state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  } // Try parsing a type cast instead of an arrow function.
  // This will start with a type assertion (via parseMaybeUnary).
  // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.


  return (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
}

function tsParseArrow() {
  if ((0, _index.match)(_types.TokenType.colon)) {
    // This is different from how the TS parser does it.
    // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.
    var snapshot = _base.state.snapshot();

    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
    if ((0, _util.canInsertSemicolon)()) (0, _util.unexpected)();
    if (!(0, _index.match)(_types.TokenType.arrow)) (0, _util.unexpected)();

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
  }

  return (0, _index.eat)(_types.TokenType.arrow);
} // Allow type annotations inside of a parameter list.


function tsParseAssignableListItemTypes() {
  var oldIsType = (0, _index.pushTypeContext)(0);
  (0, _index.eat)(_types.TokenType.question);
  tsTryParseTypeAnnotation();
  (0, _index.popTypeContext)(oldIsType);
}

function tsParseMaybeDecoratorArguments() {
  if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.bitShiftL)) {
    tsParseTypeArgumentsWithPossibleBitshift();
  }

  (0, _statement.baseParseMaybeDecoratorArguments)();
}