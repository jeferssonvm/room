"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typedParseConditional = typedParseConditional;
exports.typedParseParenItem = typedParseParenItem;

var _index = require("../tokenizer/index");

var _types = require("../tokenizer/types");

var _base = require("../traverser/base");

var _expression = require("../traverser/expression");

var _flow = require("./flow");

var _typescript = require("./typescript");

/**
 * Common parser code for TypeScript and Flow.
 */
// An apparent conditional expression could actually be an optional parameter in an arrow function.
function typedParseConditional(noIn) {
  // If we see ?:, this can't possibly be a valid conditional. typedParseParenItem will be called
  // later to finish off the arrow parameter. We also need to handle bare ? tokens for optional
  // parameters without type annotations, i.e. ?, and ?) .
  if ((0, _index.match)(_types.TokenType.question)) {
    var nextType = (0, _index.lookaheadType)();

    if (nextType === _types.TokenType.colon || nextType === _types.TokenType.comma || nextType === _types.TokenType.parenR) {
      return;
    }
  }

  (0, _expression.baseParseConditional)(noIn);
} // Note: These "type casts" are *not* valid TS expressions.
// But we parse them here and change them when completing the arrow function.


function typedParseParenItem() {
  (0, _index.eatTypeToken)(_types.TokenType.question);

  if ((0, _index.match)(_types.TokenType.colon)) {
    if (_base.isTypeScriptEnabled) {
      (0, _typescript.tsParseTypeAnnotation)();
    } else if (_base.isFlowEnabled) {
      (0, _flow.flowParseTypeAnnotation)();
    }
  }
}