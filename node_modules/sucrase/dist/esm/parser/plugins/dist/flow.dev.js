"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flowParseTypeParameterDeclaration = flowParseTypeParameterDeclaration;
exports.flowParseTypeAnnotation = flowParseTypeAnnotation;
exports.flowParseVariance = flowParseVariance;
exports.flowParseFunctionBodyAndFinish = flowParseFunctionBodyAndFinish;
exports.flowParseSubscript = flowParseSubscript;
exports.flowStartParseNewArguments = flowStartParseNewArguments;
exports.flowTryParseStatement = flowTryParseStatement;
exports.flowTryParseExportDefaultExpression = flowTryParseExportDefaultExpression;
exports.flowParseIdentifierStatement = flowParseIdentifierStatement;
exports.flowShouldParseExportDeclaration = flowShouldParseExportDeclaration;
exports.flowShouldDisallowExportDefaultSpecifier = flowShouldDisallowExportDefaultSpecifier;
exports.flowParseExportDeclaration = flowParseExportDeclaration;
exports.flowShouldParseExportStar = flowShouldParseExportStar;
exports.flowParseExportStar = flowParseExportStar;
exports.flowAfterParseClassSuper = flowAfterParseClassSuper;
exports.flowStartParseObjPropValue = flowStartParseObjPropValue;
exports.flowParseAssignableListItemTypes = flowParseAssignableListItemTypes;
exports.flowStartParseImportSpecifiers = flowStartParseImportSpecifiers;
exports.flowParseImportSpecifier = flowParseImportSpecifier;
exports.flowStartParseFunctionParams = flowStartParseFunctionParams;
exports.flowAfterParseVarHead = flowAfterParseVarHead;
exports.flowStartParseAsyncArrowFromCallExpression = flowStartParseAsyncArrowFromCallExpression;
exports.flowParseMaybeAssign = flowParseMaybeAssign;
exports.flowParseArrow = flowParseArrow;
exports.flowParseSubscripts = flowParseSubscripts;

var _index = require("../tokenizer/index");

var _keywords = require("../tokenizer/keywords");

var _types = require("../tokenizer/types");

var _base = require("../traverser/base");

var _expression = require("../traverser/expression");

var _statement = require("../traverser/statement");

var _util = require("../traverser/util");

/* eslint max-len: 0 */
function isMaybeDefaultImport(lookahead) {
  return (lookahead.type === _types.TokenType.name || !!(lookahead.type & _types.TokenType.IS_KEYWORD)) && lookahead.contextualKeyword !== _keywords.ContextualKeyword._from;
}

function flowParseTypeInitialiser(tok) {
  var oldIsType = (0, _index.pushTypeContext)(0);
  (0, _util.expect)(tok || _types.TokenType.colon);
  flowParseType();
  (0, _index.popTypeContext)(oldIsType);
}

function flowParsePredicate() {
  (0, _util.expect)(_types.TokenType.modulo);
  (0, _util.expectContextual)(_keywords.ContextualKeyword._checks);

  if ((0, _index.eat)(_types.TokenType.parenL)) {
    (0, _expression.parseExpression)();
    (0, _util.expect)(_types.TokenType.parenR);
  }
}

function flowParseTypeAndPredicateInitialiser() {
  var oldIsType = (0, _index.pushTypeContext)(0);
  (0, _util.expect)(_types.TokenType.colon);

  if ((0, _index.match)(_types.TokenType.modulo)) {
    flowParsePredicate();
  } else {
    flowParseType();

    if ((0, _index.match)(_types.TokenType.modulo)) {
      flowParsePredicate();
    }
  }

  (0, _index.popTypeContext)(oldIsType);
}

function flowParseDeclareClass() {
  (0, _index.next)();
  flowParseInterfaceish(
  /* isClass */
  true);
}

function flowParseDeclareFunction() {
  (0, _index.next)();
  (0, _expression.parseIdentifier)();

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  (0, _util.expect)(_types.TokenType.parenL);
  flowParseFunctionTypeParams();
  (0, _util.expect)(_types.TokenType.parenR);
  flowParseTypeAndPredicateInitialiser();
  (0, _util.semicolon)();
}

function flowParseDeclare() {
  if ((0, _index.match)(_types.TokenType._class)) {
    flowParseDeclareClass();
  } else if ((0, _index.match)(_types.TokenType._function)) {
    flowParseDeclareFunction();
  } else if ((0, _index.match)(_types.TokenType._var)) {
    flowParseDeclareVariable();
  } else if ((0, _util.eatContextual)(_keywords.ContextualKeyword._module)) {
    if ((0, _index.eat)(_types.TokenType.dot)) {
      flowParseDeclareModuleExports();
    } else {
      flowParseDeclareModule();
    }
  } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._type)) {
    flowParseDeclareTypeAlias();
  } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._opaque)) {
    flowParseDeclareOpaqueType();
  } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._interface)) {
    flowParseDeclareInterface();
  } else if ((0, _index.match)(_types.TokenType._export)) {
    flowParseDeclareExportDeclaration();
  } else {
    (0, _util.unexpected)();
  }
}

function flowParseDeclareVariable() {
  (0, _index.next)();
  flowParseTypeAnnotatableIdentifier();
  (0, _util.semicolon)();
}

function flowParseDeclareModule() {
  if ((0, _index.match)(_types.TokenType.string)) {
    (0, _expression.parseExprAtom)();
  } else {
    (0, _expression.parseIdentifier)();
  }

  (0, _util.expect)(_types.TokenType.braceL);

  while (!(0, _index.match)(_types.TokenType.braceR) && !_base.state.error) {
    if ((0, _index.match)(_types.TokenType._import)) {
      (0, _index.next)();
      (0, _statement.parseImport)();
    } else {
      (0, _util.unexpected)();
    }
  }

  (0, _util.expect)(_types.TokenType.braceR);
}

function flowParseDeclareExportDeclaration() {
  (0, _util.expect)(_types.TokenType._export);

  if ((0, _index.eat)(_types.TokenType._default)) {
    if ((0, _index.match)(_types.TokenType._function) || (0, _index.match)(_types.TokenType._class)) {
      // declare export default class ...
      // declare export default function ...
      flowParseDeclare();
    } else {
      // declare export default [type];
      flowParseType();
      (0, _util.semicolon)();
    }
  } else if ((0, _index.match)(_types.TokenType._var) || // declare export var ...
  (0, _index.match)(_types.TokenType._function) || // declare export function ...
  (0, _index.match)(_types.TokenType._class) || // declare export class ...
  (0, _util.isContextual)(_keywords.ContextualKeyword._opaque) // declare export opaque ..
  ) {
      flowParseDeclare();
    } else if ((0, _index.match)(_types.TokenType.star) || // declare export * from ''
  (0, _index.match)(_types.TokenType.braceL) || // declare export {} ...
  (0, _util.isContextual)(_keywords.ContextualKeyword._interface) || // declare export interface ...
  (0, _util.isContextual)(_keywords.ContextualKeyword._type) || // declare export type ...
  (0, _util.isContextual)(_keywords.ContextualKeyword._opaque) // declare export opaque type ...
  ) {
      (0, _statement.parseExport)();
    } else {
    (0, _util.unexpected)();
  }
}

function flowParseDeclareModuleExports() {
  (0, _util.expectContextual)(_keywords.ContextualKeyword._exports);
  flowParseTypeAnnotation();
  (0, _util.semicolon)();
}

function flowParseDeclareTypeAlias() {
  (0, _index.next)();
  flowParseTypeAlias();
}

function flowParseDeclareOpaqueType() {
  (0, _index.next)();
  flowParseOpaqueType(true);
}

function flowParseDeclareInterface() {
  (0, _index.next)();
  flowParseInterfaceish();
} // Interfaces


function flowParseInterfaceish() {
  var isClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  flowParseRestrictedIdentifier();

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  if ((0, _index.eat)(_types.TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while (!isClass && (0, _index.eat)(_types.TokenType.comma));
  }

  if ((0, _util.isContextual)(_keywords.ContextualKeyword._mixins)) {
    (0, _index.next)();

    do {
      flowParseInterfaceExtends();
    } while ((0, _index.eat)(_types.TokenType.comma));
  }

  if ((0, _util.isContextual)(_keywords.ContextualKeyword._implements)) {
    (0, _index.next)();

    do {
      flowParseInterfaceExtends();
    } while ((0, _index.eat)(_types.TokenType.comma));
  }

  flowParseObjectType(isClass, false, isClass);
}

function flowParseInterfaceExtends() {
  flowParseQualifiedTypeIdentifier(false);

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseInterface() {
  flowParseInterfaceish();
}

function flowParseRestrictedIdentifier() {
  (0, _expression.parseIdentifier)();
}

function flowParseTypeAlias() {
  flowParseRestrictedIdentifier();

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  flowParseTypeInitialiser(_types.TokenType.eq);
  (0, _util.semicolon)();
}

function flowParseOpaqueType(declare) {
  (0, _util.expectContextual)(_keywords.ContextualKeyword._type);
  flowParseRestrictedIdentifier();

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  } // Parse the supertype


  if ((0, _index.match)(_types.TokenType.colon)) {
    flowParseTypeInitialiser(_types.TokenType.colon);
  }

  if (!declare) {
    flowParseTypeInitialiser(_types.TokenType.eq);
  }

  (0, _util.semicolon)();
}

function flowParseTypeParameter() {
  flowParseVariance();
  flowParseTypeAnnotatableIdentifier();

  if ((0, _index.eat)(_types.TokenType.eq)) {
    flowParseType();
  }
}

function flowParseTypeParameterDeclaration() {
  var oldIsType = (0, _index.pushTypeContext)(0); // istanbul ignore else: this condition is already checked at all call sites

  if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.typeParameterStart)) {
    (0, _index.next)();
  } else {
    (0, _util.unexpected)();
  }

  do {
    flowParseTypeParameter();

    if (!(0, _index.match)(_types.TokenType.greaterThan)) {
      (0, _util.expect)(_types.TokenType.comma);
    }
  } while (!(0, _index.match)(_types.TokenType.greaterThan) && !_base.state.error);

  (0, _util.expect)(_types.TokenType.greaterThan);
  (0, _index.popTypeContext)(oldIsType);
}

function flowParseTypeParameterInstantiation() {
  var oldIsType = (0, _index.pushTypeContext)(0);
  (0, _util.expect)(_types.TokenType.lessThan);

  while (!(0, _index.match)(_types.TokenType.greaterThan) && !_base.state.error) {
    flowParseType();

    if (!(0, _index.match)(_types.TokenType.greaterThan)) {
      (0, _util.expect)(_types.TokenType.comma);
    }
  }

  (0, _util.expect)(_types.TokenType.greaterThan);
  (0, _index.popTypeContext)(oldIsType);
}

function flowParseInterfaceType() {
  (0, _util.expectContextual)(_keywords.ContextualKeyword._interface);

  if ((0, _index.eat)(_types.TokenType._extends)) {
    do {
      flowParseInterfaceExtends();
    } while ((0, _index.eat)(_types.TokenType.comma));
  }

  flowParseObjectType(false, false, false);
}

function flowParseObjectPropertyKey() {
  if ((0, _index.match)(_types.TokenType.num) || (0, _index.match)(_types.TokenType.string)) {
    (0, _expression.parseExprAtom)();
  } else {
    (0, _expression.parseIdentifier)();
  }
}

function flowParseObjectTypeIndexer() {
  // Note: bracketL has already been consumed
  if ((0, _index.lookaheadType)() === _types.TokenType.colon) {
    flowParseObjectPropertyKey();
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }

  (0, _util.expect)(_types.TokenType.bracketR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeInternalSlot() {
  // Note: both bracketL have already been consumed
  flowParseObjectPropertyKey();
  (0, _util.expect)(_types.TokenType.bracketR);
  (0, _util.expect)(_types.TokenType.bracketR);

  if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.parenL)) {
    flowParseObjectTypeMethodish();
  } else {
    (0, _index.eat)(_types.TokenType.question);
    flowParseTypeInitialiser();
  }
}

function flowParseObjectTypeMethodish() {
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
  }

  (0, _util.expect)(_types.TokenType.parenL);

  while (!(0, _index.match)(_types.TokenType.parenR) && !(0, _index.match)(_types.TokenType.ellipsis) && !_base.state.error) {
    flowParseFunctionTypeParam();

    if (!(0, _index.match)(_types.TokenType.parenR)) {
      (0, _util.expect)(_types.TokenType.comma);
    }
  }

  if ((0, _index.eat)(_types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }

  (0, _util.expect)(_types.TokenType.parenR);
  flowParseTypeInitialiser();
}

function flowParseObjectTypeCallProperty() {
  flowParseObjectTypeMethodish();
}

function flowParseObjectType(allowStatic, allowExact, allowProto) {
  var endDelim;

  if (allowExact && (0, _index.match)(_types.TokenType.braceBarL)) {
    (0, _util.expect)(_types.TokenType.braceBarL);
    endDelim = _types.TokenType.braceBarR;
  } else {
    (0, _util.expect)(_types.TokenType.braceL);
    endDelim = _types.TokenType.braceR;
  }

  while (!(0, _index.match)(endDelim) && !_base.state.error) {
    if (allowProto && (0, _util.isContextual)(_keywords.ContextualKeyword._proto)) {
      var lookahead = (0, _index.lookaheadType)();

      if (lookahead !== _types.TokenType.colon && lookahead !== _types.TokenType.question) {
        (0, _index.next)();
        allowStatic = false;
      }
    }

    if (allowStatic && (0, _util.isContextual)(_keywords.ContextualKeyword._static)) {
      var _lookahead = (0, _index.lookaheadType)();

      if (_lookahead !== _types.TokenType.colon && _lookahead !== _types.TokenType.question) {
        (0, _index.next)();
      }
    }

    flowParseVariance();

    if ((0, _index.eat)(_types.TokenType.bracketL)) {
      if ((0, _index.eat)(_types.TokenType.bracketL)) {
        flowParseObjectTypeInternalSlot();
      } else {
        flowParseObjectTypeIndexer();
      }
    } else if ((0, _index.match)(_types.TokenType.parenL) || (0, _index.match)(_types.TokenType.lessThan)) {
      flowParseObjectTypeCallProperty();
    } else {
      if ((0, _util.isContextual)(_keywords.ContextualKeyword._get) || (0, _util.isContextual)(_keywords.ContextualKeyword._set)) {
        var _lookahead2 = (0, _index.lookaheadType)();

        if (_lookahead2 === _types.TokenType.name || _lookahead2 === _types.TokenType.string || _lookahead2 === _types.TokenType.num) {
          (0, _index.next)();
        }
      }

      flowParseObjectTypeProperty();
    }

    flowObjectTypeSemicolon();
  }

  (0, _util.expect)(endDelim);
}

function flowParseObjectTypeProperty() {
  if ((0, _index.match)(_types.TokenType.ellipsis)) {
    (0, _util.expect)(_types.TokenType.ellipsis);

    if (!(0, _index.eat)(_types.TokenType.comma)) {
      (0, _index.eat)(_types.TokenType.semi);
    } // Explicit inexact object syntax.


    if ((0, _index.match)(_types.TokenType.braceR)) {
      return;
    }

    flowParseType();
  } else {
    flowParseObjectPropertyKey();

    if ((0, _index.match)(_types.TokenType.lessThan) || (0, _index.match)(_types.TokenType.parenL)) {
      // This is a method property
      flowParseObjectTypeMethodish();
    } else {
      (0, _index.eat)(_types.TokenType.question);
      flowParseTypeInitialiser();
    }
  }
}

function flowObjectTypeSemicolon() {
  if (!(0, _index.eat)(_types.TokenType.semi) && !(0, _index.eat)(_types.TokenType.comma) && !(0, _index.match)(_types.TokenType.braceR) && !(0, _index.match)(_types.TokenType.braceBarR)) {
    (0, _util.unexpected)();
  }
}

function flowParseQualifiedTypeIdentifier(initialIdAlreadyParsed) {
  if (!initialIdAlreadyParsed) {
    (0, _expression.parseIdentifier)();
  }

  while ((0, _index.eat)(_types.TokenType.dot)) {
    (0, _expression.parseIdentifier)();
  }
}

function flowParseGenericType() {
  flowParseQualifiedTypeIdentifier(true);

  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }
}

function flowParseTypeofType() {
  (0, _util.expect)(_types.TokenType._typeof);
  flowParsePrimaryType();
}

function flowParseTupleType() {
  (0, _util.expect)(_types.TokenType.bracketL); // We allow trailing commas

  while (_base.state.pos < _base.input.length && !(0, _index.match)(_types.TokenType.bracketR)) {
    flowParseType();

    if ((0, _index.match)(_types.TokenType.bracketR)) {
      break;
    }

    (0, _util.expect)(_types.TokenType.comma);
  }

  (0, _util.expect)(_types.TokenType.bracketR);
}

function flowParseFunctionTypeParam() {
  var lookahead = (0, _index.lookaheadType)();

  if (lookahead === _types.TokenType.colon || lookahead === _types.TokenType.question) {
    (0, _expression.parseIdentifier)();
    (0, _index.eat)(_types.TokenType.question);
    flowParseTypeInitialiser();
  } else {
    flowParseType();
  }
}

function flowParseFunctionTypeParams() {
  while (!(0, _index.match)(_types.TokenType.parenR) && !(0, _index.match)(_types.TokenType.ellipsis) && !_base.state.error) {
    flowParseFunctionTypeParam();

    if (!(0, _index.match)(_types.TokenType.parenR)) {
      (0, _util.expect)(_types.TokenType.comma);
    }
  }

  if ((0, _index.eat)(_types.TokenType.ellipsis)) {
    flowParseFunctionTypeParam();
  }
} // The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.


function flowParsePrimaryType() {
  var isGroupedType = false;
  var oldNoAnonFunctionType = _base.state.noAnonFunctionType;

  switch (_base.state.type) {
    case _types.TokenType.name:
      {
        if ((0, _util.isContextual)(_keywords.ContextualKeyword._interface)) {
          flowParseInterfaceType();
          return;
        }

        (0, _expression.parseIdentifier)();
        flowParseGenericType();
        return;
      }

    case _types.TokenType.braceL:
      flowParseObjectType(false, false, false);
      return;

    case _types.TokenType.braceBarL:
      flowParseObjectType(false, true, false);
      return;

    case _types.TokenType.bracketL:
      flowParseTupleType();
      return;

    case _types.TokenType.lessThan:
      flowParseTypeParameterDeclaration();
      (0, _util.expect)(_types.TokenType.parenL);
      flowParseFunctionTypeParams();
      (0, _util.expect)(_types.TokenType.parenR);
      (0, _util.expect)(_types.TokenType.arrow);
      flowParseType();
      return;

    case _types.TokenType.parenL:
      (0, _index.next)(); // Check to see if this is actually a grouped type

      if (!(0, _index.match)(_types.TokenType.parenR) && !(0, _index.match)(_types.TokenType.ellipsis)) {
        if ((0, _index.match)(_types.TokenType.name)) {
          var token = (0, _index.lookaheadType)();
          isGroupedType = token !== _types.TokenType.question && token !== _types.TokenType.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        _base.state.noAnonFunctionType = false;
        flowParseType();
        _base.state.noAnonFunctionType = oldNoAnonFunctionType; // A `,` or a `) =>` means this is an anonymous function type

        if (_base.state.noAnonFunctionType || !((0, _index.match)(_types.TokenType.comma) || (0, _index.match)(_types.TokenType.parenR) && (0, _index.lookaheadType)() === _types.TokenType.arrow)) {
          (0, _util.expect)(_types.TokenType.parenR);
          return;
        } else {
          // Eat a comma if there is one
          (0, _index.eat)(_types.TokenType.comma);
        }
      }

      flowParseFunctionTypeParams();
      (0, _util.expect)(_types.TokenType.parenR);
      (0, _util.expect)(_types.TokenType.arrow);
      flowParseType();
      return;

    case _types.TokenType.minus:
      (0, _index.next)();
      (0, _expression.parseLiteral)();
      return;

    case _types.TokenType.string:
    case _types.TokenType.num:
    case _types.TokenType._true:
    case _types.TokenType._false:
    case _types.TokenType._null:
    case _types.TokenType._this:
    case _types.TokenType._void:
    case _types.TokenType.star:
      (0, _index.next)();
      return;

    default:
      if (_base.state.type === _types.TokenType._typeof) {
        flowParseTypeofType();
        return;
      } else if (_base.state.type & _types.TokenType.IS_KEYWORD) {
        (0, _index.next)();
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
        return;
      }

  }

  (0, _util.unexpected)();
}

function flowParsePostfixType() {
  flowParsePrimaryType();

  while (!(0, _util.canInsertSemicolon)() && ((0, _index.match)(_types.TokenType.bracketL) || (0, _index.match)(_types.TokenType.questionDot))) {
    (0, _index.eat)(_types.TokenType.questionDot);
    (0, _util.expect)(_types.TokenType.bracketL);

    if ((0, _index.eat)(_types.TokenType.bracketR)) {// Array type
    } else {
      // Indexed access type
      flowParseType();
      (0, _util.expect)(_types.TokenType.bracketR);
    }
  }
}

function flowParsePrefixType() {
  if ((0, _index.eat)(_types.TokenType.question)) {
    flowParsePrefixType();
  } else {
    flowParsePostfixType();
  }
}

function flowParseAnonFunctionWithoutParens() {
  flowParsePrefixType();

  if (!_base.state.noAnonFunctionType && (0, _index.eat)(_types.TokenType.arrow)) {
    flowParseType();
  }
}

function flowParseIntersectionType() {
  (0, _index.eat)(_types.TokenType.bitwiseAND);
  flowParseAnonFunctionWithoutParens();

  while ((0, _index.eat)(_types.TokenType.bitwiseAND)) {
    flowParseAnonFunctionWithoutParens();
  }
}

function flowParseUnionType() {
  (0, _index.eat)(_types.TokenType.bitwiseOR);
  flowParseIntersectionType();

  while ((0, _index.eat)(_types.TokenType.bitwiseOR)) {
    flowParseIntersectionType();
  }
}

function flowParseType() {
  flowParseUnionType();
}

function flowParseTypeAnnotation() {
  flowParseTypeInitialiser();
}

function flowParseTypeAnnotatableIdentifier() {
  (0, _expression.parseIdentifier)();

  if ((0, _index.match)(_types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
}

function flowParseVariance() {
  if ((0, _index.match)(_types.TokenType.plus) || (0, _index.match)(_types.TokenType.minus)) {
    (0, _index.next)();
    _base.state.tokens[_base.state.tokens.length - 1].isType = true;
  }
} // ==================================
// Overrides
// ==================================


function flowParseFunctionBodyAndFinish(funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if ((0, _index.match)(_types.TokenType.colon)) {
    flowParseTypeAndPredicateInitialiser();
  }

  (0, _expression.parseFunctionBody)(false, funcContextId);
}

function flowParseSubscript(startTokenIndex, noCalls, stopState) {
  if ((0, _index.match)(_types.TokenType.questionDot) && (0, _index.lookaheadType)() === _types.TokenType.lessThan) {
    if (noCalls) {
      stopState.stop = true;
      return;
    }

    (0, _index.next)();
    flowParseTypeParameterInstantiation();
    (0, _util.expect)(_types.TokenType.parenL);
    (0, _expression.parseCallExpressionArguments)();
    return;
  } else if (!noCalls && (0, _index.match)(_types.TokenType.lessThan)) {
    var snapshot = _base.state.snapshot();

    flowParseTypeParameterInstantiation();
    (0, _util.expect)(_types.TokenType.parenL);
    (0, _expression.parseCallExpressionArguments)();

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  }

  (0, _expression.baseParseSubscript)(startTokenIndex, noCalls, stopState);
}

function flowStartParseNewArguments() {
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    var snapshot = _base.state.snapshot();

    flowParseTypeParameterInstantiation();

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
  }
} // interfaces


function flowTryParseStatement() {
  if ((0, _index.match)(_types.TokenType.name) && _base.state.contextualKeyword === _keywords.ContextualKeyword._interface) {
    var oldIsType = (0, _index.pushTypeContext)(0);
    (0, _index.next)();
    flowParseInterface();
    (0, _index.popTypeContext)(oldIsType);
    return true;
  } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }

  return false;
}

function flowTryParseExportDefaultExpression() {
  if ((0, _util.isContextual)(_keywords.ContextualKeyword._enum)) {
    flowParseEnumDeclaration();
    return true;
  }

  return false;
} // declares, interfaces and type aliases


function flowParseIdentifierStatement(contextualKeyword) {
  if (contextualKeyword === _keywords.ContextualKeyword._declare) {
    if ((0, _index.match)(_types.TokenType._class) || (0, _index.match)(_types.TokenType.name) || (0, _index.match)(_types.TokenType._function) || (0, _index.match)(_types.TokenType._var) || (0, _index.match)(_types.TokenType._export)) {
      var oldIsType = (0, _index.pushTypeContext)(1);
      flowParseDeclare();
      (0, _index.popTypeContext)(oldIsType);
    }
  } else if ((0, _index.match)(_types.TokenType.name)) {
    if (contextualKeyword === _keywords.ContextualKeyword._interface) {
      var _oldIsType = (0, _index.pushTypeContext)(1);

      flowParseInterface();
      (0, _index.popTypeContext)(_oldIsType);
    } else if (contextualKeyword === _keywords.ContextualKeyword._type) {
      var _oldIsType2 = (0, _index.pushTypeContext)(1);

      flowParseTypeAlias();
      (0, _index.popTypeContext)(_oldIsType2);
    } else if (contextualKeyword === _keywords.ContextualKeyword._opaque) {
      var _oldIsType3 = (0, _index.pushTypeContext)(1);

      flowParseOpaqueType(false);
      (0, _index.popTypeContext)(_oldIsType3);
    }
  }

  (0, _util.semicolon)();
} // export type


function flowShouldParseExportDeclaration() {
  return (0, _util.isContextual)(_keywords.ContextualKeyword._type) || (0, _util.isContextual)(_keywords.ContextualKeyword._interface) || (0, _util.isContextual)(_keywords.ContextualKeyword._opaque) || (0, _util.isContextual)(_keywords.ContextualKeyword._enum);
}

function flowShouldDisallowExportDefaultSpecifier() {
  return (0, _index.match)(_types.TokenType.name) && (_base.state.contextualKeyword === _keywords.ContextualKeyword._type || _base.state.contextualKeyword === _keywords.ContextualKeyword._interface || _base.state.contextualKeyword === _keywords.ContextualKeyword._opaque || _base.state.contextualKeyword === _keywords.ContextualKeyword._enum);
}

function flowParseExportDeclaration() {
  if ((0, _util.isContextual)(_keywords.ContextualKeyword._type)) {
    var oldIsType = (0, _index.pushTypeContext)(1);
    (0, _index.next)();

    if ((0, _index.match)(_types.TokenType.braceL)) {
      // export type { foo, bar };
      (0, _statement.parseExportSpecifiers)();
      (0, _statement.parseExportFrom)();
    } else {
      // export type Foo = Bar;
      flowParseTypeAlias();
    }

    (0, _index.popTypeContext)(oldIsType);
  } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._opaque)) {
    var _oldIsType4 = (0, _index.pushTypeContext)(1);

    (0, _index.next)(); // export opaque type Foo = Bar;

    flowParseOpaqueType(false);
    (0, _index.popTypeContext)(_oldIsType4);
  } else if ((0, _util.isContextual)(_keywords.ContextualKeyword._interface)) {
    var _oldIsType5 = (0, _index.pushTypeContext)(1);

    (0, _index.next)();
    flowParseInterface();
    (0, _index.popTypeContext)(_oldIsType5);
  } else {
    (0, _statement.parseStatement)(true);
  }
}

function flowShouldParseExportStar() {
  return (0, _index.match)(_types.TokenType.star) || (0, _util.isContextual)(_keywords.ContextualKeyword._type) && (0, _index.lookaheadType)() === _types.TokenType.star;
}

function flowParseExportStar() {
  if ((0, _util.eatContextual)(_keywords.ContextualKeyword._type)) {
    var oldIsType = (0, _index.pushTypeContext)(2);
    (0, _statement.baseParseExportStar)();
    (0, _index.popTypeContext)(oldIsType);
  } else {
    (0, _statement.baseParseExportStar)();
  }
} // parse a the super class type parameters and implements


function flowAfterParseClassSuper(hasSuper) {
  if (hasSuper && (0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterInstantiation();
  }

  if ((0, _util.isContextual)(_keywords.ContextualKeyword._implements)) {
    var oldIsType = (0, _index.pushTypeContext)(0);
    (0, _index.next)();
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;

    do {
      flowParseRestrictedIdentifier();

      if ((0, _index.match)(_types.TokenType.lessThan)) {
        flowParseTypeParameterInstantiation();
      }
    } while ((0, _index.eat)(_types.TokenType.comma));

    (0, _index.popTypeContext)(oldIsType);
  }
} // parse type parameters for object method shorthand


function flowStartParseObjPropValue() {
  // method shorthand
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    flowParseTypeParameterDeclaration();
    if (!(0, _index.match)(_types.TokenType.parenL)) (0, _util.unexpected)();
  }
}

function flowParseAssignableListItemTypes() {
  var oldIsType = (0, _index.pushTypeContext)(0);
  (0, _index.eat)(_types.TokenType.question);

  if ((0, _index.match)(_types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }

  (0, _index.popTypeContext)(oldIsType);
} // parse typeof and type imports


function flowStartParseImportSpecifiers() {
  if ((0, _index.match)(_types.TokenType._typeof) || (0, _util.isContextual)(_keywords.ContextualKeyword._type)) {
    var lh = (0, _index.lookaheadTypeAndKeyword)();

    if (isMaybeDefaultImport(lh) || lh.type === _types.TokenType.braceL || lh.type === _types.TokenType.star) {
      (0, _index.next)();
    }
  }
} // parse import-type/typeof shorthand


function flowParseImportSpecifier() {
  var isTypeKeyword = _base.state.contextualKeyword === _keywords.ContextualKeyword._type || _base.state.type === _types.TokenType._typeof;

  if (isTypeKeyword) {
    (0, _index.next)();
  } else {
    (0, _expression.parseIdentifier)();
  }

  if ((0, _util.isContextual)(_keywords.ContextualKeyword._as) && !(0, _util.isLookaheadContextual)(_keywords.ContextualKeyword._as)) {
    (0, _expression.parseIdentifier)();

    if (isTypeKeyword && !(0, _index.match)(_types.TokenType.name) && !(_base.state.type & _types.TokenType.IS_KEYWORD)) {// `import {type as ,` or `import {type as }`
    } else {
      // `import {type as foo`
      (0, _expression.parseIdentifier)();
    }
  } else {
    if (isTypeKeyword && ((0, _index.match)(_types.TokenType.name) || !!(_base.state.type & _types.TokenType.IS_KEYWORD))) {
      // `import {type foo`
      (0, _expression.parseIdentifier)();
    }

    if ((0, _util.eatContextual)(_keywords.ContextualKeyword._as)) {
      (0, _expression.parseIdentifier)();
    }
  }
} // parse function type parameters - function foo<T>() {}


function flowStartParseFunctionParams() {
  // Originally this checked if the method is a getter/setter, but if it was, we'd crash soon
  // anyway, so don't try to propagate that information.
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    var oldIsType = (0, _index.pushTypeContext)(0);
    flowParseTypeParameterDeclaration();
    (0, _index.popTypeContext)(oldIsType);
  }
} // parse flow type annotations on variable declarator heads - let foo: string = bar


function flowAfterParseVarHead() {
  if ((0, _index.match)(_types.TokenType.colon)) {
    flowParseTypeAnnotation();
  }
} // parse the return type of an async arrow function - let foo = (async (): number => {});


function flowStartParseAsyncArrowFromCallExpression() {
  if ((0, _index.match)(_types.TokenType.colon)) {
    var oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    _base.state.noAnonFunctionType = true;
    flowParseTypeAnnotation();
    _base.state.noAnonFunctionType = oldNoAnonFunctionType;
  }
} // We need to support type parameter declarations for arrow functions. This
// is tricky. There are three situations we need to handle
//
// 1. This is either JSX or an arrow function. We'll try JSX first. If that
//    fails, we'll try an arrow function. If that fails, we'll throw the JSX
//    error.
// 2. This is an arrow function. We'll parse the type parameter declaration,
//    parse the rest, make sure the rest is an arrow function, and go from
//    there
// 3. This is neither. Just call the super method


function flowParseMaybeAssign(noIn, isWithinParens) {
  if ((0, _index.match)(_types.TokenType.lessThan)) {
    var snapshot = _base.state.snapshot();

    var wasArrow = (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);

      _base.state.type = _types.TokenType.typeParameterStart;
    } else {
      return wasArrow;
    }

    var oldIsType = (0, _index.pushTypeContext)(0);
    flowParseTypeParameterDeclaration();
    (0, _index.popTypeContext)(oldIsType);
    wasArrow = (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);

    if (wasArrow) {
      return true;
    }

    (0, _util.unexpected)();
  }

  return (0, _expression.baseParseMaybeAssign)(noIn, isWithinParens);
} // handle return types for arrow functions


function flowParseArrow() {
  if ((0, _index.match)(_types.TokenType.colon)) {
    var oldIsType = (0, _index.pushTypeContext)(0);

    var snapshot = _base.state.snapshot();

    var oldNoAnonFunctionType = _base.state.noAnonFunctionType;
    _base.state.noAnonFunctionType = true;
    flowParseTypeAndPredicateInitialiser();
    _base.state.noAnonFunctionType = oldNoAnonFunctionType;
    if ((0, _util.canInsertSemicolon)()) (0, _util.unexpected)();
    if (!(0, _index.match)(_types.TokenType.arrow)) (0, _util.unexpected)();

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }

    (0, _index.popTypeContext)(oldIsType);
  }

  return (0, _index.eat)(_types.TokenType.arrow);
}

function flowParseSubscripts(startTokenIndex) {
  var noCalls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (_base.state.tokens[_base.state.tokens.length - 1].contextualKeyword === _keywords.ContextualKeyword._async && (0, _index.match)(_types.TokenType.lessThan)) {
    var snapshot = _base.state.snapshot();

    var wasArrow = parseAsyncArrowWithTypeParameters();

    if (wasArrow && !_base.state.error) {
      return;
    }

    _base.state.restoreFromSnapshot(snapshot);
  }

  (0, _expression.baseParseSubscripts)(startTokenIndex, noCalls);
} // Returns true if there was an arrow function here.


function parseAsyncArrowWithTypeParameters() {
  _base.state.scopeDepth++;
  var startTokenIndex = _base.state.tokens.length;
  (0, _statement.parseFunctionParams)();

  if (!(0, _expression.parseArrow)()) {
    return false;
  }

  (0, _expression.parseArrowExpression)(startTokenIndex);
  return true;
}

function flowParseEnumDeclaration() {
  (0, _util.expectContextual)(_keywords.ContextualKeyword._enum);
  _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
  (0, _expression.parseIdentifier)();
  flowParseEnumBody();
}

function flowParseEnumBody() {
  if ((0, _util.eatContextual)(_keywords.ContextualKeyword._of)) {
    (0, _index.next)();
  }

  (0, _util.expect)(_types.TokenType.braceL);
  flowParseEnumMembers();
  (0, _util.expect)(_types.TokenType.braceR);
}

function flowParseEnumMembers() {
  while (!(0, _index.match)(_types.TokenType.braceR) && !_base.state.error) {
    if ((0, _index.eat)(_types.TokenType.ellipsis)) {
      break;
    }

    flowParseEnumMember();

    if (!(0, _index.match)(_types.TokenType.braceR)) {
      (0, _util.expect)(_types.TokenType.comma);
    }
  }
}

function flowParseEnumMember() {
  (0, _expression.parseIdentifier)();

  if ((0, _index.eat)(_types.TokenType.eq)) {
    // Flow enum values are always just one token (a string, number, or boolean literal).
    (0, _index.next)();
  }
}