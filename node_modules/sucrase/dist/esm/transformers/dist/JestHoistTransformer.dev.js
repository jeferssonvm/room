"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _types = require("../parser/tokenizer/types");

var _Transformer2 = _interopRequireDefault(require("./Transformer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _optionalChain(ops) {
  var lastAccessLHS = undefined;
  var value = ops[0];
  var i = 1;

  while (i < ops.length) {
    var op = ops[i];
    var fn = ops[i + 1];
    i += 2;

    if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) {
      return undefined;
    }

    if (op === 'access' || op === 'optionalAccess') {
      lastAccessLHS = value;
      value = fn(value);
    } else if (op === 'call' || op === 'optionalCall') {
      value = fn(function () {
        var _value;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return (_value = value).call.apply(_value, [lastAccessLHS].concat(args));
      });
      lastAccessLHS = undefined;
    }
  }

  return value;
}

var JEST_GLOBAL_NAME = "jest";
var HOISTED_METHODS = ["mock", "unmock", "enableAutomock", "disableAutomock"];
/**
 * Implementation of babel-plugin-jest-hoist, which hoists up some jest method
 * calls above the imports to allow them to override other imports.
 *
 * To preserve line numbers, rather than directly moving the jest.mock code, we
 * wrap each invocation in a function statement and then call the function from
 * the top of the file.
 */

var JestHoistTransformer =
/*#__PURE__*/
function (_Transformer) {
  _inherits(JestHoistTransformer, _Transformer);

  _createClass(JestHoistTransformer, [{
    key: "__init",
    value: function __init() {
      this.hoistedFunctionNames = [];
    }
  }]);

  function JestHoistTransformer(rootTransformer, tokens, nameManager, importProcessor) {
    var _this;

    _classCallCheck(this, JestHoistTransformer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(JestHoistTransformer).call(this));
    _this.rootTransformer = rootTransformer;
    _this.tokens = tokens;
    _this.nameManager = nameManager;
    _this.importProcessor = importProcessor;

    JestHoistTransformer.prototype.__init.call(_assertThisInitialized(_this));

    ;
    return _this;
  }

  _createClass(JestHoistTransformer, [{
    key: "process",
    value: function process() {
      if (this.tokens.currentToken().scopeDepth === 0 && this.tokens.matches4(_types.TokenType.name, _types.TokenType.dot, _types.TokenType.name, _types.TokenType.parenL) && this.tokens.identifierName() === JEST_GLOBAL_NAME) {
        // TODO: This only works if imports transform is active, which it will be for jest.
        //       But if jest adds module support and we no longer need the import transform, this needs fixing.
        if (_optionalChain([this, 'access', function (_) {
          return _.importProcessor;
        }, 'optionalAccess', function (_2) {
          return _2.getGlobalNames;
        }, 'call', function (_3) {
          return _3();
        }, 'optionalAccess', function (_4) {
          return _4.has;
        }, 'call', function (_5) {
          return _5(JEST_GLOBAL_NAME);
        }])) {
          return false;
        }

        return this.extractHoistedCalls();
      }

      return false;
    }
  }, {
    key: "getHoistedCode",
    value: function getHoistedCode() {
      if (this.hoistedFunctionNames.length > 0) {
        // This will be placed before module interop code, but that's fine since
        // imports aren't allowed in module mock factories.
        return this.hoistedFunctionNames.map(function (name) {
          return "".concat(name, "();");
        }).join("");
      }

      return "";
    }
    /**
     * Extracts any methods calls on the jest-object that should be hoisted.
     *
     * According to the jest docs, https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options,
     * mock, unmock, enableAutomock, disableAutomock, are the methods that should be hoisted.
     *
     * We do not apply the same checks of the arguments as babel-plugin-jest-hoist does.
     */

  }, {
    key: "extractHoistedCalls",
    value: function extractHoistedCalls() {
      // We're handling a chain of calls where `jest` may or may not need to be inserted for each call
      // in the chain, so remove the initial `jest` to make the loop implementation cleaner.
      this.tokens.removeToken(); // Track some state so that multiple non-hoisted chained calls in a row keep their chaining
      // syntax.

      var followsNonHoistedJestCall = false; // Iterate through all chained calls on the jest object.

      while (this.tokens.matches3(_types.TokenType.dot, _types.TokenType.name, _types.TokenType.parenL)) {
        var methodName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
        var shouldHoist = HOISTED_METHODS.includes(methodName);

        if (shouldHoist) {
          // We've matched e.g. `.mock(...)` or similar call.
          // Replace the initial `.` with `function __jestHoist(){jest.`
          var hoistedFunctionName = this.nameManager.claimFreeName("__jestHoist");
          this.hoistedFunctionNames.push(hoistedFunctionName);
          this.tokens.replaceToken("function ".concat(hoistedFunctionName, "(){").concat(JEST_GLOBAL_NAME, "."));
          this.tokens.copyToken();
          this.tokens.copyToken();
          this.rootTransformer.processBalancedCode();
          this.tokens.copyExpectedToken(_types.TokenType.parenR);
          this.tokens.appendCode(";}");
          followsNonHoistedJestCall = false;
        } else {
          // This is a non-hoisted method, so just transform the code as usual.
          if (followsNonHoistedJestCall) {
            // If we didn't hoist the previous call, we can leave the code as-is to chain off of the
            // previous method call. It's important to preserve the code here because we don't know
            // for sure that the method actually returned the jest object for chaining.
            this.tokens.copyToken();
          } else {
            // If we hoisted the previous call, we know it returns the jest object back, so we insert
            // the identifier `jest` to continue the chain.
            this.tokens.replaceToken("".concat(JEST_GLOBAL_NAME, "."));
          }

          this.tokens.copyToken();
          this.tokens.copyToken();
          this.rootTransformer.processBalancedCode();
          this.tokens.copyExpectedToken(_types.TokenType.parenR);
          followsNonHoistedJestCall = true;
        }
      }

      return true;
    }
  }]);

  return JestHoistTransformer;
}(_Transformer2["default"]);

exports["default"] = JestHoistTransformer;