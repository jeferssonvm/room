"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _keywords = require("../parser/tokenizer/keywords");

var _types = require("../parser/tokenizer/types");

var _getClassInfo = _interopRequireDefault(require("../util/getClassInfo"));

var _CJSImportTransformer = _interopRequireDefault(require("./CJSImportTransformer"));

var _ESMImportTransformer = _interopRequireDefault(require("./ESMImportTransformer"));

var _FlowTransformer = _interopRequireDefault(require("./FlowTransformer"));

var _JestHoistTransformer = _interopRequireDefault(require("./JestHoistTransformer"));

var _JSXTransformer = _interopRequireDefault(require("./JSXTransformer"));

var _NumericSeparatorTransformer = _interopRequireDefault(require("./NumericSeparatorTransformer"));

var _OptionalCatchBindingTransformer = _interopRequireDefault(require("./OptionalCatchBindingTransformer"));

var _OptionalChainingNullishTransformer = _interopRequireDefault(require("./OptionalChainingNullishTransformer"));

var _ReactDisplayNameTransformer = _interopRequireDefault(require("./ReactDisplayNameTransformer"));

var _ReactHotLoaderTransformer = _interopRequireDefault(require("./ReactHotLoaderTransformer"));

var _TypeScriptTransformer = _interopRequireDefault(require("./TypeScriptTransformer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var RootTransformer =
/*#__PURE__*/
function () {
  _createClass(RootTransformer, [{
    key: "__init",
    value: function __init() {
      this.transformers = [];
    }
  }, {
    key: "__init2",
    value: function __init2() {
      this.generatedVariables = [];
    }
  }]);

  function RootTransformer(sucraseContext, transforms, enableLegacyBabel5ModuleInterop, options) {
    _classCallCheck(this, RootTransformer);

    ;

    RootTransformer.prototype.__init.call(this);

    RootTransformer.prototype.__init2.call(this);

    this.nameManager = sucraseContext.nameManager;
    this.helperManager = sucraseContext.helperManager;
    var tokenProcessor = sucraseContext.tokenProcessor,
        importProcessor = sucraseContext.importProcessor;
    this.tokens = tokenProcessor;
    this.isImportsTransformEnabled = transforms.includes("imports");
    this.isReactHotLoaderTransformEnabled = transforms.includes("react-hot-loader");
    this.disableESTransforms = Boolean(options.disableESTransforms);

    if (!options.disableESTransforms) {
      this.transformers.push(new _OptionalChainingNullishTransformer["default"](tokenProcessor, this.nameManager));
      this.transformers.push(new _NumericSeparatorTransformer["default"](tokenProcessor));
      this.transformers.push(new _OptionalCatchBindingTransformer["default"](tokenProcessor, this.nameManager));
    }

    if (transforms.includes("jsx")) {
      if (options.jsxRuntime !== "preserve") {
        this.transformers.push(new _JSXTransformer["default"](this, tokenProcessor, importProcessor, this.nameManager, options));
      }

      this.transformers.push(new _ReactDisplayNameTransformer["default"](this, tokenProcessor, importProcessor, options));
    }

    var reactHotLoaderTransformer = null;

    if (transforms.includes("react-hot-loader")) {
      if (!options.filePath) {
        throw new Error("filePath is required when using the react-hot-loader transform.");
      }

      reactHotLoaderTransformer = new _ReactHotLoaderTransformer["default"](tokenProcessor, options.filePath);
      this.transformers.push(reactHotLoaderTransformer);
    } // Note that we always want to enable the imports transformer, even when the import transform
    // itself isn't enabled, since we need to do type-only import pruning for both Flow and
    // TypeScript.


    if (transforms.includes("imports")) {
      if (importProcessor === null) {
        throw new Error("Expected non-null importProcessor with imports transform enabled.");
      }

      this.transformers.push(new _CJSImportTransformer["default"](this, tokenProcessor, importProcessor, this.nameManager, this.helperManager, reactHotLoaderTransformer, enableLegacyBabel5ModuleInterop, Boolean(options.enableLegacyTypeScriptModuleInterop), transforms.includes("typescript"), transforms.includes("flow"), Boolean(options.preserveDynamicImport), Boolean(options.keepUnusedImports)));
    } else {
      this.transformers.push(new _ESMImportTransformer["default"](tokenProcessor, this.nameManager, this.helperManager, reactHotLoaderTransformer, transforms.includes("typescript"), transforms.includes("flow"), Boolean(options.keepUnusedImports), options));
    }

    if (transforms.includes("flow")) {
      this.transformers.push(new _FlowTransformer["default"](this, tokenProcessor, transforms.includes("imports")));
    }

    if (transforms.includes("typescript")) {
      this.transformers.push(new _TypeScriptTransformer["default"](this, tokenProcessor, transforms.includes("imports")));
    }

    if (transforms.includes("jest")) {
      this.transformers.push(new _JestHoistTransformer["default"](this, tokenProcessor, this.nameManager, importProcessor));
    }
  }

  _createClass(RootTransformer, [{
    key: "transform",
    value: function transform() {
      this.tokens.reset();
      this.processBalancedCode();
      var shouldAddUseStrict = this.isImportsTransformEnabled; // "use strict" always needs to be first, so override the normal transformer order.

      var prefix = shouldAddUseStrict ? '"use strict";' : "";
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.transformers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var transformer = _step.value;
          prefix += transformer.getPrefixCode();
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      prefix += this.helperManager.emitHelpers();
      prefix += this.generatedVariables.map(function (v) {
        return " var ".concat(v, ";");
      }).join("");
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.transformers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _transformer = _step2.value;
          prefix += _transformer.getHoistedCode();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var suffix = "";
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = this.transformers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _transformer2 = _step3.value;
          suffix += _transformer2.getSuffixCode();
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      var result = this.tokens.finish();
      var code = result.code;

      if (code.startsWith("#!")) {
        var newlineIndex = code.indexOf("\n");

        if (newlineIndex === -1) {
          newlineIndex = code.length;
          code += "\n";
        }

        return {
          code: code.slice(0, newlineIndex + 1) + prefix + code.slice(newlineIndex + 1) + suffix,
          // The hashbang line has no tokens, so shifting the tokens to account
          // for prefix can happen normally.
          mappings: this.shiftMappings(result.mappings, prefix.length)
        };
      } else {
        return {
          code: prefix + code + suffix,
          mappings: this.shiftMappings(result.mappings, prefix.length)
        };
      }
    }
  }, {
    key: "processBalancedCode",
    value: function processBalancedCode() {
      var braceDepth = 0;
      var parenDepth = 0;

      while (!this.tokens.isAtEnd()) {
        if (this.tokens.matches1(_types.TokenType.braceL) || this.tokens.matches1(_types.TokenType.dollarBraceL)) {
          braceDepth++;
        } else if (this.tokens.matches1(_types.TokenType.braceR)) {
          if (braceDepth === 0) {
            return;
          }

          braceDepth--;
        }

        if (this.tokens.matches1(_types.TokenType.parenL)) {
          parenDepth++;
        } else if (this.tokens.matches1(_types.TokenType.parenR)) {
          if (parenDepth === 0) {
            return;
          }

          parenDepth--;
        }

        this.processToken();
      }
    }
  }, {
    key: "processToken",
    value: function processToken() {
      if (this.tokens.matches1(_types.TokenType._class)) {
        this.processClass();
        return;
      }

      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this.transformers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var transformer = _step4.value;
          var wasProcessed = transformer.process();

          if (wasProcessed) {
            return;
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this.tokens.copyToken();
    }
    /**
     * Skip past a class with a name and return that name.
     */

  }, {
    key: "processNamedClass",
    value: function processNamedClass() {
      if (!this.tokens.matches2(_types.TokenType._class, _types.TokenType.name)) {
        throw new Error("Expected identifier for exported class name.");
      }

      var name = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
      this.processClass();
      return name;
    }
  }, {
    key: "processClass",
    value: function processClass() {
      var classInfo = (0, _getClassInfo["default"])(this, this.tokens, this.nameManager, this.disableESTransforms); // Both static and instance initializers need a class name to use to invoke the initializer, so
      // assign to one if necessary.

      var needsCommaExpression = (classInfo.headerInfo.isExpression || !classInfo.headerInfo.className) && classInfo.staticInitializerNames.length + classInfo.instanceInitializerNames.length > 0;
      var className = classInfo.headerInfo.className;

      if (needsCommaExpression) {
        className = this.nameManager.claimFreeName("_class");
        this.generatedVariables.push(className);
        this.tokens.appendCode(" (".concat(className, " ="));
      }

      var classToken = this.tokens.currentToken();
      var contextId = classToken.contextId;

      if (contextId == null) {
        throw new Error("Expected class to have a context ID.");
      }

      this.tokens.copyExpectedToken(_types.TokenType._class);

      while (!this.tokens.matchesContextIdAndLabel(_types.TokenType.braceL, contextId)) {
        this.processToken();
      }

      this.processClassBody(classInfo, className);
      var staticInitializerStatements = classInfo.staticInitializerNames.map(function (name) {
        return "".concat(className, ".").concat(name, "()");
      });

      if (needsCommaExpression) {
        this.tokens.appendCode(", ".concat(staticInitializerStatements.map(function (s) {
          return "".concat(s, ", ");
        }).join("")).concat(className, ")"));
      } else if (classInfo.staticInitializerNames.length > 0) {
        this.tokens.appendCode(" ".concat(staticInitializerStatements.map(function (s) {
          return "".concat(s, ";");
        }).join(" ")));
      }
    }
    /**
     * We want to just handle class fields in all contexts, since TypeScript supports them. Later,
     * when some JS implementations support class fields, this should be made optional.
     */

  }, {
    key: "processClassBody",
    value: function processClassBody(classInfo, className) {
      var headerInfo = classInfo.headerInfo,
          constructorInsertPos = classInfo.constructorInsertPos,
          constructorInitializerStatements = classInfo.constructorInitializerStatements,
          fields = classInfo.fields,
          instanceInitializerNames = classInfo.instanceInitializerNames,
          rangesToRemove = classInfo.rangesToRemove;
      var fieldIndex = 0;
      var rangeToRemoveIndex = 0;
      var classContextId = this.tokens.currentToken().contextId;

      if (classContextId == null) {
        throw new Error("Expected non-null context ID on class.");
      }

      this.tokens.copyExpectedToken(_types.TokenType.braceL);

      if (this.isReactHotLoaderTransformEnabled) {
        this.tokens.appendCode("__reactstandin__regenerateByEval(key, code) {this[key] = eval(code);}");
      }

      var needsConstructorInit = constructorInitializerStatements.length + instanceInitializerNames.length > 0;

      if (constructorInsertPos === null && needsConstructorInit) {
        var constructorInitializersCode = this.makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className);

        if (headerInfo.hasSuperclass) {
          var argsName = this.nameManager.claimFreeName("args");
          this.tokens.appendCode("constructor(...".concat(argsName, ") { super(...").concat(argsName, "); ").concat(constructorInitializersCode, "; }"));
        } else {
          this.tokens.appendCode("constructor() { ".concat(constructorInitializersCode, "; }"));
        }
      }

      while (!this.tokens.matchesContextIdAndLabel(_types.TokenType.braceR, classContextId)) {
        if (fieldIndex < fields.length && this.tokens.currentIndex() === fields[fieldIndex].start) {
          var needsCloseBrace = false;

          if (this.tokens.matches1(_types.TokenType.bracketL)) {
            this.tokens.copyTokenWithPrefix("".concat(fields[fieldIndex].initializerName, "() {this"));
          } else if (this.tokens.matches1(_types.TokenType.string) || this.tokens.matches1(_types.TokenType.num)) {
            this.tokens.copyTokenWithPrefix("".concat(fields[fieldIndex].initializerName, "() {this["));
            needsCloseBrace = true;
          } else {
            this.tokens.copyTokenWithPrefix("".concat(fields[fieldIndex].initializerName, "() {this."));
          }

          while (this.tokens.currentIndex() < fields[fieldIndex].end) {
            if (needsCloseBrace && this.tokens.currentIndex() === fields[fieldIndex].equalsIndex) {
              this.tokens.appendCode("]");
            }

            this.processToken();
          }

          this.tokens.appendCode("}");
          fieldIndex++;
        } else if (rangeToRemoveIndex < rangesToRemove.length && this.tokens.currentIndex() >= rangesToRemove[rangeToRemoveIndex].start) {
          if (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
            this.tokens.removeInitialToken();
          }

          while (this.tokens.currentIndex() < rangesToRemove[rangeToRemoveIndex].end) {
            this.tokens.removeToken();
          }

          rangeToRemoveIndex++;
        } else if (this.tokens.currentIndex() === constructorInsertPos) {
          this.tokens.copyToken();

          if (needsConstructorInit) {
            this.tokens.appendCode(";".concat(this.makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className), ";"));
          }

          this.processToken();
        } else {
          this.processToken();
        }
      }

      this.tokens.copyExpectedToken(_types.TokenType.braceR);
    }
  }, {
    key: "makeConstructorInitCode",
    value: function makeConstructorInitCode(constructorInitializerStatements, instanceInitializerNames, className) {
      return [].concat(_toConsumableArray(constructorInitializerStatements), _toConsumableArray(instanceInitializerNames.map(function (name) {
        return "".concat(className, ".prototype.").concat(name, ".call(this)");
      }))).join(";");
    }
    /**
     * Normally it's ok to simply remove type tokens, but we need to be more careful when dealing with
     * arrow function return types since they can confuse the parser. In that case, we want to move
     * the close-paren to the same line as the arrow.
     *
     * See https://github.com/alangpierce/sucrase/issues/391 for more details.
     */

  }, {
    key: "processPossibleArrowParamEnd",
    value: function processPossibleArrowParamEnd() {
      if (this.tokens.matches2(_types.TokenType.parenR, _types.TokenType.colon) && this.tokens.tokenAtRelativeIndex(1).isType) {
        var nextNonTypeIndex = this.tokens.currentIndex() + 1; // Look ahead to see if this is an arrow function or something else.

        while (this.tokens.tokens[nextNonTypeIndex].isType) {
          nextNonTypeIndex++;
        }

        if (this.tokens.matches1AtIndex(nextNonTypeIndex, _types.TokenType.arrow)) {
          this.tokens.removeInitialToken();

          while (this.tokens.currentIndex() < nextNonTypeIndex) {
            this.tokens.removeToken();
          }

          this.tokens.replaceTokenTrimmingLeftWhitespace(") =>");
          return true;
        }
      }

      return false;
    }
    /**
     * An async arrow function might be of the form:
     *
     * async <
     *   T
     * >() => {}
     *
     * in which case, removing the type parameters will cause a syntax error. Detect this case and
     * move the open-paren earlier.
     */

  }, {
    key: "processPossibleAsyncArrowWithTypeParams",
    value: function processPossibleAsyncArrowWithTypeParams() {
      if (!this.tokens.matchesContextual(_keywords.ContextualKeyword._async) && !this.tokens.matches1(_types.TokenType._async)) {
        return false;
      }

      var nextToken = this.tokens.tokenAtRelativeIndex(1);

      if (nextToken.type !== _types.TokenType.lessThan || !nextToken.isType) {
        return false;
      }

      var nextNonTypeIndex = this.tokens.currentIndex() + 1; // Look ahead to see if this is an arrow function or something else.

      while (this.tokens.tokens[nextNonTypeIndex].isType) {
        nextNonTypeIndex++;
      }

      if (this.tokens.matches1AtIndex(nextNonTypeIndex, _types.TokenType.parenL)) {
        this.tokens.replaceToken("async (");
        this.tokens.removeInitialToken();

        while (this.tokens.currentIndex() < nextNonTypeIndex) {
          this.tokens.removeToken();
        }

        this.tokens.removeToken(); // We ate a ( token, so we need to process the tokens in between and then the ) token so that
        // we remain balanced.

        this.processBalancedCode();
        this.processToken();
        return true;
      }

      return false;
    }
  }, {
    key: "processPossibleTypeRange",
    value: function processPossibleTypeRange() {
      if (this.tokens.currentToken().isType) {
        this.tokens.removeInitialToken();

        while (this.tokens.currentToken().isType) {
          this.tokens.removeToken();
        }

        return true;
      }

      return false;
    }
  }, {
    key: "shiftMappings",
    value: function shiftMappings(mappings, prefixLength) {
      for (var i = 0; i < mappings.length; i++) {
        var mapping = mappings[i];

        if (mapping !== undefined) {
          mappings[i] = mapping + prefixLength;
        }
      }

      return mappings;
    }
  }]);

  return RootTransformer;
}();

exports["default"] = RootTransformer;