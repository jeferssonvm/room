"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = formatTokens;

var _linesAndColumns = _interopRequireDefault(require("lines-and-columns"));

var _types = require("../parser/tokenizer/types");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function formatTokens(code, tokens) {
  if (tokens.length === 0) {
    return "";
  }

  var tokenKeys = Object.keys(tokens[0]).filter(function (k) {
    return k !== "type" && k !== "value" && k !== "start" && k !== "end" && k !== "loc";
  });
  var typeKeys = Object.keys(tokens[0].type).filter(function (k) {
    return k !== "label" && k !== "keyword";
  });
  var headings = ["Location", "Label", "Raw"].concat(_toConsumableArray(tokenKeys), _toConsumableArray(typeKeys));
  var lines = new _linesAndColumns["default"](code);
  var rows = [headings].concat(_toConsumableArray(tokens.map(getTokenComponents)));
  var padding = headings.map(function () {
    return 0;
  });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = rows[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var components = _step.value;

      for (var i = 0; i < components.length; i++) {
        padding[i] = Math.max(padding[i], components[i].length);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return rows.map(function (components) {
    return components.map(function (component, i) {
      return component.padEnd(padding[i]);
    }).join(" ");
  }).join("\n");

  function getTokenComponents(token) {
    var raw = code.slice(token.start, token.end);
    return [formatRange(token.start, token.end), (0, _types.formatTokenType)(token.type), truncate(String(raw), 14)].concat(_toConsumableArray(tokenKeys.map(function (key) {
      return formatValue(token[key], key);
    })), _toConsumableArray(typeKeys.map(function (key) {
      return formatValue(token.type[key], key);
    })));
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  function formatValue(value, key) {
    if (value === true) {
      return key;
    } else if (value === false || value === null) {
      return "";
    } else {
      return String(value);
    }
  }

  function formatRange(start, end) {
    return "".concat(formatPos(start), "-").concat(formatPos(end));
  }

  function formatPos(pos) {
    var location = lines.locationForIndex(pos);

    if (!location) {
      return "Unknown";
    } else {
      return "".concat(location.line + 1, ":").concat(location.column + 1);
    }
  }
}

function truncate(s, length) {
  if (s.length > length) {
    return "".concat(s.slice(0, length - 3), "...");
  } else {
    return s;
  }
}