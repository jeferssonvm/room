"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVersion = getVersion;
exports.transform = transform;
exports.getFormattedTokens = getFormattedTokens;

var _CJSImportProcessor = _interopRequireDefault(require("./CJSImportProcessor"));

var _computeSourceMap = _interopRequireDefault(require("./computeSourceMap"));

var _HelperManager = require("./HelperManager");

var _identifyShadowedGlobals = _interopRequireDefault(require("./identifyShadowedGlobals"));

var _NameManager = _interopRequireDefault(require("./NameManager"));

var _Options = require("./Options");

var _parser = require("./parser");

var _TokenProcessor = _interopRequireDefault(require("./TokenProcessor"));

var _RootTransformer = _interopRequireDefault(require("./transformers/RootTransformer"));

var _formatTokens = _interopRequireDefault(require("./util/formatTokens"));

var _getTSImportedNames = _interopRequireDefault(require("./util/getTSImportedNames"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

;

function getVersion() {
  /* istanbul ignore next */
  return "3.34.0";
}

function transform(code, options) {
  (0, _Options.validateOptions)(options);

  try {
    var sucraseContext = getSucraseContext(code, options);
    var transformer = new _RootTransformer["default"](sucraseContext, options.transforms, Boolean(options.enableLegacyBabel5ModuleInterop), options);
    var transformerResult = transformer.transform();
    var result = {
      code: transformerResult.code
    };

    if (options.sourceMapOptions) {
      if (!options.filePath) {
        throw new Error("filePath must be specified when generating a source map.");
      }

      result = _objectSpread({}, result, {
        sourceMap: (0, _computeSourceMap["default"])(transformerResult, options.filePath, options.sourceMapOptions, code, sucraseContext.tokenProcessor.tokens)
      });
    }

    return result; // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (e) {
    if (options.filePath) {
      e.message = "Error transforming ".concat(options.filePath, ": ").concat(e.message);
    }

    throw e;
  }
}
/**
 * Return a string representation of the sucrase tokens, mostly useful for
 * diagnostic purposes.
 */


function getFormattedTokens(code, options) {
  var tokens = getSucraseContext(code, options).tokenProcessor.tokens;
  return (0, _formatTokens["default"])(code, tokens);
}
/**
 * Call into the parser/tokenizer and do some further preprocessing:
 * - Come up with a set of used names so that we can assign new names.
 * - Preprocess all import/export statements so we know which globals we are interested in.
 * - Compute situations where any of those globals are shadowed.
 *
 * In the future, some of these preprocessing steps can be skipped based on what actual work is
 * being done.
 */


function getSucraseContext(code, options) {
  var isJSXEnabled = options.transforms.includes("jsx");
  var isTypeScriptEnabled = options.transforms.includes("typescript");
  var isFlowEnabled = options.transforms.includes("flow");
  var disableESTransforms = options.disableESTransforms === true;
  var file = (0, _parser.parse)(code, isJSXEnabled, isTypeScriptEnabled, isFlowEnabled);
  var tokens = file.tokens;
  var scopes = file.scopes;
  var nameManager = new _NameManager["default"](code, tokens);
  var helperManager = new _HelperManager.HelperManager(nameManager);
  var tokenProcessor = new _TokenProcessor["default"](code, tokens, isFlowEnabled, disableESTransforms, helperManager);
  var enableLegacyTypeScriptModuleInterop = Boolean(options.enableLegacyTypeScriptModuleInterop);
  var importProcessor = null;

  if (options.transforms.includes("imports")) {
    importProcessor = new _CJSImportProcessor["default"](nameManager, tokenProcessor, enableLegacyTypeScriptModuleInterop, options, options.transforms.includes("typescript"), Boolean(options.keepUnusedImports), helperManager);
    importProcessor.preprocessTokens(); // We need to mark shadowed globals after processing imports so we know that the globals are,
    // but before type-only import pruning, since that relies on shadowing information.

    (0, _identifyShadowedGlobals["default"])(tokenProcessor, scopes, importProcessor.getGlobalNames());

    if (options.transforms.includes("typescript") && !options.keepUnusedImports) {
      importProcessor.pruneTypeOnlyImports();
    }
  } else if (options.transforms.includes("typescript") && !options.keepUnusedImports) {
    // Shadowed global detection is needed for TS implicit elision of imported names.
    (0, _identifyShadowedGlobals["default"])(tokenProcessor, scopes, (0, _getTSImportedNames["default"])(tokenProcessor));
  }

  return {
    tokenProcessor: tokenProcessor,
    scopes: scopes,
    nameManager: nameManager,
    importProcessor: importProcessor,
    helperManager: helperManager
  };
}