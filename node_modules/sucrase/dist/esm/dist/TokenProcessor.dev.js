"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _types = require("./parser/tokenizer/types");

var _isAsyncOperation = _interopRequireDefault(require("./util/isAsyncOperation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var TokenProcessor =
/*#__PURE__*/
function () {
  _createClass(TokenProcessor, [{
    key: "__init",
    value: function __init() {
      this.resultCode = "";
    } // Array mapping input token index to optional string index position in the
    // output code.

  }, {
    key: "__init2",
    value: function __init2() {
      this.resultMappings = new Array(this.tokens.length);
    }
  }, {
    key: "__init3",
    value: function __init3() {
      this.tokenIndex = 0;
    }
  }]);

  function TokenProcessor(code, tokens, isFlowEnabled, disableESTransforms, helperManager) {
    _classCallCheck(this, TokenProcessor);

    ;
    this.code = code;
    this.tokens = tokens;
    this.isFlowEnabled = isFlowEnabled;
    this.disableESTransforms = disableESTransforms;
    this.helperManager = helperManager;

    TokenProcessor.prototype.__init.call(this);

    TokenProcessor.prototype.__init2.call(this);

    TokenProcessor.prototype.__init3.call(this);
  }
  /**
   * Snapshot the token state in a way that can be restored later, useful for
   * things like lookahead.
   *
   * resultMappings do not need to be copied since in all use cases, they will
   * be overwritten anyway after restore.
   */


  _createClass(TokenProcessor, [{
    key: "snapshot",
    value: function snapshot() {
      return {
        resultCode: this.resultCode,
        tokenIndex: this.tokenIndex
      };
    }
  }, {
    key: "restoreToSnapshot",
    value: function restoreToSnapshot(snapshot) {
      this.resultCode = snapshot.resultCode;
      this.tokenIndex = snapshot.tokenIndex;
    }
    /**
     * Remove and return the code generated since the snapshot, leaving the
     * current token position in-place. Unlike most TokenProcessor operations,
     * this operation can result in input/output line number mismatches because
     * the removed code may contain newlines, so this operation should be used
     * sparingly.
     */

  }, {
    key: "dangerouslyGetAndRemoveCodeSinceSnapshot",
    value: function dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot) {
      var result = this.resultCode.slice(snapshot.resultCode.length);
      this.resultCode = snapshot.resultCode;
      return result;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.resultCode = "";
      this.resultMappings = new Array(this.tokens.length);
      this.tokenIndex = 0;
    }
  }, {
    key: "matchesContextualAtIndex",
    value: function matchesContextualAtIndex(index, contextualKeyword) {
      return this.matches1AtIndex(index, _types.TokenType.name) && this.tokens[index].contextualKeyword === contextualKeyword;
    }
  }, {
    key: "identifierNameAtIndex",
    value: function identifierNameAtIndex(index) {
      // TODO: We need to process escapes since technically you can have unicode escapes in variable
      // names.
      return this.identifierNameForToken(this.tokens[index]);
    }
  }, {
    key: "identifierNameAtRelativeIndex",
    value: function identifierNameAtRelativeIndex(relativeIndex) {
      return this.identifierNameForToken(this.tokenAtRelativeIndex(relativeIndex));
    }
  }, {
    key: "identifierName",
    value: function identifierName() {
      return this.identifierNameForToken(this.currentToken());
    }
  }, {
    key: "identifierNameForToken",
    value: function identifierNameForToken(token) {
      return this.code.slice(token.start, token.end);
    }
  }, {
    key: "rawCodeForToken",
    value: function rawCodeForToken(token) {
      return this.code.slice(token.start, token.end);
    }
  }, {
    key: "stringValueAtIndex",
    value: function stringValueAtIndex(index) {
      return this.stringValueForToken(this.tokens[index]);
    }
  }, {
    key: "stringValue",
    value: function stringValue() {
      return this.stringValueForToken(this.currentToken());
    }
  }, {
    key: "stringValueForToken",
    value: function stringValueForToken(token) {
      // This is used to identify when two imports are the same and to resolve TypeScript enum keys.
      // Ideally we'd process escapes within the strings, but for now we pretty much take the raw
      // code.
      return this.code.slice(token.start + 1, token.end - 1);
    }
  }, {
    key: "matches1AtIndex",
    value: function matches1AtIndex(index, t1) {
      return this.tokens[index].type === t1;
    }
  }, {
    key: "matches2AtIndex",
    value: function matches2AtIndex(index, t1, t2) {
      return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;
    }
  }, {
    key: "matches3AtIndex",
    value: function matches3AtIndex(index, t1, t2, t3) {
      return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2 && this.tokens[index + 2].type === t3;
    }
  }, {
    key: "matches1",
    value: function matches1(t1) {
      return this.tokens[this.tokenIndex].type === t1;
    }
  }, {
    key: "matches2",
    value: function matches2(t1, t2) {
      return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;
    }
  }, {
    key: "matches3",
    value: function matches3(t1, t2, t3) {
      return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3;
    }
  }, {
    key: "matches4",
    value: function matches4(t1, t2, t3, t4) {
      return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4;
    }
  }, {
    key: "matches5",
    value: function matches5(t1, t2, t3, t4, t5) {
      return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2 && this.tokens[this.tokenIndex + 2].type === t3 && this.tokens[this.tokenIndex + 3].type === t4 && this.tokens[this.tokenIndex + 4].type === t5;
    }
  }, {
    key: "matchesContextual",
    value: function matchesContextual(contextualKeyword) {
      return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);
    }
  }, {
    key: "matchesContextIdAndLabel",
    value: function matchesContextIdAndLabel(type, contextId) {
      return this.matches1(type) && this.currentToken().contextId === contextId;
    }
  }, {
    key: "previousWhitespaceAndComments",
    value: function previousWhitespaceAndComments() {
      var whitespaceAndComments = this.code.slice(this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0, this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length);

      if (this.isFlowEnabled) {
        whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, "");
      }

      return whitespaceAndComments;
    }
  }, {
    key: "replaceToken",
    value: function replaceToken(newCode) {
      this.resultCode += this.previousWhitespaceAndComments();
      this.appendTokenPrefix();
      this.resultMappings[this.tokenIndex] = this.resultCode.length;
      this.resultCode += newCode;
      this.appendTokenSuffix();
      this.tokenIndex++;
    }
  }, {
    key: "replaceTokenTrimmingLeftWhitespace",
    value: function replaceTokenTrimmingLeftWhitespace(newCode) {
      this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, "");
      this.appendTokenPrefix();
      this.resultMappings[this.tokenIndex] = this.resultCode.length;
      this.resultCode += newCode;
      this.appendTokenSuffix();
      this.tokenIndex++;
    }
  }, {
    key: "removeInitialToken",
    value: function removeInitialToken() {
      this.replaceToken("");
    }
  }, {
    key: "removeToken",
    value: function removeToken() {
      this.replaceTokenTrimmingLeftWhitespace("");
    }
    /**
     * Remove all code until the next }, accounting for balanced braces.
     */

  }, {
    key: "removeBalancedCode",
    value: function removeBalancedCode() {
      var braceDepth = 0;

      while (!this.isAtEnd()) {
        if (this.matches1(_types.TokenType.braceL)) {
          braceDepth++;
        } else if (this.matches1(_types.TokenType.braceR)) {
          if (braceDepth === 0) {
            return;
          }

          braceDepth--;
        }

        this.removeToken();
      }
    }
  }, {
    key: "copyExpectedToken",
    value: function copyExpectedToken(tokenType) {
      if (this.tokens[this.tokenIndex].type !== tokenType) {
        throw new Error("Expected token ".concat(tokenType));
      }

      this.copyToken();
    }
  }, {
    key: "copyToken",
    value: function copyToken() {
      this.resultCode += this.previousWhitespaceAndComments();
      this.appendTokenPrefix();
      this.resultMappings[this.tokenIndex] = this.resultCode.length;
      this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end);
      this.appendTokenSuffix();
      this.tokenIndex++;
    }
  }, {
    key: "copyTokenWithPrefix",
    value: function copyTokenWithPrefix(prefix) {
      this.resultCode += this.previousWhitespaceAndComments();
      this.appendTokenPrefix();
      this.resultCode += prefix;
      this.resultMappings[this.tokenIndex] = this.resultCode.length;
      this.resultCode += this.code.slice(this.tokens[this.tokenIndex].start, this.tokens[this.tokenIndex].end);
      this.appendTokenSuffix();
      this.tokenIndex++;
    }
  }, {
    key: "appendTokenPrefix",
    value: function appendTokenPrefix() {
      var token = this.currentToken();

      if (token.numNullishCoalesceStarts || token.isOptionalChainStart) {
        token.isAsyncOperation = (0, _isAsyncOperation["default"])(this);
      }

      if (this.disableESTransforms) {
        return;
      }

      if (token.numNullishCoalesceStarts) {
        for (var i = 0; i < token.numNullishCoalesceStarts; i++) {
          if (token.isAsyncOperation) {
            this.resultCode += "await ";
            this.resultCode += this.helperManager.getHelperName("asyncNullishCoalesce");
          } else {
            this.resultCode += this.helperManager.getHelperName("nullishCoalesce");
          }

          this.resultCode += "(";
        }
      }

      if (token.isOptionalChainStart) {
        if (token.isAsyncOperation) {
          this.resultCode += "await ";
        }

        if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === _types.TokenType._delete) {
          if (token.isAsyncOperation) {
            this.resultCode += this.helperManager.getHelperName("asyncOptionalChainDelete");
          } else {
            this.resultCode += this.helperManager.getHelperName("optionalChainDelete");
          }
        } else if (token.isAsyncOperation) {
          this.resultCode += this.helperManager.getHelperName("asyncOptionalChain");
        } else {
          this.resultCode += this.helperManager.getHelperName("optionalChain");
        }

        this.resultCode += "([";
      }
    }
  }, {
    key: "appendTokenSuffix",
    value: function appendTokenSuffix() {
      var token = this.currentToken();

      if (token.isOptionalChainEnd && !this.disableESTransforms) {
        this.resultCode += "])";
      }

      if (token.numNullishCoalesceEnds && !this.disableESTransforms) {
        for (var i = 0; i < token.numNullishCoalesceEnds; i++) {
          this.resultCode += "))";
        }
      }
    }
  }, {
    key: "appendCode",
    value: function appendCode(code) {
      this.resultCode += code;
    }
  }, {
    key: "currentToken",
    value: function currentToken() {
      return this.tokens[this.tokenIndex];
    }
  }, {
    key: "currentTokenCode",
    value: function currentTokenCode() {
      var token = this.currentToken();
      return this.code.slice(token.start, token.end);
    }
  }, {
    key: "tokenAtRelativeIndex",
    value: function tokenAtRelativeIndex(relativeIndex) {
      return this.tokens[this.tokenIndex + relativeIndex];
    }
  }, {
    key: "currentIndex",
    value: function currentIndex() {
      return this.tokenIndex;
    }
    /**
     * Move to the next token. Only suitable in preprocessing steps. When
     * generating new code, you should use copyToken or removeToken.
     */

  }, {
    key: "nextToken",
    value: function nextToken() {
      if (this.tokenIndex === this.tokens.length) {
        throw new Error("Unexpectedly reached end of input.");
      }

      this.tokenIndex++;
    }
  }, {
    key: "previousToken",
    value: function previousToken() {
      this.tokenIndex--;
    }
  }, {
    key: "finish",
    value: function finish() {
      if (this.tokenIndex !== this.tokens.length) {
        throw new Error("Tried to finish processing tokens before reaching the end.");
      }

      this.resultCode += this.previousWhitespaceAndComments();
      return {
        code: this.resultCode,
        mappings: this.resultMappings
      };
    }
  }, {
    key: "isAtEnd",
    value: function isAtEnd() {
      return this.tokenIndex === this.tokens.length;
    }
  }]);

  return TokenProcessor;
}();

exports["default"] = TokenProcessor;