"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var _keywords = require('../parser/tokenizer/keywords');

var _types = require('../parser/tokenizer/types');

var _Transformer = require('./Transformer');

var _Transformer2 = _interopRequireDefault(_Transformer);

var FlowTransformer =
/*#__PURE__*/
function (_Transformer2$default) {
  _inherits(FlowTransformer, _Transformer2$default);

  function FlowTransformer(rootTransformer, tokens, isImportsTransformEnabled) {
    var _this;

    _classCallCheck(this, FlowTransformer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FlowTransformer).call(this));
    _this.rootTransformer = rootTransformer;
    _this.tokens = tokens;
    _this.isImportsTransformEnabled = isImportsTransformEnabled;
    ;
    return _this;
  }

  _createClass(FlowTransformer, [{
    key: "process",
    value: function process() {
      if (this.rootTransformer.processPossibleArrowParamEnd() || this.rootTransformer.processPossibleAsyncArrowWithTypeParams() || this.rootTransformer.processPossibleTypeRange()) {
        return true;
      }

      if (this.tokens.matches1(_types.TokenType._enum)) {
        this.processEnum();
        return true;
      }

      if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._enum)) {
        this.processNamedExportEnum();
        return true;
      }

      if (this.tokens.matches3(_types.TokenType._export, _types.TokenType._default, _types.TokenType._enum)) {
        this.processDefaultExportEnum();
        return true;
      }

      return false;
    }
    /**
     * Handle a declaration like:
     * export enum E ...
     *
     * With this imports transform, this becomes:
     * const E = [[enum]]; exports.E = E;
     *
     * otherwise, it becomes:
     * export const E = [[enum]];
     */

  }, {
    key: "processNamedExportEnum",
    value: function processNamedExportEnum() {
      if (this.isImportsTransformEnabled) {
        // export
        this.tokens.removeInitialToken();
        var enumName = this.tokens.identifierNameAtRelativeIndex(1);
        this.processEnum();
        this.tokens.appendCode(" exports.".concat(enumName, " = ").concat(enumName, ";"));
      } else {
        this.tokens.copyToken();
        this.processEnum();
      }
    }
    /**
     * Handle a declaration like:
     * export default enum E
     *
     * With the imports transform, this becomes:
     * const E = [[enum]]; exports.default = E;
     *
     * otherwise, it becomes:
     * const E = [[enum]]; export default E;
     */

  }, {
    key: "processDefaultExportEnum",
    value: function processDefaultExportEnum() {
      // export
      this.tokens.removeInitialToken(); // default

      this.tokens.removeToken();
      var enumName = this.tokens.identifierNameAtRelativeIndex(1);
      this.processEnum();

      if (this.isImportsTransformEnabled) {
        this.tokens.appendCode(" exports.default = ".concat(enumName, ";"));
      } else {
        this.tokens.appendCode(" export default ".concat(enumName, ";"));
      }
    }
    /**
     * Transpile flow enums to invoke the "flow-enums-runtime" library.
     *
     * Currently, the transpiled code always uses `require("flow-enums-runtime")`,
     * but if future flexibility is needed, we could expose a config option for
     * this string (similar to configurable JSX). Even when targeting ESM, the
     * default behavior of babel-plugin-transform-flow-enums is to use require
     * rather than injecting an import.
     *
     * Flow enums are quite a bit simpler than TS enums and have some convenient
     * constraints:
     * - Element initializers must be either always present or always absent. That
     *   means that we can use fixed lookahead on the first element (if any) and
     *   assume that all elements are like that.
     * - The right-hand side of an element initializer must be a literal value,
     *   not a complex expression and not referencing other elements. That means
     *   we can simply copy a single token.
     *
     * Enums can be broken up into three basic cases:
     *
     * Mirrored enums:
     * enum E {A, B}
     *   ->
     * const E = require("flow-enums-runtime").Mirrored(["A", "B"]);
     *
     * Initializer enums:
     * enum E {A = 1, B = 2}
     *   ->
     * const E = require("flow-enums-runtime")({A: 1, B: 2});
     *
     * Symbol enums:
     * enum E of symbol {A, B}
     *   ->
     * const E = require("flow-enums-runtime")({A: Symbol("A"), B: Symbol("B")});
     *
     * We can statically detect which of the three cases this is by looking at the
     * "of" declaration (if any) and seeing if the first element has an initializer.
     * Since the other transform details are so similar between the three cases, we
     * use a single implementation and vary the transform within processEnumElement
     * based on case.
     */

  }, {
    key: "processEnum",
    value: function processEnum() {
      // enum E -> const E
      this.tokens.replaceToken("const");
      this.tokens.copyExpectedToken(_types.TokenType.name);
      var isSymbolEnum = false;

      if (this.tokens.matchesContextual(_keywords.ContextualKeyword._of)) {
        this.tokens.removeToken();
        isSymbolEnum = this.tokens.matchesContextual(_keywords.ContextualKeyword._symbol);
        this.tokens.removeToken();
      }

      var hasInitializers = this.tokens.matches3(_types.TokenType.braceL, _types.TokenType.name, _types.TokenType.eq);
      this.tokens.appendCode(' = require("flow-enums-runtime")');
      var isMirrored = !isSymbolEnum && !hasInitializers;
      this.tokens.replaceTokenTrimmingLeftWhitespace(isMirrored ? ".Mirrored([" : "({");

      while (!this.tokens.matches1(_types.TokenType.braceR)) {
        // ... is allowed at the end and has no runtime behavior.
        if (this.tokens.matches1(_types.TokenType.ellipsis)) {
          this.tokens.removeToken();
          break;
        }

        this.processEnumElement(isSymbolEnum, hasInitializers);

        if (this.tokens.matches1(_types.TokenType.comma)) {
          this.tokens.copyToken();
        }
      }

      this.tokens.replaceToken(isMirrored ? "]);" : "});");
    }
    /**
     * Process an individual enum element, producing either an array element or an
     * object element based on what type of enum this is.
     */

  }, {
    key: "processEnumElement",
    value: function processEnumElement(isSymbolEnum, hasInitializers) {
      if (isSymbolEnum) {
        // Symbol enums never have initializers and are expanded to object elements.
        // A, -> A: Symbol("A"),
        var elementName = this.tokens.identifierName();
        this.tokens.copyToken();
        this.tokens.appendCode(": Symbol(\"".concat(elementName, "\")"));
      } else if (hasInitializers) {
        // Initializers are expanded to object elements.
        // A = 1, -> A: 1,
        this.tokens.copyToken();
        this.tokens.replaceTokenTrimmingLeftWhitespace(":");
        this.tokens.copyToken();
      } else {
        // Enum elements without initializers become string literal array elements.
        // A, -> "A",
        this.tokens.replaceToken("\"".concat(this.tokens.identifierName(), "\""));
      }
    }
  }]);

  return FlowTransformer;
}(_Transformer2["default"]);

exports["default"] = FlowTransformer;