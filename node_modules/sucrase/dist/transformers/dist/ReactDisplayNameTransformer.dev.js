"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var _tokenizer = require('../parser/tokenizer');

var _types = require('../parser/tokenizer/types');

var _Transformer = require('./Transformer');

var _Transformer2 = _interopRequireDefault(_Transformer);
/**
 * Implementation of babel-plugin-transform-react-display-name, which adds a
 * display name to usages of React.createClass and createReactClass.
 */


var ReactDisplayNameTransformer =
/*#__PURE__*/
function (_Transformer2$default) {
  _inherits(ReactDisplayNameTransformer, _Transformer2$default);

  function ReactDisplayNameTransformer(rootTransformer, tokens, importProcessor, options) {
    var _this;

    _classCallCheck(this, ReactDisplayNameTransformer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactDisplayNameTransformer).call(this));
    _this.rootTransformer = rootTransformer;
    _this.tokens = tokens;
    _this.importProcessor = importProcessor;
    _this.options = options;
    ;
    return _this;
  }

  _createClass(ReactDisplayNameTransformer, [{
    key: "process",
    value: function process() {
      var startIndex = this.tokens.currentIndex();

      if (this.tokens.identifierName() === "createReactClass") {
        var newName = this.importProcessor && this.importProcessor.getIdentifierReplacement("createReactClass");

        if (newName) {
          this.tokens.replaceToken("(0, ".concat(newName, ")"));
        } else {
          this.tokens.copyToken();
        }

        this.tryProcessCreateClassCall(startIndex);
        return true;
      }

      if (this.tokens.matches3(_types.TokenType.name, _types.TokenType.dot, _types.TokenType.name) && this.tokens.identifierName() === "React" && this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 2) === "createClass") {
        var _newName = this.importProcessor ? this.importProcessor.getIdentifierReplacement("React") || "React" : "React";

        if (_newName) {
          this.tokens.replaceToken(_newName);
          this.tokens.copyToken();
          this.tokens.copyToken();
        } else {
          this.tokens.copyToken();
          this.tokens.copyToken();
          this.tokens.copyToken();
        }

        this.tryProcessCreateClassCall(startIndex);
        return true;
      }

      return false;
    }
    /**
     * This is called with the token position at the open-paren.
     */

  }, {
    key: "tryProcessCreateClassCall",
    value: function tryProcessCreateClassCall(startIndex) {
      var displayName = this.findDisplayName(startIndex);

      if (!displayName) {
        return;
      }

      if (this.classNeedsDisplayName()) {
        this.tokens.copyExpectedToken(_types.TokenType.parenL);
        this.tokens.copyExpectedToken(_types.TokenType.braceL);
        this.tokens.appendCode("displayName: '".concat(displayName, "',"));
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(_types.TokenType.braceR);
        this.tokens.copyExpectedToken(_types.TokenType.parenR);
      }
    }
  }, {
    key: "findDisplayName",
    value: function findDisplayName(startIndex) {
      if (startIndex < 2) {
        return null;
      }

      if (this.tokens.matches2AtIndex(startIndex - 2, _types.TokenType.name, _types.TokenType.eq)) {
        // This is an assignment (or declaration) and the LHS is either an identifier or a member
        // expression ending in an identifier, so use that identifier name.
        return this.tokens.identifierNameAtIndex(startIndex - 2);
      }

      if (startIndex >= 2 && this.tokens.tokens[startIndex - 2].identifierRole === _tokenizer.IdentifierRole.ObjectKey) {
        // This is an object literal value.
        return this.tokens.identifierNameAtIndex(startIndex - 2);
      }

      if (this.tokens.matches2AtIndex(startIndex - 2, _types.TokenType._export, _types.TokenType._default)) {
        return this.getDisplayNameFromFilename();
      }

      return null;
    }
  }, {
    key: "getDisplayNameFromFilename",
    value: function getDisplayNameFromFilename() {
      var filePath = this.options.filePath || "unknown";
      var pathSegments = filePath.split("/");
      var filename = pathSegments[pathSegments.length - 1];
      var dotIndex = filename.lastIndexOf(".");
      var baseFilename = dotIndex === -1 ? filename : filename.slice(0, dotIndex);

      if (baseFilename === "index" && pathSegments[pathSegments.length - 2]) {
        return pathSegments[pathSegments.length - 2];
      } else {
        return baseFilename;
      }
    }
    /**
     * We only want to add a display name when this is a function call containing
     * one argument, which is an object literal without `displayName` as an
     * existing key.
     */

  }, {
    key: "classNeedsDisplayName",
    value: function classNeedsDisplayName() {
      var index = this.tokens.currentIndex();

      if (!this.tokens.matches2(_types.TokenType.parenL, _types.TokenType.braceL)) {
        return false;
      } // The block starts on the {, and we expect any displayName key to be in
      // that context. We need to ignore other other contexts to avoid matching
      // nested displayName keys.


      var objectStartIndex = index + 1;
      var objectContextId = this.tokens.tokens[objectStartIndex].contextId;

      if (objectContextId == null) {
        throw new Error("Expected non-null context ID on object open-brace.");
      }

      for (; index < this.tokens.tokens.length; index++) {
        var token = this.tokens.tokens[index];

        if (token.type === _types.TokenType.braceR && token.contextId === objectContextId) {
          index++;
          break;
        }

        if (this.tokens.identifierNameAtIndex(index) === "displayName" && this.tokens.tokens[index].identifierRole === _tokenizer.IdentifierRole.ObjectKey && token.contextId === objectContextId) {
          // We found a displayName key, so bail out.
          return false;
        }
      }

      if (index === this.tokens.tokens.length) {
        throw new Error("Unexpected end of input when processing React class.");
      } // If we got this far, we know we have createClass with an object with no
      // display name, so we want to proceed as long as that was the only argument.


      return this.tokens.matches1AtIndex(index, _types.TokenType.parenR) || this.tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.parenR);
    }
  }]);

  return ReactDisplayNameTransformer;
}(_Transformer2["default"]);

exports["default"] = ReactDisplayNameTransformer;