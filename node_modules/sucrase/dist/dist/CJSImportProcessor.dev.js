"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var _tokenizer = require('./parser/tokenizer');

var _keywords = require('./parser/tokenizer/keywords');

var _types = require('./parser/tokenizer/types');

var _getImportExportSpecifierInfo = require('./util/getImportExportSpecifierInfo');

var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);

var _getNonTypeIdentifiers = require('./util/getNonTypeIdentifiers');
/**
 * Class responsible for preprocessing and bookkeeping import and export declarations within the
 * file.
 *
 * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and
 * interopRequireWildcard, so we also allow that mode for compatibility.
 */


var CJSImportProcessor =
/*#__PURE__*/
function () {
  _createClass(CJSImportProcessor, [{
    key: "__init",
    value: function __init() {
      this.nonTypeIdentifiers = new Set();
    }
  }, {
    key: "__init2",
    value: function __init2() {
      this.importInfoByPath = new Map();
    }
  }, {
    key: "__init3",
    value: function __init3() {
      this.importsToReplace = new Map();
    }
  }, {
    key: "__init4",
    value: function __init4() {
      this.identifierReplacements = new Map();
    }
  }, {
    key: "__init5",
    value: function __init5() {
      this.exportBindingsByLocalName = new Map();
    }
  }]);

  function CJSImportProcessor(nameManager, tokens, enableLegacyTypeScriptModuleInterop, options, isTypeScriptTransformEnabled, keepUnusedImports, helperManager) {
    _classCallCheck(this, CJSImportProcessor);

    ;
    this.nameManager = nameManager;
    this.tokens = tokens;
    this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;
    this.options = options;
    this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;
    this.keepUnusedImports = keepUnusedImports;
    this.helperManager = helperManager;

    CJSImportProcessor.prototype.__init.call(this);

    CJSImportProcessor.prototype.__init2.call(this);

    CJSImportProcessor.prototype.__init3.call(this);

    CJSImportProcessor.prototype.__init4.call(this);

    CJSImportProcessor.prototype.__init5.call(this);
  }

  _createClass(CJSImportProcessor, [{
    key: "preprocessTokens",
    value: function preprocessTokens() {
      for (var i = 0; i < this.tokens.tokens.length; i++) {
        if (this.tokens.matches1AtIndex(i, _types.TokenType._import) && !this.tokens.matches3AtIndex(i, _types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) {
          this.preprocessImportAtIndex(i);
        }

        if (this.tokens.matches1AtIndex(i, _types.TokenType._export) && !this.tokens.matches2AtIndex(i, _types.TokenType._export, _types.TokenType.eq)) {
          this.preprocessExportAtIndex(i);
        }
      }

      this.generateImportReplacements();
    }
    /**
     * In TypeScript, import statements that only import types should be removed.
     * This includes `import {} from 'foo';`, but not `import 'foo';`.
     */

  }, {
    key: "pruneTypeOnlyImports",
    value: function pruneTypeOnlyImports() {
      var _this = this;

      this.nonTypeIdentifiers = _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, this.tokens, this.options);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.importInfoByPath.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              path = _step$value[0],
              importInfo = _step$value[1];

          if (importInfo.hasBareImport || importInfo.hasStarExport || importInfo.exportStarNames.length > 0 || importInfo.namedExports.length > 0) {
            continue;
          }

          var names = [].concat(_toConsumableArray(importInfo.defaultNames), _toConsumableArray(importInfo.wildcardNames), _toConsumableArray(importInfo.namedImports.map(function (_ref) {
            var localName = _ref.localName;
            return localName;
          })));

          if (names.every(function (name) {
            return _this.shouldAutomaticallyElideImportedName(name);
          })) {
            this.importsToReplace.set(path, "");
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "shouldAutomaticallyElideImportedName",
    value: function shouldAutomaticallyElideImportedName(name) {
      return this.isTypeScriptTransformEnabled && !this.keepUnusedImports && !this.nonTypeIdentifiers.has(name);
    }
  }, {
    key: "generateImportReplacements",
    value: function generateImportReplacements() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this.importInfoByPath.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = _slicedToArray(_step2.value, 2),
              path = _step2$value[0],
              importInfo = _step2$value[1];

          var defaultNames = importInfo.defaultNames,
              wildcardNames = importInfo.wildcardNames,
              namedImports = importInfo.namedImports,
              namedExports = importInfo.namedExports,
              exportStarNames = importInfo.exportStarNames,
              hasStarExport = importInfo.hasStarExport;

          if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0 && namedExports.length === 0 && exportStarNames.length === 0 && !hasStarExport) {
            // Import is never used, so don't even assign a name.
            this.importsToReplace.set(path, "require('".concat(path, "');"));
            continue;
          }

          var primaryImportName = this.getFreeIdentifierForPath(path);
          var secondaryImportName = void 0;

          if (this.enableLegacyTypeScriptModuleInterop) {
            secondaryImportName = primaryImportName;
          } else {
            secondaryImportName = wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
          }

          var requireCode = "var ".concat(primaryImportName, " = require('").concat(path, "');");

          if (wildcardNames.length > 0) {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = wildcardNames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var wildcardName = _step3.value;
                var moduleExpr = this.enableLegacyTypeScriptModuleInterop ? primaryImportName : "".concat(this.helperManager.getHelperName("interopRequireWildcard"), "(").concat(primaryImportName, ")");
                requireCode += " var ".concat(wildcardName, " = ").concat(moduleExpr, ";");
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {
            requireCode += " var ".concat(secondaryImportName, " = ").concat(this.helperManager.getHelperName("interopRequireWildcard"), "(").concat(primaryImportName, ");");
          } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {
            requireCode += " var ".concat(secondaryImportName, " = ").concat(this.helperManager.getHelperName("interopRequireDefault"), "(").concat(primaryImportName, ");");
          }

          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = namedExports[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var _step4$value = _step4.value,
                  importedName = _step4$value.importedName,
                  localName = _step4$value.localName;
              requireCode += " ".concat(this.helperManager.getHelperName("createNamedExportFrom"), "(").concat(primaryImportName, ", '").concat(localName, "', '").concat(importedName, "');");
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = exportStarNames[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var exportStarName = _step5.value;
              requireCode += " exports.".concat(exportStarName, " = ").concat(secondaryImportName, ";");
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

          if (hasStarExport) {
            requireCode += " ".concat(this.helperManager.getHelperName("createStarExport"), "(").concat(primaryImportName, ");");
          }

          this.importsToReplace.set(path, requireCode);
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = defaultNames[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var defaultName = _step6.value;
              this.identifierReplacements.set(defaultName, "".concat(secondaryImportName, ".default"));
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                _iterator6["return"]();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }

          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = namedImports[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var _step7$value = _step7.value,
                  _importedName = _step7$value.importedName,
                  _localName = _step7$value.localName;
              this.identifierReplacements.set(_localName, "".concat(primaryImportName, ".").concat(_importedName));
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                _iterator7["return"]();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "getFreeIdentifierForPath",
    value: function getFreeIdentifierForPath(path) {
      var components = path.split("/");
      var lastComponent = components[components.length - 1];
      var baseName = lastComponent.replace(/\W/g, "");
      return this.nameManager.claimFreeName("_".concat(baseName));
    }
  }, {
    key: "preprocessImportAtIndex",
    value: function preprocessImportAtIndex(index) {
      var _importInfo$defaultNa, _importInfo$wildcardN, _importInfo$namedImpo;

      var defaultNames = [];
      var wildcardNames = [];
      var namedImports = [];
      index++;

      if ((this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._type) || this.tokens.matches1AtIndex(index, _types.TokenType._typeof)) && !this.tokens.matches1AtIndex(index + 1, _types.TokenType.comma) && !this.tokens.matchesContextualAtIndex(index + 1, _keywords.ContextualKeyword._from)) {
        // import type declaration, so no need to process anything.
        return;
      }

      if (this.tokens.matches1AtIndex(index, _types.TokenType.parenL)) {
        // Dynamic import, so nothing to do
        return;
      }

      if (this.tokens.matches1AtIndex(index, _types.TokenType.name)) {
        defaultNames.push(this.tokens.identifierNameAtIndex(index));
        index++;

        if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
          index++;
        }
      }

      if (this.tokens.matches1AtIndex(index, _types.TokenType.star)) {
        // * as
        index += 2;
        wildcardNames.push(this.tokens.identifierNameAtIndex(index));
        index++;
      }

      if (this.tokens.matches1AtIndex(index, _types.TokenType.braceL)) {
        var result = this.getNamedImports(index + 1);
        index = result.newIndex;
        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = result.namedImports[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var namedImport = _step8.value;

            // Treat {default as X} as a default import to ensure usage of require interop helper
            if (namedImport.importedName === "default") {
              defaultNames.push(namedImport.localName);
            } else {
              namedImports.push(namedImport);
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
              _iterator8["return"]();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }
      }

      if (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._from)) {
        index++;
      }

      if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
        throw new Error("Expected string token at the end of import statement.");
      }

      var path = this.tokens.stringValueAtIndex(index);
      var importInfo = this.getImportInfo(path);

      (_importInfo$defaultNa = importInfo.defaultNames).push.apply(_importInfo$defaultNa, defaultNames);

      (_importInfo$wildcardN = importInfo.wildcardNames).push.apply(_importInfo$wildcardN, wildcardNames);

      (_importInfo$namedImpo = importInfo.namedImports).push.apply(_importInfo$namedImpo, namedImports);

      if (defaultNames.length === 0 && wildcardNames.length === 0 && namedImports.length === 0) {
        importInfo.hasBareImport = true;
      }
    }
  }, {
    key: "preprocessExportAtIndex",
    value: function preprocessExportAtIndex(index) {
      if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._var) || this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._let) || this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._const)) {
        this.preprocessVarExportAtIndex(index);
      } else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._function) || this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType._class)) {
        var exportName = this.tokens.identifierNameAtIndex(index + 2);
        this.addExportBinding(exportName, exportName);
      } else if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.name, _types.TokenType._function)) {
        var _exportName = this.tokens.identifierNameAtIndex(index + 3);

        this.addExportBinding(_exportName, _exportName);
      } else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType.braceL)) {
        this.preprocessNamedExportAtIndex(index);
      } else if (this.tokens.matches2AtIndex(index, _types.TokenType._export, _types.TokenType.star)) {
        this.preprocessExportStarAtIndex(index);
      }
    }
  }, {
    key: "preprocessVarExportAtIndex",
    value: function preprocessVarExportAtIndex(index) {
      var depth = 0; // Handle cases like `export let {x} = y;`, starting at the open-brace in that case.

      for (var i = index + 2;; i++) {
        if (this.tokens.matches1AtIndex(i, _types.TokenType.braceL) || this.tokens.matches1AtIndex(i, _types.TokenType.dollarBraceL) || this.tokens.matches1AtIndex(i, _types.TokenType.bracketL)) {
          depth++;
        } else if (this.tokens.matches1AtIndex(i, _types.TokenType.braceR) || this.tokens.matches1AtIndex(i, _types.TokenType.bracketR)) {
          depth--;
        } else if (depth === 0 && !this.tokens.matches1AtIndex(i, _types.TokenType.name)) {
          break;
        } else if (this.tokens.matches1AtIndex(1, _types.TokenType.eq)) {
          var endIndex = this.tokens.currentToken().rhsEndIndex;

          if (endIndex == null) {
            throw new Error("Expected = token with an end index.");
          }

          i = endIndex - 1;
        } else {
          var token = this.tokens.tokens[i];

          if (_tokenizer.isDeclaration.call(void 0, token)) {
            var exportName = this.tokens.identifierNameAtIndex(i);
            this.identifierReplacements.set(exportName, "exports.".concat(exportName));
          }
        }
      }
    }
    /**
     * Walk this export statement just in case it's an export...from statement.
     * If it is, combine it into the import info for that path. Otherwise, just
     * bail out; it'll be handled later.
     */

  }, {
    key: "preprocessNamedExportAtIndex",
    value: function preprocessNamedExportAtIndex(index) {
      var _importInfo$namedExpo;

      // export {
      index += 2;

      var _this$getNamedImports = this.getNamedImports(index),
          newIndex = _this$getNamedImports.newIndex,
          namedImports = _this$getNamedImports.namedImports;

      index = newIndex;

      if (this.tokens.matchesContextualAtIndex(index, _keywords.ContextualKeyword._from)) {
        index++;
      } else {
        // Reinterpret "a as b" to be local/exported rather than imported/local.
        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
          for (var _iterator9 = namedImports[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
            var _step9$value = _step9.value,
                localName = _step9$value.importedName,
                exportedName = _step9$value.localName;
            this.addExportBinding(localName, exportedName);
          }
        } catch (err) {
          _didIteratorError9 = true;
          _iteratorError9 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
              _iterator9["return"]();
            }
          } finally {
            if (_didIteratorError9) {
              throw _iteratorError9;
            }
          }
        }

        return;
      }

      if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
        throw new Error("Expected string token at the end of import statement.");
      }

      var path = this.tokens.stringValueAtIndex(index);
      var importInfo = this.getImportInfo(path);

      (_importInfo$namedExpo = importInfo.namedExports).push.apply(_importInfo$namedExpo, _toConsumableArray(namedImports));
    }
  }, {
    key: "preprocessExportStarAtIndex",
    value: function preprocessExportStarAtIndex(index) {
      var exportedName = null;

      if (this.tokens.matches3AtIndex(index, _types.TokenType._export, _types.TokenType.star, _types.TokenType._as)) {
        // export * as
        index += 3;
        exportedName = this.tokens.identifierNameAtIndex(index); // foo from

        index += 2;
      } else {
        // export * from
        index += 3;
      }

      if (!this.tokens.matches1AtIndex(index, _types.TokenType.string)) {
        throw new Error("Expected string token at the end of star export statement.");
      }

      var path = this.tokens.stringValueAtIndex(index);
      var importInfo = this.getImportInfo(path);

      if (exportedName !== null) {
        importInfo.exportStarNames.push(exportedName);
      } else {
        importInfo.hasStarExport = true;
      }
    }
  }, {
    key: "getNamedImports",
    value: function getNamedImports(index) {
      var namedImports = [];

      while (true) {
        if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
          index++;
          break;
        }

        var specifierInfo = _getImportExportSpecifierInfo2["default"].call(void 0, this.tokens, index);

        index = specifierInfo.endIndex;

        if (!specifierInfo.isType) {
          namedImports.push({
            importedName: specifierInfo.leftName,
            localName: specifierInfo.rightName
          });
        }

        if (this.tokens.matches2AtIndex(index, _types.TokenType.comma, _types.TokenType.braceR)) {
          index += 2;
          break;
        } else if (this.tokens.matches1AtIndex(index, _types.TokenType.braceR)) {
          index++;
          break;
        } else if (this.tokens.matches1AtIndex(index, _types.TokenType.comma)) {
          index++;
        } else {
          throw new Error("Unexpected token: ".concat(JSON.stringify(this.tokens.tokens[index])));
        }
      }

      return {
        newIndex: index,
        namedImports: namedImports
      };
    }
    /**
     * Get a mutable import info object for this path, creating one if it doesn't
     * exist yet.
     */

  }, {
    key: "getImportInfo",
    value: function getImportInfo(path) {
      var existingInfo = this.importInfoByPath.get(path);

      if (existingInfo) {
        return existingInfo;
      }

      var newInfo = {
        defaultNames: [],
        wildcardNames: [],
        namedImports: [],
        namedExports: [],
        hasBareImport: false,
        exportStarNames: [],
        hasStarExport: false
      };
      this.importInfoByPath.set(path, newInfo);
      return newInfo;
    }
  }, {
    key: "addExportBinding",
    value: function addExportBinding(localName, exportedName) {
      if (!this.exportBindingsByLocalName.has(localName)) {
        this.exportBindingsByLocalName.set(localName, []);
      }

      this.exportBindingsByLocalName.get(localName).push(exportedName);
    }
    /**
     * Return the code to use for the import for this path, or the empty string if
     * the code has already been "claimed" by a previous import.
     */

  }, {
    key: "claimImportCode",
    value: function claimImportCode(importPath) {
      var result = this.importsToReplace.get(importPath);
      this.importsToReplace.set(importPath, "");
      return result || "";
    }
  }, {
    key: "getIdentifierReplacement",
    value: function getIdentifierReplacement(identifierName) {
      return this.identifierReplacements.get(identifierName) || null;
    }
    /**
     * Return a string like `exports.foo = exports.bar`.
     */

  }, {
    key: "resolveExportBinding",
    value: function resolveExportBinding(assignedName) {
      var exportedNames = this.exportBindingsByLocalName.get(assignedName);

      if (!exportedNames || exportedNames.length === 0) {
        return null;
      }

      return exportedNames.map(function (exportedName) {
        return "exports.".concat(exportedName);
      }).join(" = ");
    }
    /**
     * Return all imported/exported names where we might be interested in whether usages of those
     * names are shadowed.
     */

  }, {
    key: "getGlobalNames",
    value: function getGlobalNames() {
      return new Set([].concat(_toConsumableArray(this.identifierReplacements.keys()), _toConsumableArray(this.exportBindingsByLocalName.keys())));
    }
  }]);

  return CJSImportProcessor;
}();

exports["default"] = CJSImportProcessor;