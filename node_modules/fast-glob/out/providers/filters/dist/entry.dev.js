"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var utils = require("../../utils");

var EntryFilter =
/*#__PURE__*/
function () {
  function EntryFilter(_settings, _micromatchOptions) {
    _classCallCheck(this, EntryFilter);

    this._settings = _settings;
    this._micromatchOptions = _micromatchOptions;
    this.index = new Map();
  }

  _createClass(EntryFilter, [{
    key: "getFilter",
    value: function getFilter(positive, negative) {
      var _this = this;

      var positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
      var negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), {
        dot: true
      }));
      return function (entry) {
        return _this._filter(entry, positiveRe, negativeRe);
      };
    }
  }, {
    key: "_filter",
    value: function _filter(entry, positiveRe, negativeRe) {
      var filepath = utils.path.removeLeadingDotSegment(entry.path);

      if (this._settings.unique && this._isDuplicateEntry(filepath)) {
        return false;
      }

      if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
        return false;
      }

      if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
        return false;
      }

      var isDirectory = entry.dirent.isDirectory();
      var isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory);

      if (this._settings.unique && isMatched) {
        this._createIndexRecord(filepath);
      }

      return isMatched;
    }
  }, {
    key: "_isDuplicateEntry",
    value: function _isDuplicateEntry(filepath) {
      return this.index.has(filepath);
    }
  }, {
    key: "_createIndexRecord",
    value: function _createIndexRecord(filepath) {
      this.index.set(filepath, undefined);
    }
  }, {
    key: "_onlyFileFilter",
    value: function _onlyFileFilter(entry) {
      return this._settings.onlyFiles && !entry.dirent.isFile();
    }
  }, {
    key: "_onlyDirectoryFilter",
    value: function _onlyDirectoryFilter(entry) {
      return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
  }, {
    key: "_isSkippedByAbsoluteNegativePatterns",
    value: function _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
      if (!this._settings.absolute) {
        return false;
      }

      var fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
      return utils.pattern.matchAny(fullpath, patternsRe);
    }
  }, {
    key: "_isMatchToPatterns",
    value: function _isMatchToPatterns(filepath, patternsRe, isDirectory) {
      // Trying to match files and directories by patterns.
      var isMatched = utils.pattern.matchAny(filepath, patternsRe); // A pattern with a trailling slash can be used for directory matching.
      // To apply such pattern, we need to add a tralling slash to the path.

      if (!isMatched && isDirectory) {
        return utils.pattern.matchAny(filepath + '/', patternsRe);
      }

      return isMatched;
    }
  }]);

  return EntryFilter;
}();

exports["default"] = EntryFilter;