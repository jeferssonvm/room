"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pattern = pattern;
exports.withoutCapturing = withoutCapturing;
exports.any = any;
exports.optional = optional;
exports.zeroOrMore = zeroOrMore;
exports.nestedBrackets = nestedBrackets;
exports.escape = escape;
var REGEX_SPECIAL = /[\\^$.*+?()[\]{}|]/g;
var REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);
/**
 * @param {string|RegExp|Array<string|RegExp>} source
 */

function toSource(source) {
  source = Array.isArray(source) ? source : [source];
  source = source.map(function (item) {
    return item instanceof RegExp ? item.source : item;
  });
  return source.join('');
}
/**
 * @param {string|RegExp|Array<string|RegExp>} source
 */


function pattern(source) {
  return new RegExp(toSource(source), 'g');
}
/**
 * @param {string|RegExp|Array<string|RegExp>} source
 */


function withoutCapturing(source) {
  return new RegExp("(?:".concat(toSource(source), ")"), 'g');
}
/**
 * @param {Array<string|RegExp>} sources
 */


function any(sources) {
  return "(?:".concat(sources.map(toSource).join('|'), ")");
}
/**
 * @param {string|RegExp} source
 */


function optional(source) {
  return "(?:".concat(toSource(source), ")?");
}
/**
 * @param {string|RegExp|Array<string|RegExp>} source
 */


function zeroOrMore(source) {
  return "(?:".concat(toSource(source), ")*");
}
/**
 * Generate a RegExp that matches balanced brackets for a given depth
 * We have to specify a depth because JS doesn't support recursive groups using ?R
 *
 * Based on https://stackoverflow.com/questions/17759004/how-to-match-string-within-parentheses-nested-in-java/17759264#17759264
 *
 * @param {string|RegExp|Array<string|RegExp>} source
 */


function nestedBrackets(open, close) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return withoutCapturing([escape(open), /[^\s]*/, depth === 1 ? "[^".concat(escape(open)).concat(escape(close), "s]*") : any(["[^".concat(escape(open)).concat(escape(close), "s]*"), nestedBrackets(open, close, depth - 1)]), /[^\s]*/, escape(close)]);
}

function escape(string) {
  return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, '\\$&') : string || '';
}