"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = processTailwindFeatures;

var _normalizeTailwindDirectives = _interopRequireDefault(require("./lib/normalizeTailwindDirectives"));

var _expandTailwindAtRules = _interopRequireDefault(require("./lib/expandTailwindAtRules"));

var _expandApplyAtRules = _interopRequireDefault(require("./lib/expandApplyAtRules"));

var _evaluateTailwindFunctions = _interopRequireDefault(require("./lib/evaluateTailwindFunctions"));

var _substituteScreenAtRules = _interopRequireDefault(require("./lib/substituteScreenAtRules"));

var _resolveDefaultsAtRules = _interopRequireDefault(require("./lib/resolveDefaultsAtRules"));

var _collapseAdjacentRules = _interopRequireDefault(require("./lib/collapseAdjacentRules"));

var _collapseDuplicateDeclarations = _interopRequireDefault(require("./lib/collapseDuplicateDeclarations"));

var _partitionApplyAtRules = _interopRequireDefault(require("./lib/partitionApplyAtRules"));

var _detectNesting = _interopRequireDefault(require("./lib/detectNesting"));

var _setupContextUtils = require("./lib/setupContextUtils");

var _featureFlags = require("./featureFlags");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function processTailwindFeatures(setupContext) {
  return function _callee(root, result) {
    var _normalizeTailwindDir, tailwindDirectives, applyDirectives, context;

    return regeneratorRuntime.async(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _normalizeTailwindDir = (0, _normalizeTailwindDirectives["default"])(root), tailwindDirectives = _normalizeTailwindDir.tailwindDirectives, applyDirectives = _normalizeTailwindDir.applyDirectives;
            (0, _detectNesting["default"])()(root, result); // Partition apply rules that are found in the css
            // itself.

            (0, _partitionApplyAtRules["default"])()(root, result);
            context = setupContext({
              tailwindDirectives: tailwindDirectives,
              applyDirectives: applyDirectives,
              registerDependency: function registerDependency(dependency) {
                result.messages.push(_objectSpread({
                  plugin: 'tailwindcss',
                  parent: result.opts.from
                }, dependency));
              },
              createContext: function createContext(tailwindConfig, changedContent) {
                return (0, _setupContextUtils.createContext)(tailwindConfig, changedContent, root);
              }
            })(root, result);

            if (!(context.tailwindConfig.separator === '-')) {
              _context.next = 6;
              break;
            }

            throw new Error("The '-' character cannot be used as a custom separator in JIT mode due to parsing ambiguity. Please use another character like '_' instead.");

          case 6:
            (0, _featureFlags.issueFlagNotices)(context.tailwindConfig);
            _context.next = 9;
            return regeneratorRuntime.awrap((0, _expandTailwindAtRules["default"])(context)(root, result));

          case 9:
            // Partition apply rules that are generated by
            // addComponents, addUtilities and so on.
            (0, _partitionApplyAtRules["default"])()(root, result);
            (0, _expandApplyAtRules["default"])(context)(root, result);
            (0, _evaluateTailwindFunctions["default"])(context)(root, result);
            (0, _substituteScreenAtRules["default"])(context)(root, result);
            (0, _resolveDefaultsAtRules["default"])(context)(root, result);
            (0, _collapseAdjacentRules["default"])(context)(root, result);
            (0, _collapseDuplicateDeclarations["default"])(context)(root, result);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    });
  };
}