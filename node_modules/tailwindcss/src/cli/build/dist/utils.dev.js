"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.indentRecursive = indentRecursive;
exports.formatNodes = formatNodes;
exports.readFileWithRetries = readFileWithRetries;
exports.drainStdin = drainStdin;
exports.outputFile = outputFile;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// @ts-check
function indentRecursive(node) {
  var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  node.each && node.each(function (child, i) {
    if (!child.raws.before || !child.raws.before.trim() || child.raws.before.includes('\n')) {
      child.raws.before = "\n".concat(node.type !== 'rule' && i > 0 ? '\n' : '').concat('  '.repeat(indent));
    }

    child.raws.after = "\n".concat('  '.repeat(indent));
    indentRecursive(child, indent + 1);
  });
}

function formatNodes(root) {
  indentRecursive(root);

  if (root.first) {
    root.first.raws.before = '';
  }
}
/**
 * When rapidly saving files atomically a couple of situations can happen:
 * - The file is missing since the external program has deleted it by the time we've gotten around to reading it from the earlier save.
 * - The file is being written to by the external program by the time we're going to read it and is thus treated as busy because a lock is held.
 *
 * To work around this we retry reading the file a handful of times with a delay between each attempt
 *
 * @param {string} path
 * @param {number} tries
 * @returns {Promise<string | undefined>}
 * @throws {Error} If the file is still missing or busy after the specified number of tries
 */


function readFileWithRetries(path) {
  var tries,
      n,
      _args = arguments;
  return regeneratorRuntime.async(function readFileWithRetries$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          tries = _args.length > 1 && _args[1] !== undefined ? _args[1] : 5;
          n = 0;

        case 2:
          if (!(n <= tries)) {
            _context.next = 20;
            break;
          }

          _context.prev = 3;
          _context.next = 6;
          return regeneratorRuntime.awrap(_fs["default"].promises.readFile(path, 'utf8'));

        case 6:
          return _context.abrupt("return", _context.sent);

        case 9:
          _context.prev = 9;
          _context.t0 = _context["catch"](3);

          if (!(n !== tries)) {
            _context.next = 16;
            break;
          }

          if (!(_context.t0.code === 'ENOENT' || _context.t0.code === 'EBUSY')) {
            _context.next = 16;
            break;
          }

          _context.next = 15;
          return regeneratorRuntime.awrap(new Promise(function (resolve) {
            return setTimeout(resolve, 10);
          }));

        case 15:
          return _context.abrupt("continue", 17);

        case 16:
          throw _context.t0;

        case 17:
          n++;
          _context.next = 2;
          break;

        case 20:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[3, 9]]);
}

function drainStdin() {
  return new Promise(function (resolve, reject) {
    var result = '';
    process.stdin.on('data', function (chunk) {
      result += chunk;
    });
    process.stdin.on('end', function () {
      return resolve(result);
    });
    process.stdin.on('error', function (err) {
      return reject(err);
    });
  });
}

function outputFile(file, newContents) {
  var currentContents;
  return regeneratorRuntime.async(function outputFile$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          _context2.next = 3;
          return regeneratorRuntime.awrap(_fs["default"].promises.readFile(file, 'utf8'));

        case 3:
          currentContents = _context2.sent;

          if (!(currentContents === newContents)) {
            _context2.next = 6;
            break;
          }

          return _context2.abrupt("return");

        case 6:
          _context2.next = 10;
          break;

        case 8:
          _context2.prev = 8;
          _context2.t0 = _context2["catch"](0);

        case 10:
          _context2.next = 12;
          return regeneratorRuntime.awrap(_fs["default"].promises.mkdir(_path["default"].dirname(file), {
            recursive: true
          }));

        case 12:
          _context2.next = 14;
          return regeneratorRuntime.awrap(_fs["default"].promises.writeFile(file, newContents, 'utf8'));

        case 14:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, [[0, 8]]);
}