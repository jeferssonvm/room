#!/usr/bin/env node
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var path_1 = require("path");
var arg_1 = require("arg");
var fs_1 = require("fs");
var build_1 = require("./build");
var help_1 = require("./help");
var init_1 = require("./init");
// ---
function oneOf() {
    var options = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        options[_i] = arguments[_i];
    }
    return Object.assign(function (value) {
        if (value === void 0) { value = true; }
        for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
            var option = options_1[_i];
            var parsed = option(value);
            if (parsed === value) {
                return parsed;
            }
        }
        throw new Error('...');
    }, { manualParsing: true });
}
var commands = {
    init: {
        run: init_1.init,
        args: {
            '--esm': { type: Boolean, description: "Initialize configuration file as ESM" },
            '--ts': { type: Boolean, description: "Initialize configuration file as TypeScript" },
            '--full': {
                type: Boolean,
                description: "Include the default values for all options in the generated configuration file"
            },
            '-f': '--full'
        }
    },
    build: {
        run: build_1.build,
        args: {
            '--input': { type: String, description: 'Input file' },
            '--output': { type: String, description: 'Output file' },
            '--watch': {
                type: oneOf(String, Boolean),
                description: 'Watch for changes and rebuild as needed'
            },
            '--poll': {
                type: Boolean,
                description: 'Use polling instead of filesystem events when watching'
            },
            '--content': {
                type: String,
                description: 'Content paths to use for removing unused classes'
            },
            '--minify': { type: Boolean, description: 'Minify the output' },
            '--config': {
                type: String,
                description: 'Path to a custom config file'
            },
            '-c': '--config',
            '-i': '--input',
            '-o': '--output',
            '-m': '--minify',
            '-w': '--watch',
            '-p': '--poll'
        }
    }
};
var sharedFlags = {
    '--help': { type: Boolean, description: 'Display usage information' },
    '-h': '--help'
};
if (process.stdout.isTTY /* Detect redirecting output to a file */ &&
    (process.argv[2] === undefined ||
        process.argv.slice(2).every(function (flag) { return sharedFlags[flag] !== undefined; }))) {
    help_1.help({
        usage: [
            'tailwindcss [--input input.css] [--output output.css] [--watch] [options...]',
            'tailwindcss init [--full] [options...]',
        ],
        commands: Object.keys(commands)
            .filter(function (command) { return command !== 'build'; })
            .map(function (command) { return command + " [options]"; }),
        options: __assign(__assign({}, commands.build.args), sharedFlags)
    });
    process.exit(0);
}
var command = (function (arg) {
    if (arg === void 0) { arg = ''; }
    return (arg.startsWith('-') ? undefined : arg);
})(process.argv[2]) || 'build';
if (commands[command] === undefined) {
    if (fs_1["default"].existsSync(path_1["default"].resolve(command))) {
        // TODO: Deprecate this in future versions
        // Check if non-existing command, might be a file.
        command = 'build';
    }
    else {
        help_1.help({
            message: "Invalid command: " + command,
            usage: ['tailwindcss <command> [options]'],
            commands: Object.keys(commands)
                .filter(function (command) { return command !== 'build'; })
                .map(function (command) { return command + " [options]"; }),
            options: sharedFlags
        });
        process.exit(1);
    }
}
// Execute command
var _a = commands[command], flags = _a.args, run = _a.run;
var args = (function () {
    try {
        var result = arg_1["default"](Object.fromEntries(Object.entries(__assign(__assign({}, flags), sharedFlags))
            .filter(function (_a) {
            var _b;
            var _key = _a[0], value = _a[1];
            return !((_b = value === null || value === void 0 ? void 0 : value.type) === null || _b === void 0 ? void 0 : _b.manualParsing);
        })
            .map(function (_a) {
            var key = _a[0], value = _a[1];
            return [key, typeof value === 'object' ? value.type : value];
        })), { permissive: true });
        // Manual parsing of flags to allow for special flags like oneOf(Boolean, String)
        for (var i = result['_'].length - 1; i >= 0; --i) {
            var flag = result['_'][i];
            if (!flag.startsWith('-'))
                continue;
            var _a = flag.split('='), flagName = _a[0], flagValue = _a[1];
            var handler = flags[flagName];
            // Resolve flagName & handler
            while (typeof handler === 'string') {
                flagName = handler;
                handler = flags[handler];
            }
            if (!handler)
                continue;
            var args_1 = [];
            var offset = i + 1;
            // --flag value syntax was used so we need to pull `value` from `args`
            if (flagValue === undefined) {
                // Parse args for current flag
                while (result['_'][offset] && !result['_'][offset].startsWith('-')) {
                    args_1.push(result['_'][offset++]);
                }
                // Cleanup manually parsed flags + args
                result['_'].splice(i, 1 + args_1.length);
                // No args were provided, use default value defined in handler
                // One arg was provided, use that directly
                // Multiple args were provided so pass them all in an array
                flagValue = args_1.length === 0 ? undefined : args_1.length === 1 ? args_1[0] : args_1;
            }
            else {
                // Remove the whole flag from the args array
                result['_'].splice(i, 1);
            }
            // Set the resolved value in the `result` object
            result[flagName] = handler.type(flagValue, flagName);
        }
        // Ensure that the `command` is always the first argument in the `args`.
        // This is important so that we don't have to check if a default command
        // (build) was used or not from within each plugin.
        //
        // E.g.: tailwindcss input.css -> _: ['build', 'input.css']
        // E.g.: tailwindcss build input.css -> _: ['build', 'input.css']
        if (result['_'][0] !== command) {
            result['_'].unshift(command);
        }
        return result;
    }
    catch (err) {
        if (err.code === 'ARG_UNKNOWN_OPTION') {
            help_1.help({
                message: err.message,
                usage: ['tailwindcss <command> [options]'],
                options: sharedFlags
            });
            process.exit(1);
        }
        throw err;
    }
})();
if (args['--help']) {
    help_1.help({
        options: __assign(__assign({}, flags), sharedFlags),
        usage: ["tailwindcss " + command + " [options]"]
    });
    process.exit(0);
}
run(args);
