"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
exports.__esModule = true;
exports.createProcessor = void 0;
var path_1 = require("path");
var fs_1 = require("fs");
var postcss_load_config_1 = require("postcss-load-config");
var lilconfig_1 = require("lilconfig");
var plugins_1 = require("postcss-load-config/src/plugins"); // Little bit scary, looking at private/internal API
var options_1 = require("postcss-load-config/src/options"); // Little bit scary, looking at private/internal API
var processTailwindFeatures_1 = require("../../../processTailwindFeatures");
var deps_1 = require("./deps");
var utils_1 = require("./utils");
var sharedState_1 = require("../../../lib/sharedState");
var resolveConfig_1 = require("../../../../resolveConfig");
var content_1 = require("../../../lib/content");
var watching_1 = require("./watching");
var fast_glob_1 = require("fast-glob");
var findAtConfigPath_1 = require("../../../lib/findAtConfigPath");
var log_1 = require("../../../util/log");
var load_config_1 = require("../../../lib/load-config");
var getModuleDependencies_1 = require("../../../lib/getModuleDependencies");
/**
 *
 * @param {string} [customPostCssPath ]
 * @returns
 */
function loadPostCssPlugins(customPostCssPath) {
    return __awaiter(this, void 0, void 0, function () {
        var config, _a, configPlugins, configPluginTailwindIdx, beforePlugins, afterPlugins;
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!customPostCssPath) return [3 /*break*/, 2];
                    return [4 /*yield*/, (function () { return __awaiter(_this, void 0, void 0, function () {
                            var file, _a, config;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        file = path_1["default"].resolve(customPostCssPath);
                                        return [4 /*yield*/, lilconfig_1.lilconfig('postcss').load(file)];
                                    case 1:
                                        _a = (_b.sent()).config, config = _a === void 0 ? {} : _a;
                                        if (typeof config === 'function') {
                                            config = config();
                                        }
                                        else {
                                            config = Object.assign({}, config);
                                        }
                                        if (!config.plugins) {
                                            config.plugins = [];
                                        }
                                        return [2 /*return*/, {
                                                file: file,
                                                plugins: plugins_1["default"](config, file),
                                                options: options_1["default"](config, file)
                                            }];
                                }
                            });
                        }); })()];
                case 1:
                    _a = _b.sent();
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, postcss_load_config_1["default"]()];
                case 3:
                    _a = _b.sent();
                    _b.label = 4;
                case 4:
                    config = _a;
                    configPlugins = config.plugins;
                    configPluginTailwindIdx = configPlugins.findIndex(function (plugin) {
                        if (typeof plugin === 'function' && plugin.name === 'tailwindcss') {
                            return true;
                        }
                        if (typeof plugin === 'object' && plugin !== null && plugin.postcssPlugin === 'tailwindcss') {
                            return true;
                        }
                        return false;
                    });
                    beforePlugins = configPluginTailwindIdx === -1 ? [] : configPlugins.slice(0, configPluginTailwindIdx);
                    afterPlugins = configPluginTailwindIdx === -1
                        ? configPlugins
                        : configPlugins.slice(configPluginTailwindIdx + 1);
                    return [2 /*return*/, [beforePlugins, afterPlugins, config.options]];
            }
        });
    });
}
function loadBuiltinPostcssPlugins() {
    var postcss = deps_1.loadPostcss();
    var IMPORT_COMMENT = '__TAILWIND_RESTORE_IMPORT__: ';
    return [
        [
            function (root) {
                root.walkAtRules('import', function (rule) {
                    if (rule.params.slice(1).startsWith('tailwindcss/')) {
                        rule.after(postcss.comment({ text: IMPORT_COMMENT + rule.params }));
                        rule.remove();
                    }
                });
            },
            deps_1.loadPostcssImport(),
            function (root) {
                root.walkComments(function (rule) {
                    if (rule.text.startsWith(IMPORT_COMMENT)) {
                        rule.after(postcss.atRule({
                            name: 'import',
                            params: rule.text.replace(IMPORT_COMMENT, '')
                        }));
                        rule.remove();
                    }
                });
            },
        ],
        [],
        {},
    ];
}
var state = {
    /** @type {any} */
    context: null,
    /** @type {ReturnType<typeof createWatcher> | null} */
    watcher: null,
    /** @type {{content: string, extension: string}[]} */
    changedContent: [],
    /** @type {{config: Config, dependencies: Set<string>, dispose: Function } | null} */
    configBag: null,
    contextDependencies: new Set(),
    /** @type {import('../../lib/content.js').ContentPath[]} */
    contentPaths: [],
    refreshContentPaths: function () {
        var _a;
        this.contentPaths = content_1.parseCandidateFiles(this.context, (_a = this.context) === null || _a === void 0 ? void 0 : _a.tailwindConfig);
    },
    get config() {
        return this.context.tailwindConfig;
    },
    get contentPatterns() {
        return {
            all: this.contentPaths.map(function (contentPath) { return contentPath.pattern; }),
            dynamic: this.contentPaths
                .filter(function (contentPath) { return contentPath.glob !== undefined; })
                .map(function (contentPath) { return contentPath.pattern; })
        };
    },
    loadConfig: function (configPath, content) {
        if (this.watcher && configPath) {
            this.refreshConfigDependencies();
        }
        var config = load_config_1.loadConfig(configPath);
        var dependencies = getModuleDependencies_1["default"](configPath);
        this.configBag = {
            config: config,
            dependencies: dependencies,
            dispose: function () {
                for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
                    var file = dependencies_1[_i];
                    delete require.cache[require.resolve(file)];
                }
            }
        };
        // @ts-ignore
        this.configBag.config = resolveConfig_1["default"](this.configBag.config, { content: { files: [] } });
        // Override content files if `--content` has been passed explicitly
        if ((content === null || content === void 0 ? void 0 : content.length) > 0) {
            this.configBag.config.content.files = content;
        }
        return this.configBag.config;
    },
    refreshConfigDependencies: function (configPath) {
        var _a;
        sharedState_1.env.DEBUG && console.time('Module dependencies');
        (_a = this.configBag) === null || _a === void 0 ? void 0 : _a.dispose();
        sharedState_1.env.DEBUG && console.timeEnd('Module dependencies');
    },
    readContentPaths: function () {
        var content = [];
        // Resolve globs from the content config
        // TODO: When we make the postcss plugin async-capable this can become async
        var files = fast_glob_1["default"].sync(this.contentPatterns.all);
        for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
            var file = files_1[_i];
            if (__OXIDE__) {
                content.push({
                    file: file,
                    extension: path_1["default"].extname(file).slice(1)
                });
            }
            else {
                content.push({
                    content: fs_1["default"].readFileSync(path_1["default"].resolve(file), 'utf8'),
                    extension: path_1["default"].extname(file).slice(1)
                });
            }
        }
        // Resolve raw content in the tailwind config
        var rawContent = this.config.content.files.filter(function (file) {
            return file !== null && typeof file === 'object';
        });
        for (var _a = 0, rawContent_1 = rawContent; _a < rawContent_1.length; _a++) {
            var _b = rawContent_1[_a], htmlContent = _b.raw, _c = _b.extension, extension = _c === void 0 ? 'html' : _c;
            content.push({ content: htmlContent, extension: extension });
        }
        return content;
    },
    getContext: function (_a) {
        var _b;
        var createContext = _a.createContext, cliConfigPath = _a.cliConfigPath, root = _a.root, result = _a.result, content = _a.content;
        if (this.context) {
            this.context.changedContent = this.changedContent.splice(0);
            return this.context;
        }
        sharedState_1.env.DEBUG && console.time('Searching for config');
        var configPath = (_b = findAtConfigPath_1.findAtConfigPath(root, result)) !== null && _b !== void 0 ? _b : cliConfigPath;
        sharedState_1.env.DEBUG && console.timeEnd('Searching for config');
        sharedState_1.env.DEBUG && console.time('Loading config');
        var config = this.loadConfig(configPath, content);
        sharedState_1.env.DEBUG && console.timeEnd('Loading config');
        sharedState_1.env.DEBUG && console.time('Creating context');
        this.context = createContext(config, []);
        Object.assign(this.context, {
            userConfigPath: configPath
        });
        sharedState_1.env.DEBUG && console.timeEnd('Creating context');
        sharedState_1.env.DEBUG && console.time('Resolving content paths');
        this.refreshContentPaths();
        sharedState_1.env.DEBUG && console.timeEnd('Resolving content paths');
        if (this.watcher) {
            sharedState_1.env.DEBUG && console.time('Watch new files');
            this.watcher.refreshWatchedFiles();
            sharedState_1.env.DEBUG && console.timeEnd('Watch new files');
        }
        for (var _i = 0, _c = this.readContentPaths(); _i < _c.length; _i++) {
            var file = _c[_i];
            this.context.changedContent.push(file);
        }
        return this.context;
    }
};
function createProcessor(args, cliConfigPath) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function () {
        function readInput() {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    // Piping in data, let's drain the stdin
                    if (input === '-') {
                        return [2 /*return*/, utils_1.drainStdin()];
                    }
                    // Input file has been provided
                    if (input) {
                        return [2 /*return*/, fs_1["default"].promises.readFile(path_1["default"].resolve(input), 'utf8')];
                    }
                    // No input file provided, fallback to default atrules
                    return [2 /*return*/, '@tailwind base; @tailwind components; @tailwind utilities'];
                });
            });
        }
        function build() {
            return __awaiter(this, void 0, void 0, function () {
                var start;
                return __generator(this, function (_a) {
                    start = process.hrtime.bigint();
                    return [2 /*return*/, readInput()
                            .then(function (css) { return processor.process(css, __assign(__assign({}, postcssOptions), { from: input, to: output })); })
                            .then(function (result) { return deps_1.lightningcss(!!args['--minify'], result); })
                            .then(function (result) {
                            if (!state.watcher) {
                                return result;
                            }
                            sharedState_1.env.DEBUG && console.time('Recording PostCSS dependencies');
                            for (var _i = 0, _a = result.messages; _i < _a.length; _i++) {
                                var message = _a[_i];
                                if (message.type === 'dependency') {
                                    state.contextDependencies.add(message.file);
                                }
                            }
                            sharedState_1.env.DEBUG && console.timeEnd('Recording PostCSS dependencies');
                            // TODO: This needs to be in a different spot
                            sharedState_1.env.DEBUG && console.time('Watch new files');
                            state.watcher.refreshWatchedFiles();
                            sharedState_1.env.DEBUG && console.timeEnd('Watch new files');
                            return result;
                        })
                            .then(function (result) {
                            if (!output) {
                                process.stdout.write(result.css);
                                return;
                            }
                            return Promise.all([
                                utils_1.outputFile(result.opts.to, result.css),
                                result.map && utils_1.outputFile(result.opts.to + '.map', result.map.toString()),
                            ]);
                        })
                            .then(function () {
                            var end = process.hrtime.bigint();
                            console.error();
                            console.error('Done in', (end - start) / BigInt(1e6) + 'ms.');
                        })
                            .then(function () { }, function (err) {
                            // TODO: If an initial build fails we can't easily pick up any PostCSS dependencies
                            // that were collected before the error occurred
                            // The result is not stored on the error so we have to store it externally
                            // and pull the messages off of it here somehow
                            // This results in a less than ideal DX because the watcher will not pick up
                            // changes to imported CSS if one of them caused an error during the initial build
                            // If you fix it and then save the main CSS file so there's no error
                            // The watcher will start watching the imported CSS files and will be
                            // resilient to future errors.
                            if (state.watcher) {
                                console.error(err);
                            }
                            else {
                                return Promise.reject(err);
                            }
                        })];
                });
            });
        }
        /**
         * @param {{file: string, content(): Promise<string>, extension: string}[]} changes
         */
        function parseChanges(changes) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, Promise.all(changes.map(function (change) { return __awaiter(_this, void 0, void 0, function () {
                            var _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _a = {};
                                        return [4 /*yield*/, change.content()];
                                    case 1: return [2 /*return*/, (_a.content = _b.sent(),
                                            _a.extension = change.extension,
                                            _a)];
                                }
                            });
                        }); }))];
                });
            });
        }
        var postcss, input, output, includePostCss, customPostCssPath, _c, beforePlugins, afterPlugins, postcssOptions, _d, content, tailwindPlugin, plugins, processor;
        var _this = this;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    postcss = deps_1.loadPostcss();
                    input = args['--input'];
                    output = args['--output'];
                    includePostCss = args['--postcss'];
                    customPostCssPath = typeof args['--postcss'] === 'string' ? args['--postcss'] : undefined;
                    if (!includePostCss) return [3 /*break*/, 2];
                    return [4 /*yield*/, loadPostCssPlugins(customPostCssPath)];
                case 1:
                    _d = _e.sent();
                    return [3 /*break*/, 3];
                case 2:
                    _d = loadBuiltinPostcssPlugins();
                    _e.label = 3;
                case 3:
                    _c = _d, beforePlugins = _c[0], afterPlugins = _c[1], postcssOptions = _c[2];
                    if (args['--purge']) {
                        log_1["default"].warn('purge-flag-deprecated', [
                            'The `--purge` flag has been deprecated.',
                            'Please use `--content` instead.',
                        ]);
                        if (!args['--content']) {
                            args['--content'] = args['--purge'];
                        }
                    }
                    content = (_b = (_a = args['--content']) === null || _a === void 0 ? void 0 : _a.split(/(?<!{[^}]+),/)) !== null && _b !== void 0 ? _b : [];
                    tailwindPlugin = function () {
                        return {
                            postcssPlugin: 'tailwindcss',
                            Once: function (root, _a) {
                                var result = _a.result;
                                return __awaiter(this, void 0, void 0, function () {
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0:
                                                sharedState_1.env.DEBUG && console.time('Compiling CSS');
                                                return [4 /*yield*/, processTailwindFeatures_1["default"](function (_a) {
                                                        var createContext = _a.createContext;
                                                        console.error();
                                                        console.error('Rebuilding...');
                                                        return function () {
                                                            return state.getContext({
                                                                createContext: createContext,
                                                                cliConfigPath: cliConfigPath,
                                                                root: root,
                                                                result: result,
                                                                content: content
                                                            });
                                                        };
                                                    })(root, result)];
                                            case 1:
                                                _b.sent();
                                                sharedState_1.env.DEBUG && console.timeEnd('Compiling CSS');
                                                return [2 /*return*/];
                                        }
                                    });
                                });
                            }
                        };
                    };
                    tailwindPlugin.postcss = true;
                    plugins = __spreadArrays(beforePlugins, [
                        tailwindPlugin,
                        !args['--minify'] && utils_1.formatNodes
                    ], afterPlugins).filter(Boolean);
                    processor = postcss(plugins);
                    if (input !== undefined && input !== '-') {
                        state.contextDependencies.add(path_1["default"].resolve(input));
                    }
                    return [2 /*return*/, {
                            build: build,
                            watch: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            state.watcher = watching_1.createWatcher(args, {
                                                state: state,
                                                /**
                                                 * @param {{file: string, content(): Promise<string>, extension: string}[]} changes
                                                 */
                                                rebuild: function (changes) {
                                                    return __awaiter(this, void 0, void 0, function () {
                                                        var needsNewContext, _i, _a, change;
                                                        return __generator(this, function (_b) {
                                                            switch (_b.label) {
                                                                case 0:
                                                                    needsNewContext = changes.some(function (change) {
                                                                        var _a;
                                                                        return (((_a = state.configBag) === null || _a === void 0 ? void 0 : _a.dependencies.has(change.file)) ||
                                                                            state.contextDependencies.has(change.file));
                                                                    });
                                                                    if (!needsNewContext) return [3 /*break*/, 1];
                                                                    state.context = null;
                                                                    return [3 /*break*/, 5];
                                                                case 1:
                                                                    _i = 0;
                                                                    return [4 /*yield*/, parseChanges(changes)];
                                                                case 2:
                                                                    _a = _b.sent();
                                                                    _b.label = 3;
                                                                case 3:
                                                                    if (!(_i < _a.length)) return [3 /*break*/, 5];
                                                                    change = _a[_i];
                                                                    state.changedContent.push(change);
                                                                    _b.label = 4;
                                                                case 4:
                                                                    _i++;
                                                                    return [3 /*break*/, 3];
                                                                case 5: return [2 /*return*/, build()];
                                                            }
                                                        });
                                                    });
                                                }
                                            });
                                            return [4 /*yield*/, build()];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); }
                        }];
            }
        });
    });
}
exports.createProcessor = createProcessor;
