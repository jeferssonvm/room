"use strict";

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(_getModuleDependencies);

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return getModuleDependencies;
  }
});

var _fs =
/*#__PURE__*/
_interop_require_default(require("fs"));

var _path =
/*#__PURE__*/
_interop_require_default(require("path"));

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var jsExtensions = [".js", ".cjs", ".mjs"]; // Given the current file `a.ts`, we want to make sure that when importing `b` that we resolve
// `b.ts` before `b.js`
//
// E.g.:
//
// a.ts
//   b // .ts
//   c // .ts
// a.js
//   b // .js or .ts

var jsResolutionOrder = ["", ".js", ".cjs", ".mjs", ".ts", ".cts", ".mts", ".jsx", ".tsx"];
var tsResolutionOrder = ["", ".ts", ".cts", ".mts", ".tsx", ".js", ".cjs", ".mjs", ".jsx"];

function resolveWithExtension(file, extensions) {
  // Try to find `./a.ts`, `./a.ts`, ... from `./a`
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var ext = _step.value;
      var full = "".concat(file).concat(ext);

      if (_fs["default"].existsSync(full) && _fs["default"].statSync(full).isFile()) {
        return full;
      }
    } // Try to find `./a/index.js` from `./a`

  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _ext = _step2.value;

      var _full = "".concat(file, "/index").concat(_ext);

      if (_fs["default"].existsSync(_full)) {
        return _full;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return null;
}

function _getModuleDependencies(filename, base, seen) {
  var ext,
      absoluteFile,
      contents,
      _i,
      _arr,
      match,
      _args = arguments;

  return regeneratorRuntime.wrap(function _getModuleDependencies$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          ext = _args.length > 3 && _args[3] !== undefined ? _args[3] : _path["default"].extname(filename);
          // Try to find the file
          absoluteFile = resolveWithExtension(_path["default"].resolve(base, filename), jsExtensions.includes(ext) ? jsResolutionOrder : tsResolutionOrder);

          if (!(absoluteFile === null)) {
            _context.next = 4;
            break;
          }

          return _context.abrupt("return");

        case 4:
          if (!seen.has(absoluteFile)) {
            _context.next = 6;
            break;
          }

          return _context.abrupt("return");

        case 6:
          // Already seen
          seen.add(absoluteFile); // Mark the file as a dependency

          _context.next = 9;
          return absoluteFile;

        case 9:
          // Resolve new base for new imports/requires
          base = _path["default"].dirname(absoluteFile);
          ext = _path["default"].extname(absoluteFile);
          contents = _fs["default"].readFileSync(absoluteFile, "utf-8"); // Find imports/requires

          _i = 0, _arr = [].concat(_toConsumableArray(contents.matchAll(/import[\s\S]*?['"](.{3,}?)['"]/gi)), _toConsumableArray(contents.matchAll(/import[\s\S]*from[\s\S]*?['"](.{3,}?)['"]/gi)), _toConsumableArray(contents.matchAll(/require\(['"`](.+)['"`]\)/gi)));

        case 13:
          if (!(_i < _arr.length)) {
            _context.next = 21;
            break;
          }

          match = _arr[_i];

          if (match[1].startsWith(".")) {
            _context.next = 17;
            break;
          }

          return _context.abrupt("continue", 18);

        case 17:
          return _context.delegateYield(_getModuleDependencies(match[1], base, seen, ext), "t0", 18);

        case 18:
          _i++;
          _context.next = 13;
          break;

        case 21:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

function getModuleDependencies(absoluteFilePath) {
  if (absoluteFilePath === null) return new Set();
  return new Set(_getModuleDependencies(absoluteFilePath, _path["default"].dirname(absoluteFilePath), new Set()));
}