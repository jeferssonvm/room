"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return expandTailwindAtRules;
  }
});

var _fs =
/*#__PURE__*/
_interop_require_default(require("fs"));

var _quicklru =
/*#__PURE__*/
_interop_require_default(require("@alloc/quick-lru"));

var _sharedState =
/*#__PURE__*/
_interop_require_wildcard(require("./sharedState"));

var _generateRules = require("./generateRules");

var _log =
/*#__PURE__*/
_interop_require_default(require("../util/log"));

var _cloneNodes =
/*#__PURE__*/
_interop_require_default(require("../util/cloneNodes"));

var _defaultExtractor = require("./defaultExtractor");

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interop_require_wildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var env = _sharedState.env;
var builtInExtractors = {
  DEFAULT: _defaultExtractor.defaultExtractor
};
var builtInTransformers = {
  DEFAULT: function DEFAULT(content) {
    return content;
  },
  svelte: function svelte(content) {
    return content.replace(/(?:^|\s)class:/g, " ");
  }
};

function getExtractor(context, fileExtension) {
  var extractors = context.tailwindConfig.content.extract;
  return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);
}

function getTransformer(tailwindConfig, fileExtension) {
  var transformers = tailwindConfig.content.transform;
  return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;
}

var extractorCache = new WeakMap(); // Scans template contents for possible classes. This is a hot path on initial build but
// not too important for subsequent builds. The faster the better though â€” if we can speed
// up these regexes by 50% that could cut initial build time by like 20%.

function getClassCandidates(content, extractor, candidates, seen) {
  if (!extractorCache.has(extractor)) {
    extractorCache.set(extractor, new _quicklru["default"]({
      maxSize: 25000
    }));
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = content.split("\n")[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;
      line = line.trim();

      if (seen.has(line)) {
        continue;
      }

      seen.add(line);

      if (extractorCache.get(extractor).has(line)) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = extractorCache.get(extractor).get(line)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var match = _step2.value;
            candidates.add(match);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      } else {
        var extractorMatches = extractor(line).filter(function (s) {
          return s !== "!*";
        });
        var lineMatchesSet = new Set(extractorMatches);
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = lineMatchesSet[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _match = _step3.value;
            candidates.add(_match);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        extractorCache.get(extractor).set(line, lineMatchesSet);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}
/**
 *
 * @param {[import('./offsets.js').RuleOffset, import('postcss').Node][]} rules
 * @param {*} context
 */


function buildStylesheet(rules, context) {
  var sortedRules = context.offsets.sort(rules);
  var returnValue = {
    base: new Set(),
    defaults: new Set(),
    components: new Set(),
    utilities: new Set(),
    variants: new Set()
  };
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = sortedRules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var _step4$value = _slicedToArray(_step4.value, 2),
          sort = _step4$value[0],
          rule = _step4$value[1];

      returnValue[sort.layer].add(rule);
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  return returnValue;
}

function expandTailwindAtRules(context) {
  return function _callee2(root) {
    var layerNodes, _context_candidates, candidates, seen, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, candidate, regexParserContent, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, item, transformer, extractor, BATCH_SIZE, i, batch, classCacheCount, sortedCandidates, _context$stylesheetCa, defaultNodes, baseNodes, componentNodes, utilityNodes, screenNodes, variantNodes, hasUtilityVariants;

    return regeneratorRuntime.async(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            layerNodes = {
              base: null,
              components: null,
              utilities: null,
              variants: null
            };
            root.walkAtRules(function (rule) {
              // Make sure this file contains Tailwind directives. If not, we can save
              // a lot of work and bail early. Also we don't have to register our touch
              // file as a dependency since the output of this CSS does not depend on
              // the source of any templates. Think Vue <style> blocks for example.
              if (rule.name === "tailwind") {
                if (Object.keys(layerNodes).includes(rule.params)) {
                  layerNodes[rule.params] = rule;
                }
              }
            });

            if (!Object.values(layerNodes).every(function (n) {
              return n === null;
            })) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", root);

          case 4:
            // ---
            // Find potential rules in changed files
            candidates = new Set([].concat(_toConsumableArray((_context_candidates = context.candidates) !== null && _context_candidates !== void 0 ? _context_candidates : []), [_sharedState.NOT_ON_DEMAND]));
            seen = new Set();
            env.DEBUG && console.time("Reading changed files");

            if (!false) {
              _context2.next = 29;
              break;
            }

            // TODO: Pass through or implement `extractor`
            _iteratorNormalCompletion5 = true;
            _didIteratorError5 = false;
            _iteratorError5 = undefined;
            _context2.prev = 11;

            for (_iterator5 = require("@tailwindcss/oxide").parseCandidateStringsFromFiles(context.changedContent)[Symbol.iterator](); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              candidate = _step5.value;
              candidates.add(candidate);
            } // for (let { file, content, extension } of context.changedContent) {
            //   let transformer = getTransformer(context.tailwindConfig, extension)
            //   let extractor = getExtractor(context, extension)
            //   getClassCandidatesOxide(file, transformer(content), extractor, candidates, seen)
            // }


            _context2.next = 19;
            break;

          case 15:
            _context2.prev = 15;
            _context2.t0 = _context2["catch"](11);
            _didIteratorError5 = true;
            _iteratorError5 = _context2.t0;

          case 19:
            _context2.prev = 19;
            _context2.prev = 20;

            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }

          case 22:
            _context2.prev = 22;

            if (!_didIteratorError5) {
              _context2.next = 25;
              break;
            }

            throw _iteratorError5;

          case 25:
            return _context2.finish(22);

          case 26:
            return _context2.finish(19);

          case 27:
            _context2.next = 58;
            break;

          case 29:
            /** @type {[item: {file?: string, content?: string}, meta: {transformer: any, extractor: any}][]} */
            regexParserContent = [];
            _iteratorNormalCompletion6 = true;
            _didIteratorError6 = false;
            _iteratorError6 = undefined;
            _context2.prev = 33;

            for (_iterator6 = context.changedContent[Symbol.iterator](); !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              item = _step6.value;
              transformer = getTransformer(context.tailwindConfig, item.extension);
              extractor = getExtractor(context, item.extension);
              regexParserContent.push([item, {
                transformer: transformer,
                extractor: extractor
              }]);
            }

            _context2.next = 41;
            break;

          case 37:
            _context2.prev = 37;
            _context2.t1 = _context2["catch"](33);
            _didIteratorError6 = true;
            _iteratorError6 = _context2.t1;

          case 41:
            _context2.prev = 41;
            _context2.prev = 42;

            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }

          case 44:
            _context2.prev = 44;

            if (!_didIteratorError6) {
              _context2.next = 47;
              break;
            }

            throw _iteratorError6;

          case 47:
            return _context2.finish(44);

          case 48:
            return _context2.finish(41);

          case 49:
            BATCH_SIZE = 500;
            i = 0;

          case 51:
            if (!(i < regexParserContent.length)) {
              _context2.next = 58;
              break;
            }

            batch = regexParserContent.slice(i, i + BATCH_SIZE);
            _context2.next = 55;
            return regeneratorRuntime.awrap(Promise.all(batch.map(function _callee(_ref) {
              var _ref2, _ref2$, file, content, _ref2$2, transformer, extractor;

              return regeneratorRuntime.async(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], file = _ref2$.file, content = _ref2$.content, _ref2$2 = _ref2[1], transformer = _ref2$2.transformer, extractor = _ref2$2.extractor;

                      if (!file) {
                        _context.next = 7;
                        break;
                      }

                      _context.next = 4;
                      return regeneratorRuntime.awrap(_fs["default"].promises.readFile(file, "utf8"));

                    case 4:
                      _context.t0 = _context.sent;
                      _context.next = 8;
                      break;

                    case 7:
                      _context.t0 = content;

                    case 8:
                      content = _context.t0;
                      getClassCandidates(transformer(content), extractor, candidates, seen);

                    case 10:
                    case "end":
                      return _context.stop();
                  }
                }
              });
            })));

          case 55:
            i += BATCH_SIZE;
            _context2.next = 51;
            break;

          case 58:
            env.DEBUG && console.timeEnd("Reading changed files"); // ---
            // Generate the actual CSS

            classCacheCount = context.classCache.size;
            env.DEBUG && console.time("Generate rules");
            env.DEBUG && console.time("Sorting candidates");
            sortedCandidates = false ? candidates : new Set(_toConsumableArray(candidates).sort(function (a, z) {
              if (a === z) return 0;
              if (a < z) return -1;
              return 1;
            }));
            env.DEBUG && console.timeEnd("Sorting candidates");
            (0, _generateRules.generateRules)(sortedCandidates, context);
            env.DEBUG && console.timeEnd("Generate rules"); // We only ever add to the classCache, so if it didn't grow, there is nothing new.

            env.DEBUG && console.time("Build stylesheet");

            if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {
              context.stylesheetCache = buildStylesheet(_toConsumableArray(context.ruleCache), context);
            }

            env.DEBUG && console.timeEnd("Build stylesheet");
            _context$stylesheetCa = context.stylesheetCache, defaultNodes = _context$stylesheetCa.defaults, baseNodes = _context$stylesheetCa.base, componentNodes = _context$stylesheetCa.components, utilityNodes = _context$stylesheetCa.utilities, screenNodes = _context$stylesheetCa.variants; // ---
            // Replace any Tailwind directives with generated CSS

            if (layerNodes.base) {
              layerNodes.base.before((0, _cloneNodes["default"])([].concat(_toConsumableArray(baseNodes), _toConsumableArray(defaultNodes)), layerNodes.base.source, {
                layer: "base"
              }));
              layerNodes.base.remove();
            }

            if (layerNodes.components) {
              layerNodes.components.before((0, _cloneNodes["default"])(_toConsumableArray(componentNodes), layerNodes.components.source, {
                layer: "components"
              }));
              layerNodes.components.remove();
            }

            if (layerNodes.utilities) {
              layerNodes.utilities.before((0, _cloneNodes["default"])(_toConsumableArray(utilityNodes), layerNodes.utilities.source, {
                layer: "utilities"
              }));
              layerNodes.utilities.remove();
            } // We do post-filtering to not alter the emitted order of the variants


            variantNodes = Array.from(screenNodes).filter(function (node) {
              var _node_raws_tailwind;

              var parentLayer = (_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer;

              if (parentLayer === "components") {
                return layerNodes.components !== null;
              }

              if (parentLayer === "utilities") {
                return layerNodes.utilities !== null;
              }

              return true;
            });

            if (layerNodes.variants) {
              layerNodes.variants.before((0, _cloneNodes["default"])(variantNodes, layerNodes.variants.source, {
                layer: "variants"
              }));
              layerNodes.variants.remove();
            } else if (variantNodes.length > 0) {
              root.append((0, _cloneNodes["default"])(variantNodes, root.source, {
                layer: "variants"
              }));
            } // If we've got a utility layer and no utilities are generated there's likely something wrong


            hasUtilityVariants = variantNodes.some(function (node) {
              var _node_raws_tailwind;

              return ((_node_raws_tailwind = node.raws.tailwind) === null || _node_raws_tailwind === void 0 ? void 0 : _node_raws_tailwind.parentLayer) === "utilities";
            });

            if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {
              _log["default"].warn("content-problems", ["No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.", "https://tailwindcss.com/docs/content-configuration"]);
            } // ---


            if (env.DEBUG) {
              console.log("Potential classes: ", candidates.size);
              console.log("Active contexts: ", _sharedState.contextSourcesMap.size);
            } // Clear the cache for the changed files


            context.changedContent = []; // Cleanup any leftover @layer atrules

            root.walkAtRules("layer", function (rule) {
              if (Object.keys(layerNodes).includes(rule.params)) {
                rule.remove();
              }
            });

          case 80:
          case "end":
            return _context2.stop();
        }
      }
    }, null, null, [[11, 15, 19, 27], [20,, 22, 26], [33, 37, 41, 49], [42,, 44, 48]]);
  };
}