"use strict";

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(toPaths);

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return _default;
  }
});

var _dlv =
/*#__PURE__*/
_interop_require_default(require("dlv"));

var _didyoumean =
/*#__PURE__*/
_interop_require_default(require("didyoumean"));

var _transformThemeValue =
/*#__PURE__*/
_interop_require_default(require("../util/transformThemeValue"));

var _index =
/*#__PURE__*/
_interop_require_default(require("../value-parser/index"));

var _normalizeScreens = require("../util/normalizeScreens");

var _buildMediaQuery =
/*#__PURE__*/
_interop_require_default(require("../util/buildMediaQuery"));

var _toPath = require("../util/toPath");

var _withAlphaVariable = require("../util/withAlphaVariable");

var _pluginUtils = require("../util/pluginUtils");

var _log =
/*#__PURE__*/
_interop_require_default(require("../util/log"));

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function isObject(input) {
  return _typeof(input) === "object" && input !== null;
}

function findClosestExistingPath(theme, path) {
  var parts = (0, _toPath.toPath)(path);

  do {
    parts.pop();
    if ((0, _dlv["default"])(theme, parts) !== undefined) break;
  } while (parts.length);

  return parts.length ? parts : undefined;
}

function pathToString(path) {
  if (typeof path === "string") return path;
  return path.reduce(function (acc, cur, i) {
    if (cur.includes(".")) return "".concat(acc, "[").concat(cur, "]");
    return i === 0 ? cur : "".concat(acc, ".").concat(cur);
  }, "");
}

function list(items) {
  return items.map(function (key) {
    return "'".concat(key, "'");
  }).join(", ");
}

function listKeys(obj) {
  return list(Object.keys(obj));
}

function validatePath(config, path, defaultValue) {
  var themeOpts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var pathString = Array.isArray(path) ? pathToString(path) : path.replace(/^['"]+|['"]+$/g, "");
  var pathSegments = Array.isArray(path) ? path : (0, _toPath.toPath)(pathString);
  var value = (0, _dlv["default"])(config.theme, pathSegments, defaultValue);

  if (value === undefined) {
    var error = "'".concat(pathString, "' does not exist in your theme config.");
    var parentSegments = pathSegments.slice(0, -1);
    var parentValue = (0, _dlv["default"])(config.theme, parentSegments);

    if (isObject(parentValue)) {
      var validKeys = Object.keys(parentValue).filter(function (key) {
        return validatePath(config, [].concat(_toConsumableArray(parentSegments), [key])).isValid;
      });
      var suggestion = (0, _didyoumean["default"])(pathSegments[pathSegments.length - 1], validKeys);

      if (suggestion) {
        error += " Did you mean '".concat(pathToString([].concat(_toConsumableArray(parentSegments), [suggestion])), "'?");
      } else if (validKeys.length > 0) {
        error += " '".concat(pathToString(parentSegments), "' has the following valid keys: ").concat(list(validKeys));
      }
    } else {
      var closestPath = findClosestExistingPath(config.theme, pathString);

      if (closestPath) {
        var closestValue = (0, _dlv["default"])(config.theme, closestPath);

        if (isObject(closestValue)) {
          error += " '".concat(pathToString(closestPath), "' has the following keys: ").concat(listKeys(closestValue));
        } else {
          error += " '".concat(pathToString(closestPath), "' is not an object.");
        }
      } else {
        error += " Your theme has the following top-level keys: ".concat(listKeys(config.theme));
      }
    }

    return {
      isValid: false,
      error: error
    };
  }

  if (!(typeof value === "string" || typeof value === "number" || typeof value === "function" || value instanceof String || value instanceof Number || Array.isArray(value))) {
    var _error = "'".concat(pathString, "' was found but does not resolve to a string.");

    if (isObject(value)) {
      var _validKeys = Object.keys(value).filter(function (key) {
        return validatePath(config, [].concat(_toConsumableArray(pathSegments), [key])).isValid;
      });

      if (_validKeys.length) {
        _error += " Did you mean something like '".concat(pathToString([].concat(_toConsumableArray(pathSegments), [_validKeys[0]])), "'?");
      }
    }

    return {
      isValid: false,
      error: _error
    };
  }

  var _pathSegments = _slicedToArray(pathSegments, 1),
      themeSection = _pathSegments[0];

  return {
    isValid: true,
    value: (0, _transformThemeValue["default"])(themeSection)(value, themeOpts)
  };
}

function extractArgs(node, vNodes, functions) {
  vNodes = vNodes.map(function (vNode) {
    return resolveVNode(node, vNode, functions);
  });
  var args = [""];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = vNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var vNode = _step.value;

      if (vNode.type === "div" && vNode.value === ",") {
        args.push("");
      } else {
        args[args.length - 1] += _index["default"].stringify(vNode);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return args;
}

function resolveVNode(node, vNode, functions) {
  if (vNode.type === "function" && functions[vNode.value] !== undefined) {
    var args = extractArgs(node, vNode.nodes, functions);
    vNode.type = "word";
    vNode.value = functions[vNode.value].apply(functions, [node].concat(_toConsumableArray(args)));
  }

  return vNode;
}

function resolveFunctions(node, input, functions) {
  var hasAnyFn = Object.keys(functions).some(function (fn) {
    return input.includes("".concat(fn, "("));
  });
  if (!hasAnyFn) return input;
  return (0, _index["default"])(input).walk(function (vNode) {
    resolveVNode(node, vNode, functions);
  }).toString();
}

var nodeTypePropertyMap = {
  atrule: "params",
  decl: "value"
};
/**
 * @param {string} path
 * @returns {Iterable<[path: string, alpha: string|undefined]>}
 */

function toPaths(path) {
  var matches, alpha;
  return regeneratorRuntime.wrap(function toPaths$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          // Strip quotes from beginning and end of string
          // This allows the alpha value to be present inside of quotes
          path = path.replace(/^['"]+|['"]+$/g, "");
          matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/);
          alpha = undefined;
          _context.next = 5;
          return [path, undefined];

        case 5:
          if (!matches) {
            _context.next = 10;
            break;
          }

          path = matches[1];
          alpha = matches[2];
          _context.next = 10;
          return [path, alpha];

        case 10:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}
/**
 *
 * @param {any} config
 * @param {string} path
 * @param {any} defaultValue
 */


function resolvePath(config, path, defaultValue) {
  var results = Array.from(toPaths(path)).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        path = _ref2[0],
        alpha = _ref2[1];

    return Object.assign(validatePath(config, path, defaultValue, {
      opacityValue: alpha
    }), {
      resolvedPath: path,
      alpha: alpha
    });
  });

  var _results_find;

  return (_results_find = results.find(function (result) {
    return result.isValid;
  })) !== null && _results_find !== void 0 ? _results_find : results[0];
}

function _default(context) {
  var config = context.tailwindConfig;
  var functions = {
    theme: function theme(node, path) {
      for (var _len = arguments.length, defaultValue = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        defaultValue[_key - 2] = arguments[_key];
      }

      var _resolvePath = resolvePath(config, path, defaultValue.length ? defaultValue : undefined),
          isValid = _resolvePath.isValid,
          value = _resolvePath.value,
          error = _resolvePath.error,
          alpha = _resolvePath.alpha;

      if (!isValid) {
        var _parentNode_raws_tailwind;

        var parentNode = node.parent;
        var candidate = (_parentNode_raws_tailwind = parentNode === null || parentNode === void 0 ? void 0 : parentNode.raws.tailwind) === null || _parentNode_raws_tailwind === void 0 ? void 0 : _parentNode_raws_tailwind.candidate;

        if (parentNode && candidate !== undefined) {
          // Remove this utility from any caches
          context.markInvalidUtilityNode(parentNode); // Remove the CSS node from the markup

          parentNode.remove(); // Show a warning

          _log["default"].warn("invalid-theme-key-in-class", ["The utility `".concat(candidate, "` contains an invalid theme value and was not generated.")]);

          return;
        }

        throw node.error(error);
      }

      var maybeColor = (0, _pluginUtils.parseColorFormat)(value);
      var isColorFunction = maybeColor !== undefined && typeof maybeColor === "function";

      if (alpha !== undefined || isColorFunction) {
        if (alpha === undefined) {
          alpha = 1.0;
        }

        value = (0, _withAlphaVariable.withAlphaValue)(maybeColor, alpha, maybeColor);
      }

      return value;
    },
    screen: function screen(node, _screen) {
      _screen = _screen.replace(/^['"]+/g, "").replace(/['"]+$/g, "");
      var screens = (0, _normalizeScreens.normalizeScreens)(config.theme.screens);
      var screenDefinition = screens.find(function (_ref3) {
        var name = _ref3.name;
        return name === _screen;
      });

      if (!screenDefinition) {
        throw node.error("The '".concat(_screen, "' screen does not exist in your theme."));
      }

      return (0, _buildMediaQuery["default"])(screenDefinition);
    }
  };
  return function (root) {
    root.walk(function (node) {
      var property = nodeTypePropertyMap[node.type];

      if (property === undefined) {
        return;
      }

      node[property] = resolveFunctions(node, node[property], functions);
    });
  };
}