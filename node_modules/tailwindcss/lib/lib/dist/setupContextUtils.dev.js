"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _export(target, all) {
  for (var name in all) {
    Object.defineProperty(target, name, {
      enumerable: true,
      get: all[name]
    });
  }
}

_export(exports, {
  INTERNAL_FEATURES: function INTERNAL_FEATURES() {
    return _INTERNAL_FEATURES;
  },
  isValidVariantFormatString: function isValidVariantFormatString() {
    return _isValidVariantFormatString;
  },
  parseVariant: function parseVariant() {
    return _parseVariant;
  },
  getFileModifiedMap: function getFileModifiedMap() {
    return _getFileModifiedMap;
  },
  createContext: function createContext() {
    return _createContext;
  },
  getContext: function getContext() {
    return _getContext;
  }
});

var _fs =
/*#__PURE__*/
_interop_require_default(require("fs"));

var _url =
/*#__PURE__*/
_interop_require_default(require("url"));

var _postcss =
/*#__PURE__*/
_interop_require_default(require("postcss"));

var _dlv =
/*#__PURE__*/
_interop_require_default(require("dlv"));

var _postcssselectorparser =
/*#__PURE__*/
_interop_require_default(require("postcss-selector-parser"));

var _transformThemeValue =
/*#__PURE__*/
_interop_require_default(require("../util/transformThemeValue"));

var _parseObjectStyles =
/*#__PURE__*/
_interop_require_default(require("../util/parseObjectStyles"));

var _prefixSelector =
/*#__PURE__*/
_interop_require_default(require("../util/prefixSelector"));

var _isPlainObject =
/*#__PURE__*/
_interop_require_default(require("../util/isPlainObject"));

var _escapeClassName =
/*#__PURE__*/
_interop_require_default(require("../util/escapeClassName"));

var _nameClass =
/*#__PURE__*/
_interop_require_wildcard(require("../util/nameClass"));

var _pluginUtils = require("../util/pluginUtils");

var _corePlugins = require("../corePlugins");

var _sharedState =
/*#__PURE__*/
_interop_require_wildcard(require("./sharedState"));

var _toPath = require("../util/toPath");

var _log =
/*#__PURE__*/
_interop_require_default(require("../util/log"));

var _negateValue =
/*#__PURE__*/
_interop_require_default(require("../util/negateValue"));

var _isSyntacticallyValidPropertyValue =
/*#__PURE__*/
_interop_require_default(require("../util/isSyntacticallyValidPropertyValue"));

var _generateRules = require("./generateRules");

var _cacheInvalidation = require("./cacheInvalidation.js");

var _offsets = require("./offsets.js");

var _featureFlags = require("../featureFlags.js");

var _formatVariantSelector = require("../util/formatVariantSelector");

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interop_require_wildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var _INTERNAL_FEATURES = Symbol();

var VARIANT_TYPES = {
  AddVariant: Symbol["for"]("ADD_VARIANT"),
  MatchVariant: Symbol["for"]("MATCH_VARIANT")
};
var VARIANT_INFO = {
  Base: 1 << 0,
  Dynamic: 1 << 1
};

function prefix(context, selector) {
  var prefix = context.tailwindConfig.prefix;
  return typeof prefix === "function" ? prefix(selector) : prefix + selector;
}

function normalizeOptionTypes(_ref) {
  var _ref$type = _ref.type,
      type = _ref$type === void 0 ? "any" : _ref$type,
      options = _objectWithoutProperties(_ref, ["type"]);

  var types = [].concat(type);
  return _objectSpread({}, options, {
    types: types.map(function (type) {
      if (Array.isArray(type)) {
        return _objectSpread({
          type: type[0]
        }, type[1]);
      }

      return {
        type: type,
        preferOnConflict: false
      };
    })
  });
}

function parseVariantFormatString(input) {
  /** @type {string[]} */
  var parts = []; // When parsing whitespace around special characters are insignificant
  // However, _inside_ of a variant they could be
  // Because the selector could look like this
  // @media { &[data-name="foo bar"] }
  // This is why we do not skip whitespace

  var current = "";
  var depth = 0;

  for (var idx = 0; idx < input.length; idx++) {
    var _char = input[idx];

    if (_char === "\\") {
      // Escaped characters are not special
      current += "\\" + input[++idx];
    } else if (_char === "{") {
      // Nested rule: start
      ++depth;
      parts.push(current.trim());
      current = "";
    } else if (_char === "}") {
      // Nested rule: end
      if (--depth < 0) {
        throw new Error("Your { and } are unbalanced.");
      }

      parts.push(current.trim());
      current = "";
    } else {
      // Normal character
      current += _char;
    }
  }

  if (current.length > 0) {
    parts.push(current.trim());
  }

  parts = parts.filter(function (part) {
    return part !== "";
  });
  return parts;
}

function insertInto(list, value) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$before = _ref2.before,
      before = _ref2$before === void 0 ? [] : _ref2$before;

  before = [].concat(before);

  if (before.length <= 0) {
    list.push(value);
    return;
  }

  var idx = list.length - 1;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = before[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var other = _step.value;
      var iidx = list.indexOf(other);
      if (iidx === -1) continue;
      idx = Math.min(idx, iidx);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  list.splice(idx, 0, value);
}

function parseStyles(styles) {
  if (!Array.isArray(styles)) {
    return parseStyles([styles]);
  }

  return styles.flatMap(function (style) {
    var isNode = !Array.isArray(style) && !(0, _isPlainObject["default"])(style);
    return isNode ? style : (0, _parseObjectStyles["default"])(style);
  });
}

function getClasses(selector, mutate) {
  var parser = (0, _postcssselectorparser["default"])(function (selectors) {
    var allClasses = [];

    if (mutate) {
      mutate(selectors);
    }

    selectors.walkClasses(function (classNode) {
      allClasses.push(classNode.value);
    });
    return allClasses;
  });
  return parser.transformSync(selector);
}
/**
 * Ignore everything inside a :not(...). This allows you to write code like
 * `div:not(.foo)`. If `.foo` is never found in your code, then we used to
 * not generated it. But now we will ignore everything inside a `:not`, so
 * that it still gets generated.
 *
 * @param {selectorParser.Root} selectors
 */


function ignoreNot(selectors) {
  selectors.walkPseudos(function (pseudo) {
    if (pseudo.value === ":not") {
      pseudo.remove();
    }
  });
}

function extractCandidates(node) {
  var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    containsNonOnDemandable: false
  };
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var classes = [];
  var selectors = [];

  if (node.type === "rule") {
    // Handle normal rules
    selectors.push.apply(selectors, _toConsumableArray(node.selectors));
  } else if (node.type === "atrule") {
    // Handle at-rules (which contains nested rules)
    node.walkRules(function (rule) {
      return selectors.push.apply(selectors, _toConsumableArray(rule.selectors));
    });
  }

  for (var _i = 0, _selectors = selectors; _i < _selectors.length; _i++) {
    var selector = _selectors[_i];
    var classCandidates = getClasses(selector, ignoreNot); // At least one of the selectors contains non-"on-demandable" candidates.

    if (classCandidates.length === 0) {
      state.containsNonOnDemandable = true;
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = classCandidates[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var classCandidate = _step2.value;
        classes.push(classCandidate);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  if (depth === 0) {
    return [state.containsNonOnDemandable || classes.length === 0, classes];
  }

  return classes;
}

function withIdentifiers(styles) {
  return parseStyles(styles).flatMap(function (node) {
    var nodeMap = new Map();

    var _extractCandidates = extractCandidates(node),
        _extractCandidates2 = _slicedToArray(_extractCandidates, 2),
        containsNonOnDemandableSelectors = _extractCandidates2[0],
        candidates = _extractCandidates2[1]; // If this isn't "on-demandable", assign it a universal candidate to always include it.


    if (containsNonOnDemandableSelectors) {
      candidates.unshift(_sharedState.NOT_ON_DEMAND);
    } // However, it could be that it also contains "on-demandable" candidates.
    // E.g.: `span, .foo {}`, in that case it should still be possible to use
    // `@apply foo` for example.


    return candidates.map(function (c) {
      if (!nodeMap.has(node)) {
        nodeMap.set(node, node);
      }

      return [c, nodeMap.get(node)];
    });
  });
}

function _isValidVariantFormatString(format) {
  return format.startsWith("@") || format.includes("&");
}

function _parseVariant(variant) {
  variant = variant.replace(/\n+/g, "").replace(/\s{1,}/g, " ").trim();
  var fns = parseVariantFormatString(variant).map(function (str) {
    if (!str.startsWith("@")) {
      return function (_ref3) {
        var format = _ref3.format;
        return format(str);
      };
    }

    var _$exec = /@(\S*)( .+|[({].*)?/g.exec(str),
        _$exec2 = _slicedToArray(_$exec, 3),
        name = _$exec2[1],
        params = _$exec2[2];

    var _params_trim;

    return function (_ref4) {
      var wrap = _ref4.wrap;
      return wrap(_postcss["default"].atRule({
        name: name,
        params: (_params_trim = params === null || params === void 0 ? void 0 : params.trim()) !== null && _params_trim !== void 0 ? _params_trim : ""
      }));
    };
  }).reverse();
  return function (api) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = fns[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var fn = _step3.value;
        fn(api);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  };
}
/**
 *
 * @param {any} tailwindConfig
 * @param {any} context
 * @param {object} param2
 * @param {Offsets} param2.offsets
 */


function buildPluginApi(tailwindConfig, context, _ref5) {
  var variantList = _ref5.variantList,
      variantMap = _ref5.variantMap,
      offsets = _ref5.offsets,
      classList = _ref5.classList;

  function getConfigValue(path, defaultValue) {
    return path ? (0, _dlv["default"])(tailwindConfig, path, defaultValue) : tailwindConfig;
  }

  function applyConfiguredPrefix(selector) {
    return (0, _prefixSelector["default"])(tailwindConfig.prefix, selector);
  }

  function prefixIdentifier(identifier, options) {
    if (identifier === _sharedState.NOT_ON_DEMAND) {
      return _sharedState.NOT_ON_DEMAND;
    }

    if (!options.respectPrefix) {
      return identifier;
    }

    return context.tailwindConfig.prefix + identifier;
  }

  function resolveThemeValue(path, defaultValue) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var parts = (0, _toPath.toPath)(path);
    var value = getConfigValue(["theme"].concat(_toConsumableArray(parts)), defaultValue);
    return (0, _transformThemeValue["default"])(parts[0])(value, opts);
  }

  var variantIdentifier = 0;
  var api = {
    postcss: _postcss["default"],
    prefix: applyConfiguredPrefix,
    e: _escapeClassName["default"],
    config: getConfigValue,
    theme: resolveThemeValue,
    corePlugins: function corePlugins(path) {
      if (Array.isArray(tailwindConfig.corePlugins)) {
        return tailwindConfig.corePlugins.includes(path);
      }

      return getConfigValue(["corePlugins", path], true);
    },
    variants: function variants() {
      // Preserved for backwards compatibility but not used in v3.0+
      return [];
    },
    addBase: function addBase(base) {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = withIdentifiers(base)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var _step4$value = _slicedToArray(_step4.value, 2),
              identifier = _step4$value[0],
              rule = _step4$value[1];

          var prefixedIdentifier = prefixIdentifier(identifier, {});
          var offset = offsets.create("base");

          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }

          context.candidateRuleMap.get(prefixedIdentifier).push([{
            sort: offset,
            layer: "base"
          }, rule]);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    },

    /**
    * @param {string} group
    * @param {Record<string, string | string[]>} declarations
    */
    addDefaults: function addDefaults(group, declarations) {
      var groups = _defineProperty({}, "@defaults ".concat(group), declarations);

      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = withIdentifiers(groups)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var _step5$value = _slicedToArray(_step5.value, 2),
              identifier = _step5$value[0],
              rule = _step5$value[1];

          var prefixedIdentifier = prefixIdentifier(identifier, {});

          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }

          context.candidateRuleMap.get(prefixedIdentifier).push([{
            sort: offsets.create("defaults"),
            layer: "defaults"
          }, rule]);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    },
    addComponents: function addComponents(components, options) {
      var defaultOptions = {
        preserveSource: false,
        respectPrefix: true,
        respectImportant: false
      };
      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = withIdentifiers(components)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var _step6$value = _slicedToArray(_step6.value, 2),
              identifier = _step6$value[0],
              rule = _step6$value[1];

          var prefixedIdentifier = prefixIdentifier(identifier, options);
          classList.add(prefixedIdentifier);

          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }

          context.candidateRuleMap.get(prefixedIdentifier).push([{
            sort: offsets.create("components"),
            layer: "components",
            options: options
          }, rule]);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    },
    addUtilities: function addUtilities(utilities, options) {
      var defaultOptions = {
        preserveSource: false,
        respectPrefix: true,
        respectImportant: true
      };
      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = withIdentifiers(utilities)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var _step7$value = _slicedToArray(_step7.value, 2),
              identifier = _step7$value[0],
              rule = _step7$value[1];

          var prefixedIdentifier = prefixIdentifier(identifier, options);
          classList.add(prefixedIdentifier);

          if (!context.candidateRuleMap.has(prefixedIdentifier)) {
            context.candidateRuleMap.set(prefixedIdentifier, []);
          }

          context.candidateRuleMap.get(prefixedIdentifier).push([{
            sort: offsets.create("utilities"),
            layer: "utilities",
            options: options
          }, rule]);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    },
    matchUtilities: function matchUtilities(utilities, options) {
      var defaultOptions = {
        respectPrefix: true,
        respectImportant: true,
        modifiers: false
      };
      options = normalizeOptionTypes(_objectSpread({}, defaultOptions, {}, options));
      var offset = offsets.create("utilities");

      var _loop = function _loop(identifier) {
        var prefixedIdentifier = prefixIdentifier(identifier, options);
        var rule = utilities[identifier];
        classList.add([prefixedIdentifier, options]);

        function wrapped(modifier, _ref6) {
          var isOnlyPlugin = _ref6.isOnlyPlugin;

          var _ref7 = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig),
              _ref8 = _slicedToArray(_ref7, 3),
              value = _ref8[0],
              coercedType = _ref8[1],
              utilityModifier = _ref8[2];

          if (value === undefined) {
            return [];
          }

          if (!options.types.some(function (_ref9) {
            var type = _ref9.type;
            return type === coercedType;
          })) {
            if (isOnlyPlugin) {
              _log["default"].warn(["Unnecessary typehint `".concat(coercedType, "` in `").concat(identifier, "-").concat(modifier, "`."), "You can safely update it to `".concat(identifier, "-").concat(modifier.replace(coercedType + ":", ""), "`.")]);
            } else {
              return [];
            }
          }

          if (!(0, _isSyntacticallyValidPropertyValue["default"])(value)) {
            return [];
          }

          var extras = {
            get modifier() {
              if (!options.modifiers) {
                _log["default"].warn("modifier-used-without-options-for-".concat(identifier), ["Your plugin must set `modifiers: true` in its options to support modifiers."]);
              }

              return utilityModifier;
            }

          };
          var modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, "generalizedModifiers");
          var ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map(function (declaration) {
            return _defineProperty({}, (0, _nameClass["default"])(identifier, modifier), declaration);
          });
          return ruleSets;
        }

        var withOffsets = [{
          sort: offset,
          layer: "utilities",
          options: options
        }, wrapped];

        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }

        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
      };

      for (var identifier in utilities) {
        _loop(identifier);
      }
    },
    matchComponents: function matchComponents(components, options) {
      var defaultOptions = {
        respectPrefix: true,
        respectImportant: false,
        modifiers: false
      };
      options = normalizeOptionTypes(_objectSpread({}, defaultOptions, {}, options));
      var offset = offsets.create("components");

      var _loop2 = function _loop2(identifier) {
        var prefixedIdentifier = prefixIdentifier(identifier, options);
        var rule = components[identifier];
        classList.add([prefixedIdentifier, options]);

        function wrapped(modifier, _ref11) {
          var isOnlyPlugin = _ref11.isOnlyPlugin;

          var _ref12 = (0, _pluginUtils.coerceValue)(options.types, modifier, options, tailwindConfig),
              _ref13 = _slicedToArray(_ref12, 3),
              value = _ref13[0],
              coercedType = _ref13[1],
              utilityModifier = _ref13[2];

          if (value === undefined) {
            return [];
          }

          if (!options.types.some(function (_ref14) {
            var type = _ref14.type;
            return type === coercedType;
          })) {
            if (isOnlyPlugin) {
              _log["default"].warn(["Unnecessary typehint `".concat(coercedType, "` in `").concat(identifier, "-").concat(modifier, "`."), "You can safely update it to `".concat(identifier, "-").concat(modifier.replace(coercedType + ":", ""), "`.")]);
            } else {
              return [];
            }
          }

          if (!(0, _isSyntacticallyValidPropertyValue["default"])(value)) {
            return [];
          }

          var extras = {
            get modifier() {
              if (!options.modifiers) {
                _log["default"].warn("modifier-used-without-options-for-".concat(identifier), ["Your plugin must set `modifiers: true` in its options to support modifiers."]);
              }

              return utilityModifier;
            }

          };
          var modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, "generalizedModifiers");
          var ruleSets = [].concat(modifiersEnabled ? rule(value, extras) : rule(value)).filter(Boolean).map(function (declaration) {
            return _defineProperty({}, (0, _nameClass["default"])(identifier, modifier), declaration);
          });
          return ruleSets;
        }

        var withOffsets = [{
          sort: offset,
          layer: "components",
          options: options
        }, wrapped];

        if (!context.candidateRuleMap.has(prefixedIdentifier)) {
          context.candidateRuleMap.set(prefixedIdentifier, []);
        }

        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);
      };

      for (var identifier in components) {
        _loop2(identifier);
      }
    },
    addVariant: function addVariant(variantName, variantFunctions) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      variantFunctions = [].concat(variantFunctions).map(function (variantFunction) {
        if (typeof variantFunction !== "string") {
          // Safelist public API functions
          return function () {
            var api = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var args = api.args,
                modifySelectors = api.modifySelectors,
                container = api.container,
                separator = api.separator,
                wrap = api.wrap,
                format = api.format;
            var result = variantFunction(Object.assign({
              modifySelectors: modifySelectors,
              container: container,
              separator: separator
            }, options.type === VARIANT_TYPES.MatchVariant && {
              args: args,
              wrap: wrap,
              format: format
            }));

            if (typeof result === "string" && !_isValidVariantFormatString(result)) {
              throw new Error("Your custom variant `".concat(variantName, "` has an invalid format string. Make sure it's an at-rule or contains a `&` placeholder."));
            }

            if (Array.isArray(result)) {
              return result.filter(function (variant) {
                return typeof variant === "string";
              }).map(function (variant) {
                return _parseVariant(variant);
              });
            } // result may be undefined with legacy variants that use APIs like `modifySelectors`
            // result may also be a postcss node if someone was returning the result from `modifySelectors`


            return result && typeof result === "string" && _parseVariant(result)(api);
          };
        }

        if (!_isValidVariantFormatString(variantFunction)) {
          throw new Error("Your custom variant `".concat(variantName, "` has an invalid format string. Make sure it's an at-rule or contains a `&` placeholder."));
        }

        return _parseVariant(variantFunction);
      });
      insertInto(variantList, variantName, options);
      variantMap.set(variantName, variantFunctions);
      context.variantOptions.set(variantName, options);
    },
    matchVariant: function matchVariant(variant, variantFn, options) {
      var _options_id; // A unique identifier that "groups" these variants together.
      // This is for internal use only which is why it is not present in the types


      var id = (_options_id = options === null || options === void 0 ? void 0 : options.id) !== null && _options_id !== void 0 ? _options_id : ++variantIdentifier;
      var isSpecial = variant === "@";
      var modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, "generalizedModifiers");

      var _options_values;

      var _loop3 = function _loop3() {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
            key = _Object$entries$_i[0],
            value = _Object$entries$_i[1];

        if (key === "DEFAULT") return "continue";
        api.addVariant(isSpecial ? "".concat(variant).concat(key) : "".concat(variant, "-").concat(key), function (_ref17) {
          var args = _ref17.args,
              container = _ref17.container;
          return variantFn(value, modifiersEnabled ? {
            modifier: args === null || args === void 0 ? void 0 : args.modifier,
            container: container
          } : {
            container: container
          });
        }, _objectSpread({}, options, {
          value: value,
          id: id,
          type: VARIANT_TYPES.MatchVariant,
          variantInfo: VARIANT_INFO.Base
        }));
      };

      for (var _i2 = 0, _Object$entries = Object.entries((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {}); _i2 < _Object$entries.length; _i2++) {
        var _ret = _loop3();

        if (_ret === "continue") continue;
      }

      var _options_values1;

      var hasDefault = "DEFAULT" in ((_options_values1 = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {});
      api.addVariant(variant, function (_ref16) {
        var args = _ref16.args,
            container = _ref16.container;

        if ((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE && !hasDefault) {
          return null;
        }

        var // (JetBrains) plugins.
        _args_value;

        return variantFn((args === null || args === void 0 ? void 0 : args.value) === _sharedState.NONE ? options.values.DEFAULT : (_args_value = args === null || args === void 0 ? void 0 : args.value) !== null && _args_value !== void 0 ? _args_value : typeof args === "string" ? args : "", modifiersEnabled ? {
          modifier: args === null || args === void 0 ? void 0 : args.modifier,
          container: container
        } : {
          container: container
        });
      }, _objectSpread({}, options, {
        id: id,
        type: VARIANT_TYPES.MatchVariant,
        variantInfo: VARIANT_INFO.Dynamic
      }));
    }
  };
  return api;
}

var fileModifiedMapCache = new WeakMap();

function _getFileModifiedMap(context) {
  if (!fileModifiedMapCache.has(context)) {
    fileModifiedMapCache.set(context, new Map());
  }

  return fileModifiedMapCache.get(context);
}

function trackModified(files, fileModifiedMap) {
  var changed = false;
  var mtimesToCommit = new Map();
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = files[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var file = _step8.value;

      var _fs_statSync;

      if (!file) continue;

      var parsed = _url["default"].parse(file);

      var pathname = parsed.hash ? parsed.href.replace(parsed.hash, "") : parsed.href;
      pathname = parsed.search ? pathname.replace(parsed.search, "") : pathname;
      var newModified = (_fs_statSync = _fs["default"].statSync(decodeURIComponent(pathname), {
        throwIfNoEntry: false
      })) === null || _fs_statSync === void 0 ? void 0 : _fs_statSync.mtimeMs;

      if (!newModified) {
        continue;
      }

      if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {
        changed = true;
      }

      mtimesToCommit.set(file, newModified);
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
        _iterator8["return"]();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  return [changed, mtimesToCommit];
}

function extractVariantAtRules(node) {
  node.walkAtRules(function (atRule) {
    if (["responsive", "variants"].includes(atRule.name)) {
      extractVariantAtRules(atRule);
      atRule.before(atRule.nodes);
      atRule.remove();
    }
  });
}

function collectLayerPlugins(root) {
  var layerPlugins = [];
  root.each(function (node) {
    if (node.type === "atrule" && ["responsive", "variants"].includes(node.name)) {
      node.name = "layer";
      node.params = "utilities";
    }
  }); // Walk @layer rules and treat them like plugins

  root.walkAtRules("layer", function (layerRule) {
    extractVariantAtRules(layerRule);

    if (layerRule.params === "base") {
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        var _loop4 = function _loop4() {
          var node = _step9.value;
          layerPlugins.push(function (_ref18) {
            var addBase = _ref18.addBase;
            addBase(node, {
              respectPrefix: false
            });
          });
        };

        for (var _iterator9 = layerRule.nodes[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          _loop4();
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      layerRule.remove();
    } else if (layerRule.params === "components") {
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        var _loop5 = function _loop5() {
          var node = _step10.value;
          layerPlugins.push(function (_ref19) {
            var addComponents = _ref19.addComponents;
            addComponents(node, {
              respectPrefix: false,
              preserveSource: true
            });
          });
        };

        for (var _iterator10 = layerRule.nodes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          _loop5();
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }

      layerRule.remove();
    } else if (layerRule.params === "utilities") {
      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        var _loop6 = function _loop6() {
          var node = _step11.value;
          layerPlugins.push(function (_ref20) {
            var addUtilities = _ref20.addUtilities;
            addUtilities(node, {
              respectPrefix: false,
              preserveSource: true
            });
          });
        };

        for (var _iterator11 = layerRule.nodes[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          _loop6();
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
            _iterator11["return"]();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }

      layerRule.remove();
    }
  });
  return layerPlugins;
}

function resolvePlugins(context, root) {
  var corePluginList = Object.entries(_objectSpread({}, _corePlugins.variantPlugins, {}, _corePlugins.corePlugins)).map(function (_ref21) {
    var _ref22 = _slicedToArray(_ref21, 2),
        name = _ref22[0],
        plugin = _ref22[1];

    if (!context.tailwindConfig.corePlugins.includes(name)) {
      return null;
    }

    return plugin;
  }).filter(Boolean);
  var userPlugins = context.tailwindConfig.plugins.map(function (plugin) {
    if (plugin.__isOptionsFunction) {
      plugin = plugin();
    }

    return typeof plugin === "function" ? plugin : plugin.handler;
  });
  var layerPlugins = collectLayerPlugins(root); // TODO: This is a workaround for backwards compatibility, since custom variants
  // were historically sorted before screen/stackable variants.

  var beforeVariants = [_corePlugins.variantPlugins["pseudoElementVariants"], _corePlugins.variantPlugins["pseudoClassVariants"], _corePlugins.variantPlugins["ariaVariants"], _corePlugins.variantPlugins["dataVariants"]];
  var afterVariants = [_corePlugins.variantPlugins["supportsVariants"], _corePlugins.variantPlugins["directionVariants"], _corePlugins.variantPlugins["reducedMotionVariants"], _corePlugins.variantPlugins["prefersContrastVariants"], _corePlugins.variantPlugins["darkVariants"], _corePlugins.variantPlugins["printVariant"], _corePlugins.variantPlugins["screenVariants"], _corePlugins.variantPlugins["orientationVariants"]];
  return [].concat(_toConsumableArray(corePluginList), beforeVariants, _toConsumableArray(userPlugins), afterVariants, _toConsumableArray(layerPlugins));
}

function registerPlugins(plugins, context) {
  var variantList = [];
  var variantMap = new Map();
  context.variantMap = variantMap;
  var offsets = new _offsets.Offsets();
  context.offsets = offsets;
  var classList = new Set();
  var pluginApi = buildPluginApi(context.tailwindConfig, context, {
    variantList: variantList,
    variantMap: variantMap,
    offsets: offsets,
    classList: classList
  });
  var _iteratorNormalCompletion12 = true;
  var _didIteratorError12 = false;
  var _iteratorError12 = undefined;

  try {
    for (var _iterator12 = plugins[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
      var plugin = _step12.value;

      if (Array.isArray(plugin)) {
        var _iteratorNormalCompletion25 = true;
        var _didIteratorError25 = false;
        var _iteratorError25 = undefined;

        try {
          for (var _iterator25 = plugin[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
            var pluginItem = _step25.value;
            pluginItem(pluginApi);
          }
        } catch (err) {
          _didIteratorError25 = true;
          _iteratorError25 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion25 && _iterator25["return"] != null) {
              _iterator25["return"]();
            }
          } finally {
            if (_didIteratorError25) {
              throw _iteratorError25;
            }
          }
        }
      } else {
        plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);
      }
    } // Make sure to record bit masks for every variant

  } catch (err) {
    _didIteratorError12 = true;
    _iteratorError12 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
        _iterator12["return"]();
      }
    } finally {
      if (_didIteratorError12) {
        throw _iteratorError12;
      }
    }
  }

  offsets.recordVariants(variantList, function (variant) {
    return variantMap.get(variant).length;
  }); // Build variantMap

  var _iteratorNormalCompletion13 = true;
  var _didIteratorError13 = false;
  var _iteratorError13 = undefined;

  try {
    var _loop10 = function _loop10() {
      var _step13$value = _slicedToArray(_step13.value, 2),
          variantName = _step13$value[0],
          variantFunctions = _step13$value[1];

      context.variantMap.set(variantName, variantFunctions.map(function (variantFunction, idx) {
        return [offsets.forVariant(variantName, idx), variantFunction];
      }));
    };

    for (var _iterator13 = variantMap.entries()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
      _loop10();
    }
  } catch (err) {
    _didIteratorError13 = true;
    _iteratorError13 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
        _iterator13["return"]();
      }
    } finally {
      if (_didIteratorError13) {
        throw _iteratorError13;
      }
    }
  }

  var _context_tailwindConfig_safelist;

  var safelist = ((_context_tailwindConfig_safelist = context.tailwindConfig.safelist) !== null && _context_tailwindConfig_safelist !== void 0 ? _context_tailwindConfig_safelist : []).filter(Boolean);

  if (safelist.length > 0) {
    var checks = [];
    var _iteratorNormalCompletion14 = true;
    var _didIteratorError14 = false;
    var _iteratorError14 = undefined;

    try {
      for (var _iterator14 = safelist[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
        var value = _step14.value;

        if (typeof value === "string") {
          context.changedContent.push({
            content: value,
            extension: "html"
          });
          continue;
        }

        if (value instanceof RegExp) {
          _log["default"].warn("root-regex", ["Regular expressions in `safelist` work differently in Tailwind CSS v3.0.", "Update your `safelist` configuration to eliminate this warning.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);

          continue;
        }

        checks.push(value);
      }
    } catch (err) {
      _didIteratorError14 = true;
      _iteratorError14 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
          _iterator14["return"]();
        }
      } finally {
        if (_didIteratorError14) {
          throw _iteratorError14;
        }
      }
    }

    if (checks.length > 0) {
      (function () {
        var patternMatchingCount = new Map();
        var prefixLength = context.tailwindConfig.prefix.length;
        var checkImportantUtils = checks.some(function (check) {
          return check.pattern.source.includes("!");
        });
        var _iteratorNormalCompletion15 = true;
        var _didIteratorError15 = false;
        var _iteratorError15 = undefined;

        try {
          var _loop7 = function _loop7() {
            var util = _step15.value;
            var utils = Array.isArray(util) ? function () {
              var _util = _slicedToArray(util, 2),
                  utilName = _util[0],
                  options = _util[1];

              var _options_values;

              var values = Object.keys((_options_values = options === null || options === void 0 ? void 0 : options.values) !== null && _options_values !== void 0 ? _options_values : {});
              var classes = values.map(function (value) {
                return (0, _nameClass.formatClass)(utilName, value);
              });

              if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {
                // This is the normal negated version
                // e.g. `-inset-1` or `-tw-inset-1`
                classes = [].concat(_toConsumableArray(classes), _toConsumableArray(classes.map(function (cls) {
                  return "-" + cls;
                }))); // This is the negated version *after* the prefix
                // e.g. `tw--inset-1`
                // The prefix is already attached to util name
                // So we add the negative after the prefix

                classes = [].concat(_toConsumableArray(classes), _toConsumableArray(classes.map(function (cls) {
                  return cls.slice(0, prefixLength) + "-" + cls.slice(prefixLength);
                })));
              }

              if (options.types.some(function (_ref23) {
                var type = _ref23.type;
                return type === "color";
              })) {
                classes = [].concat(_toConsumableArray(classes), _toConsumableArray(classes.flatMap(function (cls) {
                  return Object.keys(context.tailwindConfig.theme.opacity).map(function (opacity) {
                    return "".concat(cls, "/").concat(opacity);
                  });
                })));
              }

              if (checkImportantUtils && (options === null || options === void 0 ? void 0 : options.respectImportant)) {
                classes = [].concat(_toConsumableArray(classes), _toConsumableArray(classes.map(function (cls) {
                  return "!" + cls;
                })));
              }

              return classes;
            }() : [util];
            var _iteratorNormalCompletion17 = true;
            var _didIteratorError17 = false;
            var _iteratorError17 = undefined;

            try {
              for (var _iterator17 = utils[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                var _util2 = _step17.value;
                var _iteratorNormalCompletion18 = true;
                var _didIteratorError18 = false;
                var _iteratorError18 = undefined;

                try {
                  for (var _iterator18 = checks[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                    var _step18$value = _step18.value,
                        pattern = _step18$value.pattern,
                        _step18$value$variant = _step18$value.variants,
                        variants = _step18$value$variant === void 0 ? [] : _step18$value$variant;
                    // RegExp with the /g flag are stateful, so let's reset the last
                    // index pointer to reset the state.
                    pattern.lastIndex = 0;

                    if (!patternMatchingCount.has(pattern)) {
                      patternMatchingCount.set(pattern, 0);
                    }

                    if (!pattern.test(_util2)) continue;
                    patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);
                    context.changedContent.push({
                      content: _util2,
                      extension: "html"
                    });
                    var _iteratorNormalCompletion19 = true;
                    var _didIteratorError19 = false;
                    var _iteratorError19 = undefined;

                    try {
                      for (var _iterator19 = variants[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                        var variant = _step19.value;
                        context.changedContent.push({
                          content: variant + context.tailwindConfig.separator + _util2,
                          extension: "html"
                        });
                      }
                    } catch (err) {
                      _didIteratorError19 = true;
                      _iteratorError19 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
                          _iterator19["return"]();
                        }
                      } finally {
                        if (_didIteratorError19) {
                          throw _iteratorError19;
                        }
                      }
                    }
                  }
                } catch (err) {
                  _didIteratorError18 = true;
                  _iteratorError18 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
                      _iterator18["return"]();
                    }
                  } finally {
                    if (_didIteratorError18) {
                      throw _iteratorError18;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError17 = true;
              _iteratorError17 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
                  _iterator17["return"]();
                }
              } finally {
                if (_didIteratorError17) {
                  throw _iteratorError17;
                }
              }
            }
          };

          for (var _iterator15 = classList[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
            _loop7();
          }
        } catch (err) {
          _didIteratorError15 = true;
          _iteratorError15 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
              _iterator15["return"]();
            }
          } finally {
            if (_didIteratorError15) {
              throw _iteratorError15;
            }
          }
        }

        var _iteratorNormalCompletion16 = true;
        var _didIteratorError16 = false;
        var _iteratorError16 = undefined;

        try {
          for (var _iterator16 = patternMatchingCount.entries()[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
            var _step16$value = _slicedToArray(_step16.value, 2),
                regex = _step16$value[0],
                count = _step16$value[1];

            if (count !== 0) continue;

            _log["default"].warn(["The safelist pattern `".concat(regex, "` doesn't match any Tailwind CSS classes."), "Fix this pattern or remove it from your `safelist` configuration.", "https://tailwindcss.com/docs/content-configuration#safelisting-classes"]);
          }
        } catch (err) {
          _didIteratorError16 = true;
          _iteratorError16 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
              _iterator16["return"]();
            }
          } finally {
            if (_didIteratorError16) {
              throw _iteratorError16;
            }
          }
        }
      })();
    }
  }

  var _context_tailwindConfig_darkMode, _concat_;

  var darkClassName = (_concat_ = [].concat((_context_tailwindConfig_darkMode = context.tailwindConfig.darkMode) !== null && _context_tailwindConfig_darkMode !== void 0 ? _context_tailwindConfig_darkMode : "media")[1]) !== null && _concat_ !== void 0 ? _concat_ : "dark"; // A list of utilities that are used by certain Tailwind CSS utilities but
  // that don't exist on their own. This will result in them "not existing" and
  // sorting could be weird since you still require them in order to make the
  // host utilities work properly. (Thanks Biology)

  var parasiteUtilities = [prefix(context, darkClassName), prefix(context, "group"), prefix(context, "peer")];

  context.getClassOrder = function getClassOrder(classes) {
    // Sort classes so they're ordered in a deterministic manner
    var sorted = _toConsumableArray(classes).sort(function (a, z) {
      if (a === z) return 0;
      if (a < z) return -1;
      return 1;
    }); // Non-util classes won't be generated, so we default them to null


    var sortedClassNames = new Map(sorted.map(function (className) {
      return [className, null];
    })); // Sort all classes in order
    // Non-tailwind classes won't be generated and will be left as `null`

    var rules = (0, _generateRules.generateRules)(new Set(sorted), context, true);
    rules = context.offsets.sort(rules);
    var idx = BigInt(parasiteUtilities.length);
    var _iteratorNormalCompletion20 = true;
    var _didIteratorError20 = false;
    var _iteratorError20 = undefined;

    try {
      for (var _iterator20 = rules[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
        var _step20$value = _slicedToArray(_step20.value, 2),
            rule = _step20$value[1];

        var candidate = rule.raws.tailwind.candidate;

        var _sortedClassNames_get; // When multiple rules match a candidate
        // always take the position of the first one


        sortedClassNames.set(candidate, (_sortedClassNames_get = sortedClassNames.get(candidate)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : idx++);
      }
    } catch (err) {
      _didIteratorError20 = true;
      _iteratorError20 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
          _iterator20["return"]();
        }
      } finally {
        if (_didIteratorError20) {
          throw _iteratorError20;
        }
      }
    }

    return classes.map(function (className) {
      var _sortedClassNames_get;

      var order = (_sortedClassNames_get = sortedClassNames.get(className)) !== null && _sortedClassNames_get !== void 0 ? _sortedClassNames_get : null;
      var parasiteIndex = parasiteUtilities.indexOf(className);

      if (order === null && parasiteIndex !== -1) {
        // This will make sure that it is at the very beginning of the
        // `components` layer which technically means 'before any
        // components'.
        order = BigInt(parasiteIndex);
      }

      return [className, order];
    });
  }; // Generate a list of strings for autocompletion purposes, e.g.
  // ['uppercase', 'lowercase', ...]


  context.getClassList = function getClassList() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var output = [];
    var _iteratorNormalCompletion21 = true;
    var _didIteratorError21 = false;
    var _iteratorError21 = undefined;

    try {
      for (var _iterator21 = classList[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
        var util = _step21.value;

        if (Array.isArray(util)) {
          var _utilOptions_types;

          var _util3 = _slicedToArray(util, 2),
              utilName = _util3[0],
              utilOptions = _util3[1];

          var negativeClasses = [];

          var _utilOptions_modifiers;

          var modifiers = Object.keys((_utilOptions_modifiers = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.modifiers) !== null && _utilOptions_modifiers !== void 0 ? _utilOptions_modifiers : {});

          if (utilOptions === null || utilOptions === void 0 ? void 0 : (_utilOptions_types = utilOptions.types) === null || _utilOptions_types === void 0 ? void 0 : _utilOptions_types.some(function (_ref24) {
            var type = _ref24.type;
            return type === "color";
          })) {
            var _context_tailwindConfig_theme_opacity;

            modifiers.push.apply(modifiers, _toConsumableArray(Object.keys((_context_tailwindConfig_theme_opacity = context.tailwindConfig.theme.opacity) !== null && _context_tailwindConfig_theme_opacity !== void 0 ? _context_tailwindConfig_theme_opacity : {})));
          }

          var metadata = {
            modifiers: modifiers
          };
          var includeMetadata = options.includeMetadata && modifiers.length > 0;

          var _utilOptions_values;

          for (var _i3 = 0, _Object$entries2 = Object.entries((_utilOptions_values = utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.values) !== null && _utilOptions_values !== void 0 ? _utilOptions_values : {}); _i3 < _Object$entries2.length; _i3++) {
            var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i3], 2),
                key = _Object$entries2$_i[0],
                _value = _Object$entries2$_i[1];

            // Ignore undefined and null values
            if (_value == null) {
              continue;
            }

            var cls = (0, _nameClass.formatClass)(utilName, key);
            output.push(includeMetadata ? [cls, metadata] : cls);

            if ((utilOptions === null || utilOptions === void 0 ? void 0 : utilOptions.supportsNegativeValues) && (0, _negateValue["default"])(_value)) {
              var _cls = (0, _nameClass.formatClass)(utilName, "-".concat(key));

              negativeClasses.push(includeMetadata ? [_cls, metadata] : _cls);
            }
          }

          output.push.apply(output, negativeClasses);
        } else {
          output.push(util);
        }
      }
    } catch (err) {
      _didIteratorError21 = true;
      _iteratorError21 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion21 && _iterator21["return"] != null) {
          _iterator21["return"]();
        }
      } finally {
        if (_didIteratorError21) {
          throw _iteratorError21;
        }
      }
    }

    return output;
  }; // Generate a list of available variants with meta information of the type of variant.


  context.getVariants = function getVariants() {
    var result = [];
    var _iteratorNormalCompletion22 = true;
    var _didIteratorError22 = false;
    var _iteratorError22 = undefined;

    try {
      var _loop8 = function _loop8() {
        var _step22$value = _slicedToArray(_step22.value, 2),
            name = _step22$value[0],
            options = _step22$value[1];

        if (options.variantInfo === VARIANT_INFO.Base) return "continue";
        result.push({
          name: name,
          isArbitrary: options.type === Symbol["for"]("MATCH_VARIANT"),
          values: Object.keys((_options_values = options.values) !== null && _options_values !== void 0 ? _options_values : {}),
          hasDash: name !== "@",
          selectors: function selectors() {
            var _ref25 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                modifier = _ref25.modifier,
                value = _ref25.value;

            var candidate = "__TAILWIND_PLACEHOLDER__";

            var rule = _postcss["default"].rule({
              selector: ".".concat(candidate)
            });

            var container = _postcss["default"].root({
              nodes: [rule.clone()]
            });

            var before = container.toString();

            var _context_variantMap_get;

            var fns = ((_context_variantMap_get = context.variantMap.get(name)) !== null && _context_variantMap_get !== void 0 ? _context_variantMap_get : []).flatMap(function (_ref26) {
              var _ref27 = _slicedToArray(_ref26, 2),
                  _ = _ref27[0],
                  fn = _ref27[1];

              return fn;
            });
            var formatStrings = [];
            var _iteratorNormalCompletion23 = true;
            var _didIteratorError23 = false;
            var _iteratorError23 = undefined;

            try {
              var _loop9 = function _loop9() {
                var fn = _step23.value;
                var localFormatStrings = [];
                var api = {
                  args: {
                    modifier: modifier,
                    value: (_options_values_value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[value]) !== null && _options_values_value !== void 0 ? _options_values_value : value
                  },
                  separator: context.tailwindConfig.separator,
                  modifySelectors: function modifySelectors(modifierFunction) {
                    // Run the modifierFunction over each rule
                    container.each(function (rule) {
                      if (rule.type !== "rule") {
                        return;
                      }

                      rule.selectors = rule.selectors.map(function (selector) {
                        return modifierFunction({
                          get className() {
                            return (0, _generateRules.getClassNameFromSelector)(selector);
                          },

                          selector: selector
                        });
                      });
                    });
                    return container;
                  },
                  format: function format(str) {
                    localFormatStrings.push(str);
                  },
                  wrap: function wrap(wrapper) {
                    localFormatStrings.push("@".concat(wrapper.name, " ").concat(wrapper.params, " { & }"));
                  },
                  container: container
                };
                var ruleWithVariant = fn(api);

                if (localFormatStrings.length > 0) {
                  formatStrings.push(localFormatStrings);
                }

                if (Array.isArray(ruleWithVariant)) {
                  var _iteratorNormalCompletion24 = true;
                  var _didIteratorError24 = false;
                  var _iteratorError24 = undefined;

                  try {
                    for (var _iterator24 = ruleWithVariant[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
                      var variantFunction = _step24.value;
                      localFormatStrings = [];
                      variantFunction(api);
                      formatStrings.push(localFormatStrings);
                    }
                  } catch (err) {
                    _didIteratorError24 = true;
                    _iteratorError24 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion24 && _iterator24["return"] != null) {
                        _iterator24["return"]();
                      }
                    } finally {
                      if (_didIteratorError24) {
                        throw _iteratorError24;
                      }
                    }
                  }
                }
              };

              for (var _iterator23 = fns[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                var _options_values;

                var _options_values_value;

                _loop9();
              } // Reverse engineer the result of the `container`

            } catch (err) {
              _didIteratorError23 = true;
              _iteratorError23 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion23 && _iterator23["return"] != null) {
                  _iterator23["return"]();
                }
              } finally {
                if (_didIteratorError23) {
                  throw _iteratorError23;
                }
              }
            }

            var manualFormatStrings = [];
            var after = container.toString();

            if (before !== after) {
              // Figure out all selectors
              container.walkRules(function (rule) {
                var modified = rule.selector; // Rebuild the base selector, this is what plugin authors would do
                // as well. E.g.: `${variant}${separator}${className}`.
                // However, plugin authors probably also prepend or append certain
                // classes, pseudos, ids, ...

                var rebuiltBase = (0, _postcssselectorparser["default"])(function (selectors) {
                  selectors.walkClasses(function (classNode) {
                    classNode.value = "".concat(name).concat(context.tailwindConfig.separator).concat(classNode.value);
                  });
                }).processSync(modified); // Now that we know the original selector, the new selector, and
                // the rebuild part in between, we can replace the part that plugin
                // authors need to rebuild with `&`, and eventually store it in the
                // collectedFormats. Similar to what `format('...')` would do.
                //
                // E.g.:
                //                   variant: foo
                //                  selector: .markdown > p
                //      modified (by plugin): .foo .foo\\:markdown > p
                //    rebuiltBase (internal): .foo\\:markdown > p
                //                    format: .foo &

                manualFormatStrings.push(modified.replace(rebuiltBase, "&").replace(candidate, "&"));
              }); // Figure out all atrules

              container.walkAtRules(function (atrule) {
                manualFormatStrings.push("@".concat(atrule.name, " (").concat(atrule.params, ") { & }"));
              });
            }

            var _options_values1;

            var isArbitraryVariant = !(value in ((_options_values1 = options.values) !== null && _options_values1 !== void 0 ? _options_values1 : {}));

            var _options_INTERNAL_FEATURES;

            var internalFeatures = (_options_INTERNAL_FEATURES = options[_INTERNAL_FEATURES]) !== null && _options_INTERNAL_FEATURES !== void 0 ? _options_INTERNAL_FEATURES : {};

            var respectPrefix = function () {
              if (isArbitraryVariant) return false;
              if (internalFeatures.respectPrefix === false) return false;
              return true;
            }();

            formatStrings = formatStrings.map(function (format) {
              return format.map(function (str) {
                return {
                  format: str,
                  respectPrefix: respectPrefix
                };
              });
            });
            manualFormatStrings = manualFormatStrings.map(function (format) {
              return {
                format: format,
                respectPrefix: respectPrefix
              };
            });
            var opts = {
              candidate: candidate,
              context: context
            };
            var result = formatStrings.map(function (formats) {
              return (0, _formatVariantSelector.finalizeSelector)(".".concat(candidate), (0, _formatVariantSelector.formatVariantSelector)(formats, opts), opts).replace(".".concat(candidate), "&").replace("{ & }", "").trim();
            });

            if (manualFormatStrings.length > 0) {
              result.push((0, _formatVariantSelector.formatVariantSelector)(manualFormatStrings, opts).toString().replace(".".concat(candidate), "&"));
            }

            return result;
          }
        });
      };

      for (var _iterator22 = context.variantOptions.entries()[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
        var _options_values;

        var _ret2 = _loop8();

        if (_ret2 === "continue") continue;
      }
    } catch (err) {
      _didIteratorError22 = true;
      _iteratorError22 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion22 && _iterator22["return"] != null) {
          _iterator22["return"]();
        }
      } finally {
        if (_didIteratorError22) {
          throw _iteratorError22;
        }
      }
    }

    return result;
  };
}
/**
 * Mark as class as retroactively invalid
 *
 *
 * @param {string} candidate
 */


function _markInvalidUtilityCandidate(context, candidate) {
  if (!context.classCache.has(candidate)) {
    return;
  } // Mark this as not being a real utility


  context.notClassCache.add(candidate); // Remove it from any candidate-specific caches

  context.classCache["delete"](candidate);
  context.applyClassCache["delete"](candidate);
  context.candidateRuleMap["delete"](candidate);
  context.candidateRuleCache["delete"](candidate); // Ensure the stylesheet gets rebuilt

  context.stylesheetCache = null;
}
/**
 * Mark as class as retroactively invalid
 *
 * @param {import('postcss').Node} node
 */


function _markInvalidUtilityNode(context, node) {
  var candidate = node.raws.tailwind.candidate;

  if (!candidate) {
    return;
  }

  var _iteratorNormalCompletion26 = true;
  var _didIteratorError26 = false;
  var _iteratorError26 = undefined;

  try {
    for (var _iterator26 = context.ruleCache[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
      var entry = _step26.value;

      if (entry[1].raws.tailwind.candidate === candidate) {
        context.ruleCache["delete"](entry); // context.postCssNodeCache.delete(node)
      }
    }
  } catch (err) {
    _didIteratorError26 = true;
    _iteratorError26 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion26 && _iterator26["return"] != null) {
        _iterator26["return"]();
      }
    } finally {
      if (_didIteratorError26) {
        throw _iteratorError26;
      }
    }
  }

  _markInvalidUtilityCandidate(context, candidate);
}

function _createContext(tailwindConfig) {
  var changedContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _postcss["default"].root();

  var _tailwindConfig_blocklist;

  var context = {
    disposables: [],
    ruleCache: new Set(),
    candidateRuleCache: new Map(),
    classCache: new Map(),
    applyClassCache: new Map(),
    // Seed the not class cache with the blocklist (which is only strings)
    notClassCache: new Set((_tailwindConfig_blocklist = tailwindConfig.blocklist) !== null && _tailwindConfig_blocklist !== void 0 ? _tailwindConfig_blocklist : []),
    postCssNodeCache: new Map(),
    candidateRuleMap: new Map(),
    tailwindConfig: tailwindConfig,
    changedContent: changedContent,
    variantMap: new Map(),
    stylesheetCache: null,
    variantOptions: new Map(),
    markInvalidUtilityCandidate: function markInvalidUtilityCandidate(candidate) {
      return _markInvalidUtilityCandidate(context, candidate);
    },
    markInvalidUtilityNode: function markInvalidUtilityNode(node) {
      return _markInvalidUtilityNode(context, node);
    }
  };
  var resolvedPlugins = resolvePlugins(context, root);
  registerPlugins(resolvedPlugins, context);
  return context;
}

var contextMap = _sharedState.contextMap;
var configContextMap = _sharedState.configContextMap;
var contextSourcesMap = _sharedState.contextSourcesMap;

function _getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {
  var sourcePath = result.opts.from;
  var isConfigFile = userConfigPath !== null;
  _sharedState.env.DEBUG && console.log("Source path:", sourcePath);
  var existingContext;

  if (isConfigFile && contextMap.has(sourcePath)) {
    existingContext = contextMap.get(sourcePath);
  } else if (configContextMap.has(tailwindConfigHash)) {
    var _context = configContextMap.get(tailwindConfigHash);

    contextSourcesMap.get(_context).add(sourcePath);
    contextMap.set(sourcePath, _context);
    existingContext = _context;
  }

  var cssDidChange = (0, _cacheInvalidation.hasContentChanged)(sourcePath, root); // If there's already a context in the cache and we don't need to
  // reset the context, return the cached context.

  if (existingContext) {
    var _trackModified = trackModified(_toConsumableArray(contextDependencies), _getFileModifiedMap(existingContext)),
        _trackModified2 = _slicedToArray(_trackModified, 2),
        contextDependenciesChanged = _trackModified2[0],
        _mtimesToCommit = _trackModified2[1];

    if (!contextDependenciesChanged && !cssDidChange) {
      return [existingContext, false, _mtimesToCommit];
    }
  } // If this source is in the context map, get the old context.
  // Remove this source from the context sources for the old context,
  // and clean up that context if no one else is using it. This can be
  // called by many processes in rapid succession, so we check for presence
  // first because the first process to run this code will wipe it out first.


  if (contextMap.has(sourcePath)) {
    var oldContext = contextMap.get(sourcePath);

    if (contextSourcesMap.has(oldContext)) {
      contextSourcesMap.get(oldContext)["delete"](sourcePath);

      if (contextSourcesMap.get(oldContext).size === 0) {
        contextSourcesMap["delete"](oldContext);
        var _iteratorNormalCompletion27 = true;
        var _didIteratorError27 = false;
        var _iteratorError27 = undefined;

        try {
          for (var _iterator27 = configContextMap[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
            var _step27$value = _slicedToArray(_step27.value, 2),
                _tailwindConfigHash = _step27$value[0],
                _context2 = _step27$value[1];

            if (_context2 === oldContext) {
              configContextMap["delete"](_tailwindConfigHash);
            }
          }
        } catch (err) {
          _didIteratorError27 = true;
          _iteratorError27 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion27 && _iterator27["return"] != null) {
              _iterator27["return"]();
            }
          } finally {
            if (_didIteratorError27) {
              throw _iteratorError27;
            }
          }
        }

        var _iteratorNormalCompletion28 = true;
        var _didIteratorError28 = false;
        var _iteratorError28 = undefined;

        try {
          for (var _iterator28 = oldContext.disposables.splice(0)[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
            var disposable = _step28.value;
            disposable(oldContext);
          }
        } catch (err) {
          _didIteratorError28 = true;
          _iteratorError28 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion28 && _iterator28["return"] != null) {
              _iterator28["return"]();
            }
          } finally {
            if (_didIteratorError28) {
              throw _iteratorError28;
            }
          }
        }
      }
    }
  }

  _sharedState.env.DEBUG && console.log("Setting up new context...");

  var context = _createContext(tailwindConfig, [], root);

  Object.assign(context, {
    userConfigPath: userConfigPath
  });

  var _trackModified3 = trackModified(_toConsumableArray(contextDependencies), _getFileModifiedMap(context)),
      _trackModified4 = _slicedToArray(_trackModified3, 2),
      mtimesToCommit = _trackModified4[1]; // ---
  // Update all context tracking state


  configContextMap.set(tailwindConfigHash, context);
  contextMap.set(sourcePath, context);

  if (!contextSourcesMap.has(context)) {
    contextSourcesMap.set(context, new Set());
  }

  contextSourcesMap.get(context).add(sourcePath);
  return [context, true, mtimesToCommit];
}