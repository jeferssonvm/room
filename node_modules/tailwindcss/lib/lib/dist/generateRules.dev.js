"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(candidatePermutations),
    _marked2 =
/*#__PURE__*/
regeneratorRuntime.mark(resolveMatchedPlugins),
    _marked3 =
/*#__PURE__*/
regeneratorRuntime.mark(recordCandidates),
    _marked4 =
/*#__PURE__*/
regeneratorRuntime.mark(_resolveMatches);

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _export(target, all) {
  for (var name in all) {
    Object.defineProperty(target, name, {
      enumerable: true,
      get: all[name]
    });
  }
}

_export(exports, {
  getClassNameFromSelector: function getClassNameFromSelector() {
    return _getClassNameFromSelector;
  },
  resolveMatches: function resolveMatches() {
    return _resolveMatches;
  },
  generateRules: function generateRules() {
    return _generateRules;
  }
});

var _postcss =
/*#__PURE__*/
_interop_require_default(require("postcss"));

var _postcssselectorparser =
/*#__PURE__*/
_interop_require_default(require("postcss-selector-parser"));

var _parseObjectStyles =
/*#__PURE__*/
_interop_require_default(require("../util/parseObjectStyles"));

var _isPlainObject =
/*#__PURE__*/
_interop_require_default(require("../util/isPlainObject"));

var _prefixSelector =
/*#__PURE__*/
_interop_require_default(require("../util/prefixSelector"));

var _pluginUtils = require("../util/pluginUtils");

var _log =
/*#__PURE__*/
_interop_require_default(require("../util/log"));

var _sharedState =
/*#__PURE__*/
_interop_require_wildcard(require("./sharedState"));

var _formatVariantSelector = require("../util/formatVariantSelector");

var _nameClass = require("../util/nameClass");

var _dataTypes = require("../util/dataTypes");

var _setupContextUtils = require("./setupContextUtils");

var _isSyntacticallyValidPropertyValue =
/*#__PURE__*/
_interop_require_default(require("../util/isSyntacticallyValidPropertyValue"));

var _splitAtTopLevelOnly = require("../util/splitAtTopLevelOnly.js");

var _featureFlags = require("../featureFlags");

var _applyImportantSelector = require("../util/applyImportantSelector");

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interop_require_wildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var classNameParser = (0, _postcssselectorparser["default"])(function (selectors) {
  return selectors.first.filter(function (_ref) {
    var type = _ref.type;
    return type === "class";
  }).pop().value;
});

function _getClassNameFromSelector(selector) {
  return classNameParser.transformSync(selector);
} // Generate match permutations for a class candidate, like:
// ['ring-offset-blue', '100']
// ['ring-offset', 'blue-100']
// ['ring', 'offset-blue-100']
// Example with dynamic classes:
// ['grid-cols', '[[linename],1fr,auto]']
// ['grid', 'cols-[[linename],1fr,auto]']


function candidatePermutations(candidate) {
  var lastIndex, dashIdx, wasSlash, bracketIdx, prefix, modifier;
  return regeneratorRuntime.wrap(function candidatePermutations$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          lastIndex = Infinity;

        case 1:
          if (!(lastIndex >= 0)) {
            _context.next = 16;
            break;
          }

          dashIdx = void 0;
          wasSlash = false;

          if (lastIndex === Infinity && candidate.endsWith("]")) {
            bracketIdx = candidate.indexOf("["); // If character before `[` isn't a dash or a slash, this isn't a dynamic class
            // eg. string[]

            if (candidate[bracketIdx - 1] === "-") {
              dashIdx = bracketIdx - 1;
            } else if (candidate[bracketIdx - 1] === "/") {
              dashIdx = bracketIdx - 1;
              wasSlash = true;
            } else {
              dashIdx = -1;
            }
          } else if (lastIndex === Infinity && candidate.includes("/")) {
            dashIdx = candidate.lastIndexOf("/");
            wasSlash = true;
          } else {
            dashIdx = candidate.lastIndexOf("-", lastIndex);
          }

          if (!(dashIdx < 0)) {
            _context.next = 7;
            break;
          }

          return _context.abrupt("break", 16);

        case 7:
          prefix = candidate.slice(0, dashIdx);
          modifier = candidate.slice(wasSlash ? dashIdx : dashIdx + 1);
          lastIndex = dashIdx - 1; // TODO: This feels a bit hacky

          if (!(prefix === "" || modifier === "/")) {
            _context.next = 12;
            break;
          }

          return _context.abrupt("continue", 1);

        case 12:
          _context.next = 14;
          return [prefix, modifier];

        case 14:
          _context.next = 1;
          break;

        case 16:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

function applyPrefix(matches, context) {
  if (matches.length === 0 || context.tailwindConfig.prefix === "") {
    return matches;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var match = _step.value;

      var _match = _slicedToArray(match, 1),
          meta = _match[0];

      if (meta.options.respectPrefix) {
        (function () {
          var container = _postcss["default"].root({
            nodes: [match[1].clone()]
          });

          var classCandidate = match[1].raws.tailwind.classCandidate;
          container.walkRules(function (r) {
            // If this is a negative utility with a dash *before* the prefix we
            // have to ensure that the generated selector matches the candidate
            // Not doing this will cause `-tw-top-1` to generate the class `.tw--top-1`
            // The disconnect between candidate <-> class can cause @apply to hard crash.
            var shouldPrependNegative = classCandidate.startsWith("-");
            r.selector = (0, _prefixSelector["default"])(context.tailwindConfig.prefix, r.selector, shouldPrependNegative);
          });
          match[1] = container.nodes[0];
        })();
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return matches;
}

function applyImportant(matches, classCandidate) {
  if (matches.length === 0) {
    return matches;
  }

  var result = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = matches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          meta = _step2$value[0],
          rule = _step2$value[1];

      var container = _postcss["default"].root({
        nodes: [rule.clone()]
      });

      container.walkRules(function (r) {
        var ast = (0, _postcssselectorparser["default"])().astSync(r.selector); // Remove extraneous selectors that do not include the base candidate

        ast.each(function (sel) {
          return (0, _formatVariantSelector.eliminateIrrelevantSelectors)(sel, classCandidate);
        }); // Update all instances of the base candidate to include the important marker

        (0, _pluginUtils.updateAllClasses)(ast, function (className) {
          return className === classCandidate ? "!".concat(className) : className;
        });
        r.selector = ast.toString();
        r.walkDecls(function (d) {
          return d.important = true;
        });
      });
      result.push([_objectSpread({}, meta, {
        important: true
      }), container.nodes[0]]);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return result;
} // Takes a list of rule tuples and applies a variant like `hover`, sm`,
// whatever to it. We used to do some extra caching here to avoid generating
// a variant of the same rule more than once, but this was never hit because
// we cache at the entire selector level further up the tree.
//
// Technically you can get a cache hit if you have `hover:focus:text-center`
// and `focus:hover:text-center` in the same project, but it doesn't feel
// worth the complexity for that case.


function applyVariant(variant, matches, context) {
  if (matches.length === 0) {
    return matches;
  }
  /** @type {{modifier: string | null, value: string | null}} */


  var args = {
    modifier: null,
    value: _sharedState.NONE
  }; // Retrieve "modifier"

  {
    var _ref2 = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(variant, "/"),
        _ref3 = _toArray(_ref2),
        baseVariant = _ref3[0],
        modifiers = _ref3.slice(1); // This is a hack to support variants with `/` in them, like `ar-1/10/20:text-red-500`
    // In this case 1/10 is a value but /20 is a modifier


    if (modifiers.length > 1) {
      baseVariant = baseVariant + "/" + modifiers.slice(0, -1).join("/");
      modifiers = modifiers.slice(-1);
    }

    if (modifiers.length && !context.variantMap.has(variant)) {
      variant = baseVariant;
      args.modifier = modifiers[0];

      if (!(0, _featureFlags.flagEnabled)(context.tailwindConfig, "generalizedModifiers")) {
        return [];
      }
    }
  } // Retrieve "arbitrary value"

  if (variant.endsWith("]") && !variant.startsWith("[")) {
    // We either have:
    //   @[200px]
    //   group-[:hover]
    //
    // But we don't want:
    //   @-[200px]        (`-` is incorrect)
    //   group[:hover]    (`-` is missing)
    var match = /(.)(-?)\[(.*)\]/g.exec(variant);

    if (match) {
      var _match2 = _slicedToArray(match, 4),
          _char = _match2[1],
          separator = _match2[2],
          value = _match2[3]; // @-[200px] case


      if (_char === "@" && separator === "-") return []; // group[:hover] case

      if (_char !== "@" && separator === "") return [];
      variant = variant.replace("".concat(separator, "[").concat(value, "]"), "");
      args.value = value;
    }
  } // Register arbitrary variants


  if (isArbitraryValue(variant) && !context.variantMap.has(variant)) {
    var sort = context.offsets.recordVariant(variant);
    var selector = (0, _dataTypes.normalize)(variant.slice(1, -1));
    var selectors = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(selector, ","); // We do not support multiple selectors for arbitrary variants

    if (selectors.length > 1) {
      return [];
    }

    if (!selectors.every(_setupContextUtils.isValidVariantFormatString)) {
      return [];
    }

    var records = selectors.map(function (sel, idx) {
      return [context.offsets.applyParallelOffset(sort, idx), (0, _setupContextUtils.parseVariant)(sel.trim())];
    });
    context.variantMap.set(variant, records);
  }

  if (context.variantMap.has(variant)) {
    var _context_variantOptions_get;

    var _context_variantOptions_get_INTERNAL_FEATURES;

    var _meta_collectedFormats;

    var _ret = function () {
      var isArbitraryVariant = isArbitraryValue(variant);
      var internalFeatures = (_context_variantOptions_get_INTERNAL_FEATURES = (_context_variantOptions_get = context.variantOptions.get(variant)) === null || _context_variantOptions_get === void 0 ? void 0 : _context_variantOptions_get[_setupContextUtils.INTERNAL_FEATURES]) !== null && _context_variantOptions_get_INTERNAL_FEATURES !== void 0 ? _context_variantOptions_get_INTERNAL_FEATURES : {};
      var variantFunctionTuples = context.variantMap.get(variant).slice();
      var result = [];

      var respectPrefix = function () {
        if (isArbitraryVariant) return false;
        if (internalFeatures.respectPrefix === false) return false;
        return true;
      }();

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = matches[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              meta = _step3$value[0],
              rule = _step3$value[1];

          // Don't generate variants for user css
          if (meta.layer === "user") {
            continue;
          }

          var container = _postcss["default"].root({
            nodes: [rule.clone()]
          });

          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            var _loop = function _loop() {
              var _step4$value = _slicedToArray(_step4.value, 3),
                  variantSort = _step4$value[0],
                  variantFunction = _step4$value[1],
                  containerFromArray = _step4$value[2];

              var clone = (containerFromArray !== null && containerFromArray !== void 0 ? containerFromArray : container).clone();
              var collectedFormats = [];

              function prepareBackup() {
                // Already prepared, chicken out
                if (clone.raws.neededBackup) {
                  return;
                }

                clone.raws.neededBackup = true;
                clone.walkRules(function (rule) {
                  return rule.raws.originalSelector = rule.selector;
                });
              }

              function modifySelectors(modifierFunction) {
                prepareBackup();
                clone.each(function (rule) {
                  if (rule.type !== "rule") {
                    return;
                  }

                  rule.selectors = rule.selectors.map(function (selector) {
                    return modifierFunction({
                      get className() {
                        return _getClassNameFromSelector(selector);
                      },

                      selector: selector
                    });
                  });
                });
                return clone;
              }

              var ruleWithVariant = variantFunction({
                // Public API
                get container() {
                  prepareBackup();
                  return clone;
                },

                separator: context.tailwindConfig.separator,
                modifySelectors: modifySelectors,
                // Private API for now
                wrap: function wrap(wrapper) {
                  var nodes = clone.nodes;
                  clone.removeAll();
                  wrapper.append(nodes);
                  clone.append(wrapper);
                },
                format: function format(selectorFormat) {
                  collectedFormats.push({
                    format: selectorFormat,
                    respectPrefix: respectPrefix
                  });
                },
                args: args
              }); // It can happen that a list of format strings is returned from within the function. In that
              // case, we have to process them as well. We can use the existing `variantSort`.

              if (Array.isArray(ruleWithVariant)) {
                var _iteratorNormalCompletion5 = true;
                var _didIteratorError5 = false;
                var _iteratorError5 = undefined;

                try {
                  for (var _iterator5 = ruleWithVariant.entries()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var _step5$value = _slicedToArray(_step5.value, 2),
                        idx = _step5$value[0],
                        _variantFunction = _step5$value[1];

                    // This is a little bit scary since we are pushing to an array of items that we are
                    // currently looping over. However, you can also think of it like a processing queue
                    // where you keep handling jobs until everything is done and each job can queue more
                    // jobs if needed.
                    variantFunctionTuples.push([context.offsets.applyParallelOffset(variantSort, idx), _variantFunction, // If the clone has been modified we have to pass that back
                    // though so each rule can use the modified container
                    clone.clone()]);
                  }
                } catch (err) {
                  _didIteratorError5 = true;
                  _iteratorError5 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                      _iterator5["return"]();
                    }
                  } finally {
                    if (_didIteratorError5) {
                      throw _iteratorError5;
                    }
                  }
                }

                return "continue";
              }

              if (typeof ruleWithVariant === "string") {
                collectedFormats.push({
                  format: ruleWithVariant,
                  respectPrefix: respectPrefix
                });
              }

              if (ruleWithVariant === null) {
                return "continue";
              } // We had to backup selectors, therefore we assume that somebody touched
              // `container` or `modifySelectors`. Let's see if they did, so that we
              // can restore the selectors, and collect the format strings.


              if (clone.raws.neededBackup) {
                delete clone.raws.neededBackup;
                clone.walkRules(function (rule) {
                  var before = rule.raws.originalSelector;
                  if (!before) return;
                  delete rule.raws.originalSelector;
                  if (before === rule.selector) return; // No mutation happened

                  var modified = rule.selector; // Rebuild the base selector, this is what plugin authors would do
                  // as well. E.g.: `${variant}${separator}${className}`.
                  // However, plugin authors probably also prepend or append certain
                  // classes, pseudos, ids, ...

                  var rebuiltBase = (0, _postcssselectorparser["default"])(function (selectors) {
                    selectors.walkClasses(function (classNode) {
                      classNode.value = "".concat(variant).concat(context.tailwindConfig.separator).concat(classNode.value);
                    });
                  }).processSync(before); // Now that we know the original selector, the new selector, and
                  // the rebuild part in between, we can replace the part that plugin
                  // authors need to rebuild with `&`, and eventually store it in the
                  // collectedFormats. Similar to what `format('...')` would do.
                  //
                  // E.g.:
                  //                   variant: foo
                  //                  selector: .markdown > p
                  //      modified (by plugin): .foo .foo\\:markdown > p
                  //    rebuiltBase (internal): .foo\\:markdown > p
                  //                    format: .foo &

                  collectedFormats.push({
                    format: modified.replace(rebuiltBase, "&"),
                    respectPrefix: respectPrefix
                  });
                  rule.selector = before;
                });
              } // This tracks the originating layer for the variant
              // For example:
              // .sm:underline {} is a variant of something in the utilities layer
              // .sm:container {} is a variant of the container component


              clone.nodes[0].raws.tailwind = _objectSpread({}, clone.nodes[0].raws.tailwind, {
                parentLayer: meta.layer
              });
              var withOffset = [_objectSpread({}, meta, {
                sort: context.offsets.applyVariantOffset(meta.sort, variantSort, Object.assign(args, context.variantOptions.get(variant))),
                collectedFormats: ((_meta_collectedFormats = meta.collectedFormats) !== null && _meta_collectedFormats !== void 0 ? _meta_collectedFormats : []).concat(collectedFormats)
              }), clone.nodes[0]];
              result.push(withOffset);
            };

            for (var _iterator4 = variantFunctionTuples[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var _ret2 = _loop();

              if (_ret2 === "continue") continue;
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return {
        v: result
      };
    }();

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return [];
}

function parseRules(rule, cache) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // PostCSS node
  if (!(0, _isPlainObject["default"])(rule) && !Array.isArray(rule)) {
    return [[rule], options];
  } // Tuple


  if (Array.isArray(rule)) {
    return parseRules(rule[0], cache, rule[1]);
  } // Simple object


  if (!cache.has(rule)) {
    cache.set(rule, (0, _parseObjectStyles["default"])(rule));
  }

  return [cache.get(rule), options];
}

var IS_VALID_PROPERTY_NAME = /^[a-z_-]/;

function isValidPropName(name) {
  return IS_VALID_PROPERTY_NAME.test(name);
}
/**
 * @param {string} declaration
 * @returns {boolean}
 */


function looksLikeUri(declaration) {
  // Quick bailout for obvious non-urls
  // This doesn't support schemes that don't use a leading // but that's unlikely to be a problem
  if (!declaration.includes("://")) {
    return false;
  }

  try {
    var url = new URL(declaration);
    return url.scheme !== "" && url.host !== "";
  } catch (err) {
    // Definitely not a valid url
    return false;
  }
}

function isParsableNode(node) {
  var isParsable = true;
  node.walkDecls(function (decl) {
    if (!isParsableCssValue(decl.prop, decl.value)) {
      isParsable = false;
      return false;
    }
  });
  return isParsable;
}

function isParsableCssValue(property, value) {
  // We don't want to to treat [https://example.com] as a custom property
  // Even though, according to the CSS grammar, it's a totally valid CSS declaration
  // So we short-circuit here by checking if the custom property looks like a url
  if (looksLikeUri("".concat(property, ":").concat(value))) {
    return false;
  }

  try {
    _postcss["default"].parse("a{".concat(property, ":").concat(value, "}")).toResult();

    return true;
  } catch (err) {
    return false;
  }
}

function extractArbitraryProperty(classCandidate, context) {
  var _classCandidate_match;

  var _ref4 = (_classCandidate_match = classCandidate.match(/^\[([a-zA-Z0-9-_]+):(\S+)\]$/)) !== null && _classCandidate_match !== void 0 ? _classCandidate_match : [],
      _ref5 = _slicedToArray(_ref4, 3),
      property = _ref5[1],
      value = _ref5[2];

  if (value === undefined) {
    return null;
  }

  if (!isValidPropName(property)) {
    return null;
  }

  if (!(0, _isSyntacticallyValidPropertyValue["default"])(value)) {
    return null;
  }

  var normalized = (0, _dataTypes.normalize)(value, {
    property: property
  });

  if (!isParsableCssValue(property, normalized)) {
    return null;
  }

  var sort = context.offsets.arbitraryProperty();
  return [[{
    sort: sort,
    layer: "utilities"
  }, function () {
    return _defineProperty({}, (0, _nameClass.asClass)(classCandidate), _defineProperty({}, property, normalized));
  }]];
}

function resolveMatchedPlugins(classCandidate, context) {
  var candidatePrefix, negative, twConfigPrefix, twConfigPrefixLen, hasMatchingPrefix, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, _step6$value, prefix, modifier;

  return regeneratorRuntime.wrap(function resolveMatchedPlugins$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          if (!context.candidateRuleMap.has(classCandidate)) {
            _context3.next = 3;
            break;
          }

          _context3.next = 3;
          return [context.candidateRuleMap.get(classCandidate), "DEFAULT"];

        case 3:
          return _context3.delegateYield(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee(arbitraryPropertyRule) {
            return regeneratorRuntime.wrap(function _callee$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!(arbitraryPropertyRule !== null)) {
                      _context2.next = 3;
                      break;
                    }

                    _context2.next = 3;
                    return [arbitraryPropertyRule, "DEFAULT"];

                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee);
          })(extractArbitraryProperty(classCandidate, context)), "t0", 4);

        case 4:
          candidatePrefix = classCandidate;
          negative = false;
          twConfigPrefix = context.tailwindConfig.prefix;
          twConfigPrefixLen = twConfigPrefix.length;
          hasMatchingPrefix = candidatePrefix.startsWith(twConfigPrefix) || candidatePrefix.startsWith("-".concat(twConfigPrefix));

          if (candidatePrefix[twConfigPrefixLen] === "-" && hasMatchingPrefix) {
            negative = true;
            candidatePrefix = twConfigPrefix + candidatePrefix.slice(twConfigPrefixLen + 1);
          }

          if (!(negative && context.candidateRuleMap.has(candidatePrefix))) {
            _context3.next = 13;
            break;
          }

          _context3.next = 13;
          return [context.candidateRuleMap.get(candidatePrefix), "-DEFAULT"];

        case 13:
          _iteratorNormalCompletion6 = true;
          _didIteratorError6 = false;
          _iteratorError6 = undefined;
          _context3.prev = 16;
          _iterator6 = candidatePermutations(candidatePrefix)[Symbol.iterator]();

        case 18:
          if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
            _context3.next = 26;
            break;
          }

          _step6$value = _slicedToArray(_step6.value, 2), prefix = _step6$value[0], modifier = _step6$value[1];

          if (!context.candidateRuleMap.has(prefix)) {
            _context3.next = 23;
            break;
          }

          _context3.next = 23;
          return [context.candidateRuleMap.get(prefix), negative ? "-".concat(modifier) : modifier];

        case 23:
          _iteratorNormalCompletion6 = true;
          _context3.next = 18;
          break;

        case 26:
          _context3.next = 32;
          break;

        case 28:
          _context3.prev = 28;
          _context3.t1 = _context3["catch"](16);
          _didIteratorError6 = true;
          _iteratorError6 = _context3.t1;

        case 32:
          _context3.prev = 32;
          _context3.prev = 33;

          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }

        case 35:
          _context3.prev = 35;

          if (!_didIteratorError6) {
            _context3.next = 38;
            break;
          }

          throw _iteratorError6;

        case 38:
          return _context3.finish(35);

        case 39:
          return _context3.finish(32);

        case 40:
        case "end":
          return _context3.stop();
      }
    }
  }, _marked2, null, [[16, 28, 32, 40], [33,, 35, 39]]);
}

function splitWithSeparator(input, separator) {
  if (input === _sharedState.NOT_ON_DEMAND) {
    return [_sharedState.NOT_ON_DEMAND];
  }

  return (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, separator);
}

function recordCandidates(matches, classCandidate) {
  var _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, match, _match__options, _match__options_preserveSource;

  return regeneratorRuntime.wrap(function recordCandidates$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _iteratorNormalCompletion7 = true;
          _didIteratorError7 = false;
          _iteratorError7 = undefined;
          _context4.prev = 3;
          _iterator7 = matches[Symbol.iterator]();

        case 5:
          if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
            _context4.next = 13;
            break;
          }

          match = _step7.value;
          match[1].raws.tailwind = _objectSpread({}, match[1].raws.tailwind, {
            classCandidate: classCandidate,
            preserveSource: (_match__options_preserveSource = (_match__options = match[0].options) === null || _match__options === void 0 ? void 0 : _match__options.preserveSource) !== null && _match__options_preserveSource !== void 0 ? _match__options_preserveSource : false
          });
          _context4.next = 10;
          return match;

        case 10:
          _iteratorNormalCompletion7 = true;
          _context4.next = 5;
          break;

        case 13:
          _context4.next = 19;
          break;

        case 15:
          _context4.prev = 15;
          _context4.t0 = _context4["catch"](3);
          _didIteratorError7 = true;
          _iteratorError7 = _context4.t0;

        case 19:
          _context4.prev = 19;
          _context4.prev = 20;

          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }

        case 22:
          _context4.prev = 22;

          if (!_didIteratorError7) {
            _context4.next = 25;
            break;
          }

          throw _iteratorError7;

        case 25:
          return _context4.finish(22);

        case 26:
          return _context4.finish(19);

        case 27:
        case "end":
          return _context4.stop();
      }
    }
  }, _marked3, null, [[3, 15, 19, 27], [20,, 22, 26]]);
}

function _resolveMatches(candidate, context) {
  var separator, _splitWithSeparator$r, _splitWithSeparator$r2, classCandidate, variants, important, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _loop2, _iterator8, _step8, _sort_options, _sort_options_types, _sort_options1, _findFallback, _typesByMatches_get, _ret3;

  return regeneratorRuntime.wrap(function _resolveMatches$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          separator = context.tailwindConfig.separator;
          _splitWithSeparator$r = splitWithSeparator(candidate, separator).reverse(), _splitWithSeparator$r2 = _toArray(_splitWithSeparator$r), classCandidate = _splitWithSeparator$r2[0], variants = _splitWithSeparator$r2.slice(1);
          important = false;

          if (classCandidate.startsWith("!")) {
            important = true;
            classCandidate = classCandidate.slice(1);
          } // TODO: Reintroduce this in ways that doesn't break on false positives
          // function sortAgainst(toSort, against) {
          //   return toSort.slice().sort((a, z) => {
          //     return bigSign(against.get(a)[0] - against.get(z)[0])
          //   })
          // }
          // let sorted = sortAgainst(variants, context.variantMap)
          // if (sorted.toString() !== variants.toString()) {
          //   let corrected = sorted.reverse().concat(classCandidate).join(':')
          //   throw new Error(`Class ${candidate} should be written as ${corrected}`)
          // }


          _iteratorNormalCompletion8 = true;
          _didIteratorError8 = false;
          _iteratorError8 = undefined;
          _context6.prev = 7;
          _loop2 =
          /*#__PURE__*/
          regeneratorRuntime.mark(function _loop2() {
            var matchedPlugins, matches, typesByMatches, _matchedPlugins, plugins, modifier, isOnlyPlugin, _iteratorNormalCompletion9, _didIteratorError9, _iteratorError9, _iterator9, _step9, _step9$value, sort, plugin, matchesPerPlugin, _iteratorNormalCompletion17, _didIteratorError17, _iteratorError17, _iterator17, _step17, ruleSet, _parseRules, _parseRules2, _rules, options, _iteratorNormalCompletion18, _didIteratorError18, _iteratorError18, _iterator18, _step18, rule, _ruleSet, _parseRules3, _parseRules4, _rules2, _options, _iteratorNormalCompletion19, _didIteratorError19, _iteratorError19, _iterator19, _step19, _rule, matchingTypes, findFallback, _matches$reduce, _matches$reduce2, withAny, withoutAny, fallback, typesPerPlugin, _iteratorNormalCompletion10, _didIteratorError10, _iteratorError10, _iterator10, _step10, pluginTypes, _iteratorNormalCompletion12, _didIteratorError12, _iteratorError12, _iterator12, _step12, type, removeFromOwnGroup, _iteratorNormalCompletion13, _didIteratorError13, _iteratorError13, _iterator13, _step13, otherGroup, messages, _iteratorNormalCompletion11, _didIteratorError11, _iteratorError11, _iterator11, _step11, _step11$value, idx, group, _iteratorNormalCompletion14, _didIteratorError14, _iteratorError14, _iterator14, _step14, _type, rules, _iteratorNormalCompletion15, _didIteratorError15, _iteratorError15, _iterator15, _step15, variant, _iteratorNormalCompletion16, _didIteratorError16, _iteratorError16, _iterator16, _step16, match;

            return regeneratorRuntime.wrap(function _loop2$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    matchedPlugins = _step8.value;
                    matches = [];
                    typesByMatches = new Map();
                    _matchedPlugins = _slicedToArray(matchedPlugins, 2), plugins = _matchedPlugins[0], modifier = _matchedPlugins[1];
                    isOnlyPlugin = plugins.length === 1;
                    _iteratorNormalCompletion9 = true;
                    _didIteratorError9 = false;
                    _iteratorError9 = undefined;
                    _context5.prev = 8;
                    _iterator9 = plugins[Symbol.iterator]();

                  case 10:
                    if (_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done) {
                      _context5.next = 86;
                      break;
                    }

                    _step9$value = _slicedToArray(_step9.value, 2), sort = _step9$value[0], plugin = _step9$value[1];
                    matchesPerPlugin = [];

                    if (!(typeof plugin === "function")) {
                      _context5.next = 60;
                      break;
                    }

                    _iteratorNormalCompletion17 = true;
                    _didIteratorError17 = false;
                    _iteratorError17 = undefined;
                    _context5.prev = 17;
                    _iterator17 = [].concat(plugin(modifier, {
                      isOnlyPlugin: isOnlyPlugin
                    }))[Symbol.iterator]();

                  case 19:
                    if (_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done) {
                      _context5.next = 44;
                      break;
                    }

                    ruleSet = _step17.value;
                    _parseRules = parseRules(ruleSet, context.postCssNodeCache), _parseRules2 = _slicedToArray(_parseRules, 2), _rules = _parseRules2[0], options = _parseRules2[1];
                    _iteratorNormalCompletion18 = true;
                    _didIteratorError18 = false;
                    _iteratorError18 = undefined;
                    _context5.prev = 25;

                    for (_iterator18 = _rules[Symbol.iterator](); !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
                      rule = _step18.value;
                      matchesPerPlugin.push([_objectSpread({}, sort, {
                        options: _objectSpread({}, sort.options, {}, options)
                      }), rule]);
                    }

                    _context5.next = 33;
                    break;

                  case 29:
                    _context5.prev = 29;
                    _context5.t0 = _context5["catch"](25);
                    _didIteratorError18 = true;
                    _iteratorError18 = _context5.t0;

                  case 33:
                    _context5.prev = 33;
                    _context5.prev = 34;

                    if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
                      _iterator18["return"]();
                    }

                  case 36:
                    _context5.prev = 36;

                    if (!_didIteratorError18) {
                      _context5.next = 39;
                      break;
                    }

                    throw _iteratorError18;

                  case 39:
                    return _context5.finish(36);

                  case 40:
                    return _context5.finish(33);

                  case 41:
                    _iteratorNormalCompletion17 = true;
                    _context5.next = 19;
                    break;

                  case 44:
                    _context5.next = 50;
                    break;

                  case 46:
                    _context5.prev = 46;
                    _context5.t1 = _context5["catch"](17);
                    _didIteratorError17 = true;
                    _iteratorError17 = _context5.t1;

                  case 50:
                    _context5.prev = 50;
                    _context5.prev = 51;

                    if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
                      _iterator17["return"]();
                    }

                  case 53:
                    _context5.prev = 53;

                    if (!_didIteratorError17) {
                      _context5.next = 56;
                      break;
                    }

                    throw _iteratorError17;

                  case 56:
                    return _context5.finish(53);

                  case 57:
                    return _context5.finish(50);

                  case 58:
                    _context5.next = 82;
                    break;

                  case 60:
                    if (!(modifier === "DEFAULT" || modifier === "-DEFAULT")) {
                      _context5.next = 82;
                      break;
                    }

                    _ruleSet = plugin;
                    _parseRules3 = parseRules(_ruleSet, context.postCssNodeCache), _parseRules4 = _slicedToArray(_parseRules3, 2), _rules2 = _parseRules4[0], _options = _parseRules4[1];
                    _iteratorNormalCompletion19 = true;
                    _didIteratorError19 = false;
                    _iteratorError19 = undefined;
                    _context5.prev = 66;

                    for (_iterator19 = _rules2[Symbol.iterator](); !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
                      _rule = _step19.value;
                      matchesPerPlugin.push([_objectSpread({}, sort, {
                        options: _objectSpread({}, sort.options, {}, _options)
                      }), _rule]);
                    }

                    _context5.next = 74;
                    break;

                  case 70:
                    _context5.prev = 70;
                    _context5.t2 = _context5["catch"](66);
                    _didIteratorError19 = true;
                    _iteratorError19 = _context5.t2;

                  case 74:
                    _context5.prev = 74;
                    _context5.prev = 75;

                    if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
                      _iterator19["return"]();
                    }

                  case 77:
                    _context5.prev = 77;

                    if (!_didIteratorError19) {
                      _context5.next = 80;
                      break;
                    }

                    throw _iteratorError19;

                  case 80:
                    return _context5.finish(77);

                  case 81:
                    return _context5.finish(74);

                  case 82:
                    if (matchesPerPlugin.length > 0) {
                      matchingTypes = Array.from((0, _pluginUtils.getMatchingTypes)((_sort_options_types = (_sort_options = sort.options) === null || _sort_options === void 0 ? void 0 : _sort_options.types) !== null && _sort_options_types !== void 0 ? _sort_options_types : [], modifier, (_sort_options1 = sort.options) !== null && _sort_options1 !== void 0 ? _sort_options1 : {}, context.tailwindConfig)).map(function (_ref16) {
                        var _ref17 = _slicedToArray(_ref16, 2),
                            _ = _ref17[0],
                            type = _ref17[1];

                        return type;
                      });

                      if (matchingTypes.length > 0) {
                        typesByMatches.set(matchesPerPlugin, matchingTypes);
                      }

                      matches.push(matchesPerPlugin);
                    }

                  case 83:
                    _iteratorNormalCompletion9 = true;
                    _context5.next = 10;
                    break;

                  case 86:
                    _context5.next = 92;
                    break;

                  case 88:
                    _context5.prev = 88;
                    _context5.t3 = _context5["catch"](8);
                    _didIteratorError9 = true;
                    _iteratorError9 = _context5.t3;

                  case 92:
                    _context5.prev = 92;
                    _context5.prev = 93;

                    if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                      _iterator9["return"]();
                    }

                  case 95:
                    _context5.prev = 95;

                    if (!_didIteratorError9) {
                      _context5.next = 98;
                      break;
                    }

                    throw _iteratorError9;

                  case 98:
                    return _context5.finish(95);

                  case 99:
                    return _context5.finish(92);

                  case 100:
                    if (!isArbitraryValue(modifier)) {
                      _context5.next = 242;
                      break;
                    }

                    if (!(matches.length > 1)) {
                      _context5.next = 241;
                      break;
                    }

                    findFallback = function findFallback(matches) {
                      // If only a single plugin matches, let's take that one
                      if (matches.length === 1) {
                        return matches[0];
                      } // Otherwise, find the plugin that creates a valid rule given the arbitrary value, and
                      // also has the correct type which preferOnConflicts the plugin in case of clashes.


                      return matches.find(function (rules) {
                        var matchingTypes = typesByMatches.get(rules);
                        return rules.some(function (_ref11) {
                          var _ref12 = _slicedToArray(_ref11, 2),
                              options = _ref12[0].options,
                              rule = _ref12[1];

                          if (!isParsableNode(rule)) {
                            return false;
                          }

                          return options.types.some(function (_ref13) {
                            var type = _ref13.type,
                                preferOnConflict = _ref13.preferOnConflict;
                            return matchingTypes.includes(type) && preferOnConflict;
                          });
                        });
                      });
                    };

                    // Partition plugins in 2 categories so that we can start searching in the plugins that
                    // don't have `any` as a type first.
                    _matches$reduce = matches.reduce(function (group, plugin) {
                      var hasAnyType = plugin.some(function (_ref8) {
                        var _ref9 = _slicedToArray(_ref8, 1),
                            options = _ref9[0].options;

                        return options.types.some(function (_ref10) {
                          var type = _ref10.type;
                          return type === "any";
                        });
                      });

                      if (hasAnyType) {
                        group[0].push(plugin);
                      } else {
                        group[1].push(plugin);
                      }

                      return group;
                    }, [[], []]), _matches$reduce2 = _slicedToArray(_matches$reduce, 2), withAny = _matches$reduce2[0], withoutAny = _matches$reduce2[1];
                    // Try to find a fallback plugin, because we already know that multiple plugins matched for
                    // the given arbitrary value.
                    fallback = (_findFallback = findFallback(withoutAny)) !== null && _findFallback !== void 0 ? _findFallback : findFallback(withAny);

                    if (!fallback) {
                      _context5.next = 109;
                      break;
                    }

                    matches = [fallback];
                    _context5.next = 241;
                    break;

                  case 109:
                    typesPerPlugin = matches.map(function (match) {
                      return new Set(_toConsumableArray((_typesByMatches_get = typesByMatches.get(match)) !== null && _typesByMatches_get !== void 0 ? _typesByMatches_get : []));
                    }); // Remove duplicates, so that we can detect proper unique types for each plugin.

                    _iteratorNormalCompletion10 = true;
                    _didIteratorError10 = false;
                    _iteratorError10 = undefined;
                    _context5.prev = 113;
                    _iterator10 = typesPerPlugin[Symbol.iterator]();

                  case 115:
                    if (_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done) {
                      _context5.next = 173;
                      break;
                    }

                    pluginTypes = _step10.value;
                    _iteratorNormalCompletion12 = true;
                    _didIteratorError12 = false;
                    _iteratorError12 = undefined;
                    _context5.prev = 120;
                    _iterator12 = pluginTypes[Symbol.iterator]();

                  case 122:
                    if (_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done) {
                      _context5.next = 156;
                      break;
                    }

                    type = _step12.value;
                    removeFromOwnGroup = false;
                    _iteratorNormalCompletion13 = true;
                    _didIteratorError13 = false;
                    _iteratorError13 = undefined;
                    _context5.prev = 128;
                    _iterator13 = typesPerPlugin[Symbol.iterator]();

                  case 130:
                    if (_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done) {
                      _context5.next = 138;
                      break;
                    }

                    otherGroup = _step13.value;

                    if (!(pluginTypes === otherGroup)) {
                      _context5.next = 134;
                      break;
                    }

                    return _context5.abrupt("continue", 135);

                  case 134:
                    if (otherGroup.has(type)) {
                      otherGroup["delete"](type);
                      removeFromOwnGroup = true;
                    }

                  case 135:
                    _iteratorNormalCompletion13 = true;
                    _context5.next = 130;
                    break;

                  case 138:
                    _context5.next = 144;
                    break;

                  case 140:
                    _context5.prev = 140;
                    _context5.t4 = _context5["catch"](128);
                    _didIteratorError13 = true;
                    _iteratorError13 = _context5.t4;

                  case 144:
                    _context5.prev = 144;
                    _context5.prev = 145;

                    if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
                      _iterator13["return"]();
                    }

                  case 147:
                    _context5.prev = 147;

                    if (!_didIteratorError13) {
                      _context5.next = 150;
                      break;
                    }

                    throw _iteratorError13;

                  case 150:
                    return _context5.finish(147);

                  case 151:
                    return _context5.finish(144);

                  case 152:
                    if (removeFromOwnGroup) pluginTypes["delete"](type);

                  case 153:
                    _iteratorNormalCompletion12 = true;
                    _context5.next = 122;
                    break;

                  case 156:
                    _context5.next = 162;
                    break;

                  case 158:
                    _context5.prev = 158;
                    _context5.t5 = _context5["catch"](120);
                    _didIteratorError12 = true;
                    _iteratorError12 = _context5.t5;

                  case 162:
                    _context5.prev = 162;
                    _context5.prev = 163;

                    if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
                      _iterator12["return"]();
                    }

                  case 165:
                    _context5.prev = 165;

                    if (!_didIteratorError12) {
                      _context5.next = 168;
                      break;
                    }

                    throw _iteratorError12;

                  case 168:
                    return _context5.finish(165);

                  case 169:
                    return _context5.finish(162);

                  case 170:
                    _iteratorNormalCompletion10 = true;
                    _context5.next = 115;
                    break;

                  case 173:
                    _context5.next = 179;
                    break;

                  case 175:
                    _context5.prev = 175;
                    _context5.t6 = _context5["catch"](113);
                    _didIteratorError10 = true;
                    _iteratorError10 = _context5.t6;

                  case 179:
                    _context5.prev = 179;
                    _context5.prev = 180;

                    if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
                      _iterator10["return"]();
                    }

                  case 182:
                    _context5.prev = 182;

                    if (!_didIteratorError10) {
                      _context5.next = 185;
                      break;
                    }

                    throw _iteratorError10;

                  case 185:
                    return _context5.finish(182);

                  case 186:
                    return _context5.finish(179);

                  case 187:
                    messages = [];
                    _iteratorNormalCompletion11 = true;
                    _didIteratorError11 = false;
                    _iteratorError11 = undefined;
                    _context5.prev = 191;
                    _iterator11 = typesPerPlugin.entries()[Symbol.iterator]();

                  case 193:
                    if (_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done) {
                      _context5.next = 225;
                      break;
                    }

                    _step11$value = _slicedToArray(_step11.value, 2), idx = _step11$value[0], group = _step11$value[1];
                    _iteratorNormalCompletion14 = true;
                    _didIteratorError14 = false;
                    _iteratorError14 = undefined;
                    _context5.prev = 198;
                    _iterator14 = group[Symbol.iterator]();

                  case 200:
                    if (_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done) {
                      _context5.next = 208;
                      break;
                    }

                    _type = _step14.value;
                    rules = matches[idx].map(function (_ref14) {
                      var _ref15 = _slicedToArray(_ref14, 2),
                          rule = _ref15[1];

                      return rule;
                    }).flat().map(function (rule) {
                      return rule.toString().split("\n").slice(1, -1) // Remove selector and closing '}'
                      .map(function (line) {
                        return line.trim();
                      }).map(function (x) {
                        return "      ".concat(x);
                      }) // Re-indent
                      .join("\n");
                    }).join("\n\n");
                    messages.push("  Use `".concat(candidate.replace("[", "[".concat(_type, ":")), "` for `").concat(rules.trim(), "`"));
                    return _context5.abrupt("break", 208);

                  case 205:
                    _iteratorNormalCompletion14 = true;
                    _context5.next = 200;
                    break;

                  case 208:
                    _context5.next = 214;
                    break;

                  case 210:
                    _context5.prev = 210;
                    _context5.t7 = _context5["catch"](198);
                    _didIteratorError14 = true;
                    _iteratorError14 = _context5.t7;

                  case 214:
                    _context5.prev = 214;
                    _context5.prev = 215;

                    if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
                      _iterator14["return"]();
                    }

                  case 217:
                    _context5.prev = 217;

                    if (!_didIteratorError14) {
                      _context5.next = 220;
                      break;
                    }

                    throw _iteratorError14;

                  case 220:
                    return _context5.finish(217);

                  case 221:
                    return _context5.finish(214);

                  case 222:
                    _iteratorNormalCompletion11 = true;
                    _context5.next = 193;
                    break;

                  case 225:
                    _context5.next = 231;
                    break;

                  case 227:
                    _context5.prev = 227;
                    _context5.t8 = _context5["catch"](191);
                    _didIteratorError11 = true;
                    _iteratorError11 = _context5.t8;

                  case 231:
                    _context5.prev = 231;
                    _context5.prev = 232;

                    if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
                      _iterator11["return"]();
                    }

                  case 234:
                    _context5.prev = 234;

                    if (!_didIteratorError11) {
                      _context5.next = 237;
                      break;
                    }

                    throw _iteratorError11;

                  case 237:
                    return _context5.finish(234);

                  case 238:
                    return _context5.finish(231);

                  case 239:
                    _log["default"].warn(["The class `".concat(candidate, "` is ambiguous and matches multiple utilities.")].concat(messages, ["If this is content and not a class, replace it with `".concat(candidate.replace("[", "&lsqb;").replace("]", "&rsqb;"), "` to silence this warning.")]));

                    return _context5.abrupt("return", "continue");

                  case 241:
                    matches = matches.map(function (list) {
                      return list.filter(function (match) {
                        return isParsableNode(match[1]);
                      });
                    });

                  case 242:
                    matches = matches.flat();
                    matches = Array.from(recordCandidates(matches, classCandidate));
                    matches = applyPrefix(matches, context);

                    if (important) {
                      matches = applyImportant(matches, classCandidate);
                    }

                    _iteratorNormalCompletion15 = true;
                    _didIteratorError15 = false;
                    _iteratorError15 = undefined;
                    _context5.prev = 249;

                    for (_iterator15 = variants[Symbol.iterator](); !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                      variant = _step15.value;
                      matches = applyVariant(variant, matches, context);
                    }

                    _context5.next = 257;
                    break;

                  case 253:
                    _context5.prev = 253;
                    _context5.t9 = _context5["catch"](249);
                    _didIteratorError15 = true;
                    _iteratorError15 = _context5.t9;

                  case 257:
                    _context5.prev = 257;
                    _context5.prev = 258;

                    if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
                      _iterator15["return"]();
                    }

                  case 260:
                    _context5.prev = 260;

                    if (!_didIteratorError15) {
                      _context5.next = 263;
                      break;
                    }

                    throw _iteratorError15;

                  case 263:
                    return _context5.finish(260);

                  case 264:
                    return _context5.finish(257);

                  case 265:
                    _iteratorNormalCompletion16 = true;
                    _didIteratorError16 = false;
                    _iteratorError16 = undefined;
                    _context5.prev = 268;
                    _iterator16 = matches[Symbol.iterator]();

                  case 270:
                    if (_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done) {
                      _context5.next = 281;
                      break;
                    }

                    match = _step16.value;
                    match[1].raws.tailwind = _objectSpread({}, match[1].raws.tailwind, {
                      candidate: candidate
                    }); // Apply final format selector

                    match = applyFinalFormat(match, {
                      context: context,
                      candidate: candidate
                    }); // Skip rules with invalid selectors
                    // This will cause the candidate to be added to the "not class"
                    // cache skipping it entirely for future builds

                    if (!(match === null)) {
                      _context5.next = 276;
                      break;
                    }

                    return _context5.abrupt("continue", 278);

                  case 276:
                    _context5.next = 278;
                    return match;

                  case 278:
                    _iteratorNormalCompletion16 = true;
                    _context5.next = 270;
                    break;

                  case 281:
                    _context5.next = 287;
                    break;

                  case 283:
                    _context5.prev = 283;
                    _context5.t10 = _context5["catch"](268);
                    _didIteratorError16 = true;
                    _iteratorError16 = _context5.t10;

                  case 287:
                    _context5.prev = 287;
                    _context5.prev = 288;

                    if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
                      _iterator16["return"]();
                    }

                  case 290:
                    _context5.prev = 290;

                    if (!_didIteratorError16) {
                      _context5.next = 293;
                      break;
                    }

                    throw _iteratorError16;

                  case 293:
                    return _context5.finish(290);

                  case 294:
                    return _context5.finish(287);

                  case 295:
                  case "end":
                    return _context5.stop();
                }
              }
            }, _loop2, null, [[8, 88, 92, 100], [17, 46, 50, 58], [25, 29, 33, 41], [34,, 36, 40], [51,, 53, 57], [66, 70, 74, 82], [75,, 77, 81], [93,, 95, 99], [113, 175, 179, 187], [120, 158, 162, 170], [128, 140, 144, 152], [145,, 147, 151], [163,, 165, 169], [180,, 182, 186], [191, 227, 231, 239], [198, 210, 214, 222], [215,, 217, 221], [232,, 234, 238], [249, 253, 257, 265], [258,, 260, 264], [268, 283, 287, 295], [288,, 290, 294]]);
          });
          _iterator8 = resolveMatchedPlugins(classCandidate, context)[Symbol.iterator]();

        case 10:
          if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
            _context6.next = 18;
            break;
          }

          return _context6.delegateYield(_loop2(), "t0", 12);

        case 12:
          _ret3 = _context6.t0;

          if (!(_ret3 === "continue")) {
            _context6.next = 15;
            break;
          }

          return _context6.abrupt("continue", 15);

        case 15:
          _iteratorNormalCompletion8 = true;
          _context6.next = 10;
          break;

        case 18:
          _context6.next = 24;
          break;

        case 20:
          _context6.prev = 20;
          _context6.t1 = _context6["catch"](7);
          _didIteratorError8 = true;
          _iteratorError8 = _context6.t1;

        case 24:
          _context6.prev = 24;
          _context6.prev = 25;

          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }

        case 27:
          _context6.prev = 27;

          if (!_didIteratorError8) {
            _context6.next = 30;
            break;
          }

          throw _iteratorError8;

        case 30:
          return _context6.finish(27);

        case 31:
          return _context6.finish(24);

        case 32:
        case "end":
          return _context6.stop();
      }
    }
  }, _marked4, null, [[7, 20, 24, 32], [25,, 27, 31]]);
}

function applyFinalFormat(match, _ref18) {
  var context = _ref18.context,
      candidate = _ref18.candidate;

  if (!match[0].collectedFormats) {
    return match;
  }

  var isValid = true;
  var finalFormat;

  try {
    finalFormat = (0, _formatVariantSelector.formatVariantSelector)(match[0].collectedFormats, {
      context: context,
      candidate: candidate
    });
  } catch (_unused) {
    // The format selector we produced is invalid
    // This could be because:
    // - A bug exists
    // - A plugin introduced an invalid variant selector (ex: `addVariant('foo', '&;foo')`)
    // - The user used an invalid arbitrary variant (ex: `[&;foo]:underline`)
    // Either way the build will fail because of this
    // We would rather that the build pass "silently" given that this could
    // happen because of picking up invalid things when scanning content
    // So we'll throw out the candidate instead
    return null;
  }

  var container = _postcss["default"].root({
    nodes: [match[1].clone()]
  });

  container.walkRules(function (rule) {
    if (inKeyframes(rule)) {
      return;
    }

    try {
      var selector = (0, _formatVariantSelector.finalizeSelector)(rule.selector, finalFormat, {
        candidate: candidate,
        context: context
      }); // Finalize Selector determined that this candidate is irrelevant
      // TODO: This elimination should happen earlier so this never happens

      if (selector === null) {
        rule.remove();
        return;
      }

      rule.selector = selector;
    } catch (_unused2) {
      // If this selector is invalid we also want to skip it
      // But it's likely that being invalid here means there's a bug in a plugin rather than too loosely matching content
      isValid = false;
      return false;
    }
  });

  if (!isValid) {
    return null;
  }

  match[1] = container.nodes[0];
  return match;
}

function inKeyframes(rule) {
  return rule.parent && rule.parent.type === "atrule" && rule.parent.name === "keyframes";
}

function getImportantStrategy(important) {
  if (important === true) {
    return function (rule) {
      if (inKeyframes(rule)) {
        return;
      }

      rule.walkDecls(function (d) {
        if (d.parent.type === "rule" && !inKeyframes(d.parent)) {
          d.important = true;
        }
      });
    };
  }

  if (typeof important === "string") {
    return function (rule) {
      if (inKeyframes(rule)) {
        return;
      }

      rule.selectors = rule.selectors.map(function (selector) {
        return (0, _applyImportantSelector.applyImportantSelector)(selector, important);
      });
    };
  }
}

function _generateRules(candidates, context) {
  var isSorting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var allRules = [];
  var strategy = getImportantStrategy(context.tailwindConfig.important);
  var _iteratorNormalCompletion20 = true;
  var _didIteratorError20 = false;
  var _iteratorError20 = undefined;

  try {
    for (var _iterator20 = candidates[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
      var candidate = _step20.value;

      if (context.notClassCache.has(candidate)) {
        continue;
      }

      if (context.candidateRuleCache.has(candidate)) {
        allRules = allRules.concat(Array.from(context.candidateRuleCache.get(candidate)));
        continue;
      }

      var matches = Array.from(_resolveMatches(candidate, context));

      if (matches.length === 0) {
        context.notClassCache.add(candidate);
        continue;
      }

      context.classCache.set(candidate, matches);

      var _context_candidateRuleCache_get;

      var rules = (_context_candidateRuleCache_get = context.candidateRuleCache.get(candidate)) !== null && _context_candidateRuleCache_get !== void 0 ? _context_candidateRuleCache_get : new Set();
      context.candidateRuleCache.set(candidate, rules);

      for (var _i2 = 0, _matches = matches; _i2 < _matches.length; _i2++) {
        var match = _matches[_i2];

        var _match3 = _slicedToArray(match, 2),
            _match3$ = _match3[0],
            sort = _match3$.sort,
            options = _match3$.options,
            rule = _match3[1];

        if (options.respectImportant && strategy) {
          var container = _postcss["default"].root({
            nodes: [rule.clone()]
          });

          container.walkRules(strategy);
          rule = container.nodes[0];
        } // Note: We have to clone rules during sorting
        // so we eliminate some shared mutable state


        var newEntry = [sort, isSorting ? rule.clone() : rule];
        rules.add(newEntry);
        context.ruleCache.add(newEntry);
        allRules.push(newEntry);
      }
    }
  } catch (err) {
    _didIteratorError20 = true;
    _iteratorError20 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
        _iterator20["return"]();
      }
    } finally {
      if (_didIteratorError20) {
        throw _iteratorError20;
      }
    }
  }

  return allRules;
}

function isArbitraryValue(input) {
  return input.startsWith("[") && input.endsWith("]");
}