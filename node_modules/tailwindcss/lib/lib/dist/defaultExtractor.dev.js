"use strict";

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(buildRegExps);

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "defaultExtractor", {
  enumerable: true,
  get: function get() {
    return defaultExtractor;
  }
});

var _regex =
/*#__PURE__*/
_interop_require_wildcard(require("./regex"));

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}

function _interop_require_wildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache(nodeInterop);

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function defaultExtractor(context) {
  var patterns = Array.from(buildRegExps(context));
  /**
  * @param {string} content
  */

  return function (content) {
    /** @type {(string|string)[]} */
    var results = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = patterns[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var pattern = _step.value;

        var _content_match;

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = ((_content_match = content.match(pattern)) !== null && _content_match !== void 0 ? _content_match : [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var result = _step2.value;
            results.push(clipAtBalancedParens(result));
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return results;
  };
}

function buildRegExps(context) {
  var separator, prefix, utility, variantPatterns, _i, _variantPatterns, variantPattern;

  return regeneratorRuntime.wrap(function buildRegExps$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          separator = context.tailwindConfig.separator;
          prefix = context.tailwindConfig.prefix !== "" ? _regex.optional(_regex.pattern([/-?/, _regex.escape(context.tailwindConfig.prefix)])) : "";
          utility = _regex.any([// Arbitrary properties (without square brackets)
          /\[[^\s:'"`]+:[^\s\[\]]+\]/, // Arbitrary properties with balanced square brackets
          // This is a targeted fix to continue to allow theme()
          // with square brackets to work in arbitrary properties
          // while fixing a problem with the regex matching too much
          /\[[^\s:'"`\]]+:[^\s]+?\[[^\s]+\][^\s]+?\]/, // Utilities
          _regex.pattern([// Utility Name / Group Name
          /-?(?:\w+)/, // Normal/Arbitrary values
          _regex.optional(_regex.any([_regex.pattern([// Arbitrary values
          /-(?:\w+-)*\[[^\s:]+\]/, // Not immediately followed by an `{[(`
          /(?![{([]])/, // optionally followed by an opacity modifier
          /(?:\/[^\s'"`\\><$]*)?/]), _regex.pattern([// Arbitrary values
          /-(?:\w+-)*\[[^\s]+\]/, // Not immediately followed by an `{[(`
          /(?![{([]])/, // optionally followed by an opacity modifier
          /(?:\/[^\s'"`\\$]*)?/]), // Normal values w/o quotes — may include an opacity modifier
          /[-\/][^\s'"`\\$={><]*/]))])]);
          variantPatterns = [// Without quotes
          _regex.any([// This is here to provide special support for the `@` variant
          _regex.pattern([/@\[[^\s"'`]+\](\/[^\s"'`]+)?/, separator]), // With variant modifier (e.g.: group-[..]/modifier)
          _regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]\/\w+/, separator]), _regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s"'`]+\]/, separator]), _regex.pattern([/[^\s"'`\[\\]+/, separator])]), // With quotes allowed
          _regex.any([// With variant modifier (e.g.: group-[..]/modifier)
          _regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]\/\w+/, separator]), _regex.pattern([/([^\s"'`\[\\]+-)?\[[^\s`]+\]/, separator]), _regex.pattern([/[^\s`\[\\]+/, separator])])];
          _i = 0, _variantPatterns = variantPatterns;

        case 5:
          if (!(_i < _variantPatterns.length)) {
            _context.next = 12;
            break;
          }

          variantPattern = _variantPatterns[_i];
          _context.next = 9;
          return _regex.pattern([// Variants
          "((?=((", variantPattern, ")+))\\2)?", // Important (optional)
          /!?/, prefix, utility]);

        case 9:
          _i++;
          _context.next = 5;
          break;

        case 12:
          _context.next = 14;
          return /[^<>"'`\s.(){}[\]#=%$]*[^<>"'`\s.(){}[\]#=%:$]/g;

        case 14:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
} // We want to capture any "special" characters
// AND the characters immediately following them (if there is one)


var SPECIALS = /([\[\]'"`])([^\[\]'"`])?/g;
var ALLOWED_CLASS_CHARACTERS = /[^"'`\s<>\]]+/;
/**
 * Clips a string ensuring that parentheses, quotes, etc… are balanced
 * Used for arbitrary values only
 *
 * We will go past the end of the balanced parens until we find a non-class character
 *
 * Depth matching behavior:
 * w-[calc(100%-theme('spacing[some_key][1.5]'))]']
 *   ┬    ┬          ┬┬       ┬        ┬┬   ┬┬┬┬┬┬┬
 *   1    2          3        4        34   3 210 END
 *   ╰────┴──────────┴────────┴────────┴┴───┴─┴┴┴
 *
 * @param {string} input
 */

function clipAtBalancedParens(input) {
  // We are care about this for arbitrary values
  if (!input.includes("-[")) {
    return input;
  }

  var depth = 0;
  var openStringTypes = []; // Find all parens, brackets, quotes, etc
  // Stop when we end at a balanced pair
  // This is naive and will treat mismatched parens as balanced
  // This shouldn't be a problem in practice though

  var matches = input.matchAll(SPECIALS); // We can't use lookbehind assertions because we have to support Safari
  // So, instead, we've emulated it using capture groups and we'll re-work the matches to accommodate

  matches = Array.from(matches).flatMap(function (match) {
    var _match = _toArray(match),
        groups = _match.slice(1);

    return groups.map(function (group, idx) {
      return Object.assign([], match, {
        index: match.index + idx,
        0: group
      });
    });
  });
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = matches[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var match = _step3.value;
      var _char = match[0];
      var inStringType = openStringTypes[openStringTypes.length - 1];

      if (_char === inStringType) {
        openStringTypes.pop();
      } else if (_char === "'" || _char === '"' || _char === "`") {
        openStringTypes.push(_char);
      }

      if (inStringType) {
        continue;
      } else if (_char === "[") {
        depth++;
        continue;
      } else if (_char === "]") {
        depth--;
        continue;
      } // We've gone one character past the point where we should stop
      // This means that there was an extra closing `]`
      // We'll clip to just before it


      if (depth < 0) {
        return input.substring(0, match.index - 1);
      } // We've finished balancing the brackets but there still may be characters that can be included
      // For example in the class `text-[#336699]/[.35]`
      // The depth goes to `0` at the closing `]` but goes up again at the `[`
      // If we're at zero and encounter a non-class character then we clip the class there


      if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(_char)) {
        return input.substring(0, match.index);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return input;
} // Regular utilities
// {{modifier}:}*{namespace}{-{suffix}}*{/{opacityModifier}}?
// Arbitrary values
// {{modifier}:}*{namespace}-[{arbitraryValue}]{/{opacityModifier}}?
// arbitraryValue: no whitespace, balanced quotes unless within quotes, balanced brackets unless within quotes
// Arbitrary properties
// {{modifier}:}*[{validCssPropertyName}:{arbitraryValue}]