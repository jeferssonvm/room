"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _export(target, all) {
  for (var name in all) {
    Object.defineProperty(target, name, {
      enumerable: true,
      get: all[name]
    });
  }
}

_export(exports, {
  pattern: function pattern() {
    return _pattern;
  },
  withoutCapturing: function withoutCapturing() {
    return _withoutCapturing;
  },
  any: function any() {
    return _any;
  },
  optional: function optional() {
    return _optional;
  },
  zeroOrMore: function zeroOrMore() {
    return _zeroOrMore;
  },
  nestedBrackets: function nestedBrackets() {
    return _nestedBrackets;
  },
  escape: function escape() {
    return _escape;
  }
});

var REGEX_SPECIAL = /[\\^$.*+?()[\]{}|]/g;
var REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);
/**
 * @param {string|RegExp|Array<string|RegExp>} source
 */

function toSource(source) {
  source = Array.isArray(source) ? source : [source];
  source = source.map(function (item) {
    return item instanceof RegExp ? item.source : item;
  });
  return source.join("");
}

function _pattern(source) {
  return new RegExp(toSource(source), "g");
}

function _withoutCapturing(source) {
  return new RegExp("(?:".concat(toSource(source), ")"), "g");
}

function _any(sources) {
  return "(?:".concat(sources.map(toSource).join("|"), ")");
}

function _optional(source) {
  return "(?:".concat(toSource(source), ")?");
}

function _zeroOrMore(source) {
  return "(?:".concat(toSource(source), ")*");
}

function _nestedBrackets(open, close) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return _withoutCapturing([_escape(open), /[^\s]*/, depth === 1 ? "[^".concat(_escape(open)).concat(_escape(close), "s]*") : _any(["[^".concat(_escape(open)).concat(_escape(close), "s]*"), _nestedBrackets(open, close, depth - 1)]), /[^\s]*/, _escape(close)]);
}

function _escape(string) {
  return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, "\\$&") : string || "";
}