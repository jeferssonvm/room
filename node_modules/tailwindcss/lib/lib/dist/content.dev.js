// @ts-check
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _export(target, all) {
  for (var name in all) {
    Object.defineProperty(target, name, {
      enumerable: true,
      get: all[name]
    });
  }
}

_export(exports, {
  parseCandidateFiles: function parseCandidateFiles() {
    return _parseCandidateFiles;
  },
  resolvedChangedContent: function resolvedChangedContent() {
    return _resolvedChangedContent;
  }
});

var _fs =
/*#__PURE__*/
_interop_require_default(require("fs"));

var _path =
/*#__PURE__*/
_interop_require_default(require("path"));

var _isglob =
/*#__PURE__*/
_interop_require_default(require("is-glob"));

var _fastglob =
/*#__PURE__*/
_interop_require_default(require("fast-glob"));

var _normalizepath =
/*#__PURE__*/
_interop_require_default(require("normalize-path"));

var _parseGlob = require("../util/parseGlob");

var _sharedState = require("./sharedState");

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _parseCandidateFiles(context, tailwindConfig) {
  var files = tailwindConfig.content.files; // Normalize the file globs

  files = files.filter(function (filePath) {
    return typeof filePath === "string";
  });
  files = files.map(_normalizepath["default"]); // Split into included and excluded globs

  var tasks = _fastglob["default"].generateTasks(files);
  /** @type {ContentPath[]} */


  var included = [];
  /** @type {ContentPath[]} */

  var excluded = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = tasks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var task = _step.value;
      included.push.apply(included, _toConsumableArray(task.positive.map(function (filePath) {
        return parseFilePath(filePath, false);
      })));
      excluded.push.apply(excluded, _toConsumableArray(task.negative.map(function (filePath) {
        return parseFilePath(filePath, true);
      })));
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var paths = [].concat(included, excluded); // Resolve paths relative to the config file or cwd

  paths = resolveRelativePaths(context, paths); // Resolve symlinks if possible

  paths = paths.flatMap(resolvePathSymlinks); // Update cached patterns

  paths = paths.map(resolveGlobPattern);
  return paths;
}
/**
 *
 * @param {string} filePath
 * @param {boolean} ignore
 * @returns {ContentPath}
 */


function parseFilePath(filePath, ignore) {
  var contentPath = {
    original: filePath,
    base: filePath,
    ignore: ignore,
    pattern: filePath,
    glob: null
  };

  if ((0, _isglob["default"])(filePath)) {
    Object.assign(contentPath, (0, _parseGlob.parseGlob)(filePath));
  }

  return contentPath;
}
/**
 *
 * @param {ContentPath} contentPath
 * @returns {ContentPath}
 */


function resolveGlobPattern(contentPath) {
  // This is required for Windows support to properly pick up Glob paths.
  // Afaik, this technically shouldn't be needed but there's probably
  // some internal, direct path matching with a normalized path in
  // a package which can't handle mixed directory separators
  var base = (0, _normalizepath["default"])(contentPath.base); // If the user's file path contains any special characters (like parens) for instance fast-glob
  // is like "OOOH SHINY" and treats them as such. So we have to escape the base path to fix this

  base = _fastglob["default"].escapePath(base);
  contentPath.pattern = contentPath.glob ? "".concat(base, "/").concat(contentPath.glob) : base;
  contentPath.pattern = contentPath.ignore ? "!".concat(contentPath.pattern) : contentPath.pattern;
  return contentPath;
}
/**
 * Resolve each path relative to the config file (when possible) if the experimental flag is enabled
 * Otherwise, resolve relative to the current working directory
 *
 * @param {any} context
 * @param {ContentPath[]} contentPaths
 * @returns {ContentPath[]}
 */


function resolveRelativePaths(context, contentPaths) {
  var resolveFrom = []; // Resolve base paths relative to the config file (when possible) if the experimental flag is enabled

  if (context.userConfigPath && context.tailwindConfig.content.relative) {
    resolveFrom = [_path["default"].dirname(context.userConfigPath)];
  }

  return contentPaths.map(function (contentPath) {
    var _path$default;

    contentPath.base = (_path$default = _path["default"]).resolve.apply(_path$default, _toConsumableArray(resolveFrom).concat([contentPath.base]));
    return contentPath;
  });
}
/**
 * Resolve the symlink for the base directory / file in each path
 * These are added as additional dependencies to watch for changes because
 * some tools (like webpack) will only watch the actual file or directory
 * but not the symlink itself even in projects that use monorepos.
 *
 * @param {ContentPath} contentPath
 * @returns {ContentPath[]}
 */


function resolvePathSymlinks(contentPath) {
  var paths = [contentPath];

  try {
    var resolvedPath = _fs["default"].realpathSync(contentPath.base);

    if (resolvedPath !== contentPath.base) {
      paths.push(_objectSpread({}, contentPath, {
        base: resolvedPath
      }));
    }
  } catch (_unused) {// TODO: log this?
  }

  return paths;
}

function _resolvedChangedContent(context, candidateFiles, fileModifiedMap) {
  var changedContent = context.tailwindConfig.content.files.filter(function (item) {
    return typeof item.raw === "string";
  }).map(function (_ref) {
    var raw = _ref.raw,
        _ref$extension = _ref.extension,
        extension = _ref$extension === void 0 ? "html" : _ref$extension;
    return {
      content: raw,
      extension: extension
    };
  });

  var _resolveChangedFiles = resolveChangedFiles(candidateFiles, fileModifiedMap),
      _resolveChangedFiles2 = _slicedToArray(_resolveChangedFiles, 2),
      changedFiles = _resolveChangedFiles2[0],
      mTimesToCommit = _resolveChangedFiles2[1];

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = changedFiles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var changedFile = _step2.value;

      var extension = _path["default"].extname(changedFile).slice(1);

      changedContent.push({
        file: changedFile,
        extension: extension
      });
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return [changedContent, mTimesToCommit];
}
/**
 *
 * @param {ContentPath[]} candidateFiles
 * @param {Map<string, number>} fileModifiedMap
 * @returns {[Set<string>, Map<string, number>]}
 */


function resolveChangedFiles(candidateFiles, fileModifiedMap) {
  var paths = candidateFiles.map(function (contentPath) {
    return contentPath.pattern;
  });
  var mTimesToCommit = new Map();
  var changedFiles = new Set();
  _sharedState.env.DEBUG && console.time("Finding changed files");

  var files = _fastglob["default"].sync(paths, {
    absolute: true
  });

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = files[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var file = _step3.value;
      var prevModified = fileModifiedMap.get(file) || -Infinity;

      var modified = _fs["default"].statSync(file).mtimeMs;

      if (modified > prevModified) {
        changedFiles.add(file);
        mTimesToCommit.set(file, modified);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  _sharedState.env.DEBUG && console.timeEnd("Finding changed files");
  return [changedFiles, mTimesToCommit];
}