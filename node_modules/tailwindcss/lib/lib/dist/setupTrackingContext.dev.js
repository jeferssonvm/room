// @ts-check
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, // DISABLE_TOUCH = TRUE
// Retrieve an existing context from cache if possible (since contexts are unique per
// source path), or set up a new one (including setting up watchers and registering
// plugins) then return it
"default", {
  enumerable: true,
  get: function get() {
    return setupTrackingContext;
  }
});

var _fs =
/*#__PURE__*/
_interop_require_default(require("fs"));

var _quicklru =
/*#__PURE__*/
_interop_require_default(require("@alloc/quick-lru"));

var _hashConfig =
/*#__PURE__*/
_interop_require_default(require("../util/hashConfig"));

var _resolveconfig =
/*#__PURE__*/
_interop_require_default(require("../public/resolve-config"));

var _resolveConfigPath =
/*#__PURE__*/
_interop_require_default(require("../util/resolveConfigPath"));

var _setupContextUtils = require("./setupContextUtils");

var _parseDependency =
/*#__PURE__*/
_interop_require_default(require("../util/parseDependency"));

var _validateConfig = require("../util/validateConfig.js");

var _content = require("./content.js");

var _loadconfig = require("../lib/load-config");

var _getModuleDependencies =
/*#__PURE__*/
_interop_require_default(require("./getModuleDependencies"));

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var configPathCache = new _quicklru["default"]({
  maxSize: 100
});
var candidateFilesCache = new WeakMap();

function getCandidateFiles(context, tailwindConfig) {
  if (candidateFilesCache.has(context)) {
    return candidateFilesCache.get(context);
  }

  var candidateFiles = (0, _content.parseCandidateFiles)(context, tailwindConfig);
  return candidateFilesCache.set(context, candidateFiles).get(context);
} // Get the config object based on a path


function getTailwindConfig(configOrPath) {
  var userConfigPath = (0, _resolveConfigPath["default"])(configOrPath);

  if (userConfigPath !== null) {
    var _ref2 = configPathCache.get(userConfigPath) || [],
        _ref3 = _slicedToArray(_ref2, 4),
        prevConfig = _ref3[0],
        prevConfigHash = _ref3[1],
        prevDeps = _ref3[2],
        prevModified = _ref3[3];

    var newDeps = (0, _getModuleDependencies["default"])(userConfigPath);
    var modified = false;
    var newModified = new Map();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = newDeps[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var file = _step.value;

        var time = _fs["default"].statSync(file).mtimeMs;

        newModified.set(file, time);

        if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {
          modified = true;
        }
      } // It hasn't changed (based on timestamps)

    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!modified) {
      return [prevConfig, userConfigPath, prevConfigHash, prevDeps];
    } // It has changed (based on timestamps), or first run


    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = newDeps[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _file = _step2.value;
        delete require.cache[_file];
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var _newConfig = (0, _validateConfig.validateConfig)((0, _resolveconfig["default"])((0, _loadconfig.loadConfig)(userConfigPath)));

    var newHash = (0, _hashConfig["default"])(_newConfig);
    configPathCache.set(userConfigPath, [_newConfig, newHash, newDeps, newModified]);
    return [_newConfig, userConfigPath, newHash, newDeps];
  }

  var _configOrPath_config, _ref; // It's a plain object, not a path


  var newConfig = (0, _resolveconfig["default"])((_ref = (_configOrPath_config = configOrPath === null || configOrPath === void 0 ? void 0 : configOrPath.config) !== null && _configOrPath_config !== void 0 ? _configOrPath_config : configOrPath) !== null && _ref !== void 0 ? _ref : {});
  newConfig = (0, _validateConfig.validateConfig)(newConfig);
  return [newConfig, null, (0, _hashConfig["default"])(newConfig), []];
}

function setupTrackingContext(configOrPath) {
  return function (_ref4) {
    var tailwindDirectives = _ref4.tailwindDirectives,
        registerDependency = _ref4.registerDependency;
    return function (root, result) {
      var _getTailwindConfig = getTailwindConfig(configOrPath),
          _getTailwindConfig2 = _slicedToArray(_getTailwindConfig, 4),
          tailwindConfig = _getTailwindConfig2[0],
          userConfigPath = _getTailwindConfig2[1],
          tailwindConfigHash = _getTailwindConfig2[2],
          configDependencies = _getTailwindConfig2[3];

      var contextDependencies = new Set(configDependencies); // If there are no @tailwind or @apply rules, we don't consider this CSS
      // file or its dependencies to be dependencies of the context. Can reuse
      // the context even if they change. We may want to think about `@layer`
      // being part of this trigger too, but it's tough because it's impossible
      // for a layer in one file to end up in the actual @tailwind rule in
      // another file since independent sources are effectively isolated.

      if (tailwindDirectives.size > 0) {
        // Add current css file as a context dependencies.
        contextDependencies.add(result.opts.from); // Add all css @import dependencies as context dependencies.

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = result.messages[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var message = _step3.value;

            if (message.type === "dependency") {
              contextDependencies.add(message.file);
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      var _ref5 = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies),
          _ref6 = _slicedToArray(_ref5, 3),
          context = _ref6[0],
          mTimesToCommit = _ref6[2];

      var fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context);
      var candidateFiles = getCandidateFiles(context, tailwindConfig); // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's
      // dependencies to be dependencies of the context. Can reuse the context even if they change.
      // We may want to think about `@layer` being part of this trigger too, but it's tough
      // because it's impossible for a layer in one file to end up in the actual @tailwind rule
      // in another file since independent sources are effectively isolated.

      if (tailwindDirectives.size > 0) {
        // Add template paths as postcss dependencies.
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = candidateFiles[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var contentPath = _step4.value;
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = (0, _parseDependency["default"])(contentPath)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var dependency = _step7.value;
                registerDependency(dependency);
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                  _iterator7["return"]();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        var _ref7 = (0, _content.resolvedChangedContent)(context, candidateFiles, fileModifiedMap),
            _ref8 = _slicedToArray(_ref7, 2),
            changedContent = _ref8[0],
            contentMTimesToCommit = _ref8[1];

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = changedContent[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var content = _step5.value;
            context.changedContent.push(content);
          } // Add the mtimes of the content files to the commit list
          // We can overwrite the existing values because unconditionally
          // This is because:
          // 1. Most of the files here won't be in the map yet
          // 2. If they are that means it's a context dependency
          // and we're reading this after the context. This means
          // that the mtime we just read is strictly >= the context
          // mtime. Unless the user / os is doing something weird
          // in which the mtime would be going backwards. If that
          // happens there's already going to be problems.

        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = contentMTimesToCommit.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var _step6$value = _slicedToArray(_step6.value, 2),
                path = _step6$value[0],
                mtime = _step6$value[1];

            mTimesToCommit.set(path, mtime);
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      }

      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = configDependencies[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var file = _step8.value;
          registerDependency({
            type: "dependency",
            file: file
          });
        } // "commit" the new modified time for all context deps
        // We do this here because we want content tracking to
        // read the "old" mtime even when it's a context dependency.

      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = mTimesToCommit.entries()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var _step9$value = _slicedToArray(_step9.value, 2),
              _path = _step9$value[0],
              _mtime = _step9$value[1];

          fileModifiedMap.set(_path, _mtime);
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      return context;
    };
  };
}