#!/usr/bin/env node
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path =
/*#__PURE__*/
_interop_require_default(require("path"));

var _arg =
/*#__PURE__*/
_interop_require_default(require("arg"));

var _fs =
/*#__PURE__*/
_interop_require_default(require("fs"));

var _build = require("./build");

var _help = require("./help");

var _init = require("./init");

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // ---


function oneOf() {
  for (var _len = arguments.length, options = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    options[_key2] = arguments[_key2];
  }

  return Object.assign(function () {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = options[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var option = _step.value;
        var parsed = option(value);

        if (parsed === value) {
          return parsed;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    throw new Error("...");
  }, {
    manualParsing: true
  });
}

var commands = {
  init: {
    run: _init.init,
    args: {
      "--esm": {
        type: Boolean,
        description: "Initialize configuration file as ESM"
      },
      "--ts": {
        type: Boolean,
        description: "Initialize configuration file as TypeScript"
      },
      "--full": {
        type: Boolean,
        description: "Include the default values for all options in the generated configuration file"
      },
      "-f": "--full"
    }
  },
  build: {
    run: _build.build,
    args: {
      "--input": {
        type: String,
        description: "Input file"
      },
      "--output": {
        type: String,
        description: "Output file"
      },
      "--watch": {
        type: oneOf(String, Boolean),
        description: "Watch for changes and rebuild as needed"
      },
      "--poll": {
        type: Boolean,
        description: "Use polling instead of filesystem events when watching"
      },
      "--content": {
        type: String,
        description: "Content paths to use for removing unused classes"
      },
      "--minify": {
        type: Boolean,
        description: "Minify the output"
      },
      "--config": {
        type: String,
        description: "Path to a custom config file"
      },
      "-c": "--config",
      "-i": "--input",
      "-o": "--output",
      "-m": "--minify",
      "-w": "--watch",
      "-p": "--poll"
    }
  }
};
var sharedFlags = {
  "--help": {
    type: Boolean,
    description: "Display usage information"
  },
  "-h": "--help"
};

if (process.stdout.isTTY
/* Detect redirecting output to a file */
&& (process.argv[2] === undefined || process.argv.slice(2).every(function (flag) {
  return sharedFlags[flag] !== undefined;
}))) {
  (0, _help.help)({
    usage: ["tailwindcss [--input input.css] [--output output.css] [--watch] [options...]", "tailwindcss init [--full] [options...]"],
    commands: Object.keys(commands).filter(function (command) {
      return command !== "build";
    }).map(function (command) {
      return "".concat(command, " [options]");
    }),
    options: _objectSpread({}, commands.build.args, {}, sharedFlags)
  });
  process.exit(0);
}

var command = function () {
  var arg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  return arg.startsWith("-") ? undefined : arg;
}(process.argv[2]) || "build";

if (commands[command] === undefined) {
  if (_fs["default"].existsSync(_path["default"].resolve(command))) {
    // TODO: Deprecate this in future versions
    // Check if non-existing command, might be a file.
    command = "build";
  } else {
    (0, _help.help)({
      message: "Invalid command: ".concat(command),
      usage: ["tailwindcss <command> [options]"],
      commands: Object.keys(commands).filter(function (command) {
        return command !== "build";
      }).map(function (command) {
        return "".concat(command, " [options]");
      }),
      options: sharedFlags
    });
    process.exit(1);
  }
} // Execute command


var _commands$command = commands[command],
    flags = _commands$command.args,
    run = _commands$command.run;

var args = function () {
  try {
    var result = (0, _arg["default"])(Object.fromEntries(Object.entries(_objectSpread({}, flags, {}, sharedFlags)).filter(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          _key = _ref2[0],
          value = _ref2[1];

      var _value_type;

      return !(value === null || value === void 0 ? void 0 : (_value_type = value.type) === null || _value_type === void 0 ? void 0 : _value_type.manualParsing);
    }).map(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          value = _ref4[1];

      return [key, _typeof(value) === "object" ? value.type : value];
    })), {
      permissive: true
    }); // Manual parsing of flags to allow for special flags like oneOf(Boolean, String)

    for (var i = result["_"].length - 1; i >= 0; --i) {
      var flag = result["_"][i];
      if (!flag.startsWith("-")) continue;

      var _flag$split = flag.split("="),
          _flag$split2 = _slicedToArray(_flag$split, 2),
          flagName = _flag$split2[0],
          flagValue = _flag$split2[1];

      var handler = flags[flagName]; // Resolve flagName & handler

      while (typeof handler === "string") {
        flagName = handler;
        handler = flags[handler];
      }

      if (!handler) continue;
      var _args = [];
      var offset = i + 1; // --flag value syntax was used so we need to pull `value` from `args`

      if (flagValue === undefined) {
        // Parse args for current flag
        while (result["_"][offset] && !result["_"][offset].startsWith("-")) {
          _args.push(result["_"][offset++]);
        } // Cleanup manually parsed flags + args


        result["_"].splice(i, 1 + _args.length); // No args were provided, use default value defined in handler
        // One arg was provided, use that directly
        // Multiple args were provided so pass them all in an array

        flagValue = _args.length === 0 ? undefined : _args.length === 1 ? _args[0] : _args;
      } else {
        // Remove the whole flag from the args array
        result["_"].splice(i, 1);
      } // Set the resolved value in the `result` object


      result[flagName] = handler.type(flagValue, flagName);
    } // Ensure that the `command` is always the first argument in the `args`.
    // This is important so that we don't have to check if a default command
    // (build) was used or not from within each plugin.
    //
    // E.g.: tailwindcss input.css -> _: ['build', 'input.css']
    // E.g.: tailwindcss build input.css -> _: ['build', 'input.css']


    if (result["_"][0] !== command) {
      result["_"].unshift(command);
    }

    return result;
  } catch (err) {
    if (err.code === "ARG_UNKNOWN_OPTION") {
      (0, _help.help)({
        message: err.message,
        usage: ["tailwindcss <command> [options]"],
        options: sharedFlags
      });
      process.exit(1);
    }

    throw err;
  }
}();

if (args["--help"]) {
  (0, _help.help)({
    options: _objectSpread({}, flags, {}, sharedFlags),
    usage: ["tailwindcss ".concat(command, " [options]")]
  });
  process.exit(0);
}

run(args);