"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "createProcessor", {
  enumerable: true,
  get: function get() {
    return createProcessor;
  }
});

var _path =
/*#__PURE__*/
_interop_require_default(require("path"));

var _fs =
/*#__PURE__*/
_interop_require_default(require("fs"));

var _postcssloadconfig =
/*#__PURE__*/
_interop_require_default(require("postcss-load-config"));

var _lilconfig = require("lilconfig");

var _plugins =
/*#__PURE__*/
_interop_require_default(require("postcss-load-config/src/plugins" // Little bit scary, looking at private/internal API
));

var _options =
/*#__PURE__*/
_interop_require_default(require("postcss-load-config/src/options" // Little bit scary, looking at private/internal API
));

var _processTailwindFeatures =
/*#__PURE__*/
_interop_require_default(require("../../../processTailwindFeatures"));

var _deps = require("./deps");

var _utils = require("./utils");

var _sharedState = require("../../../lib/sharedState");

var _resolveConfig =
/*#__PURE__*/
_interop_require_default(require("../../../../resolveConfig"));

var _content = require("../../../lib/content");

var _watching = require("./watching");

var _fastglob =
/*#__PURE__*/
_interop_require_default(require("fast-glob"));

var _findAtConfigPath = require("../../../lib/findAtConfigPath");

var _log =
/*#__PURE__*/
_interop_require_default(require("../../../util/log"));

var _loadconfig = require("../../../lib/load-config");

var _getModuleDependencies =
/*#__PURE__*/
_interop_require_default(require("../../../lib/getModuleDependencies"));

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 *
 * @param {string} [customPostCssPath ]
 * @returns
 */


function loadPostCssPlugins(customPostCssPath) {
  var config, configPlugins, configPluginTailwindIdx, beforePlugins, afterPlugins;
  return regeneratorRuntime.async(function loadPostCssPlugins$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!customPostCssPath) {
            _context2.next = 6;
            break;
          }

          _context2.next = 3;
          return regeneratorRuntime.awrap(function _callee() {
            var file, _ref, _ref$config, config;

            return regeneratorRuntime.async(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    file = _path["default"].resolve(customPostCssPath); // Implementation, see: https://unpkg.com/browse/postcss-load-config@3.1.0/src/index.js
                    // @ts-ignore

                    _context.next = 3;
                    return regeneratorRuntime.awrap((0, _lilconfig.lilconfig)("postcss").load(file));

                  case 3:
                    _ref = _context.sent;
                    _ref$config = _ref.config;
                    config = _ref$config === void 0 ? {} : _ref$config;

                    if (typeof config === "function") {
                      config = config();
                    } else {
                      config = Object.assign({}, config);
                    }

                    if (!config.plugins) {
                      config.plugins = [];
                    }

                    return _context.abrupt("return", {
                      file: file,
                      plugins: (0, _plugins["default"])(config, file),
                      options: (0, _options["default"])(config, file)
                    });

                  case 9:
                  case "end":
                    return _context.stop();
                }
              }
            });
          }());

        case 3:
          _context2.t0 = _context2.sent;
          _context2.next = 9;
          break;

        case 6:
          _context2.next = 8;
          return regeneratorRuntime.awrap((0, _postcssloadconfig["default"])());

        case 8:
          _context2.t0 = _context2.sent;

        case 9:
          config = _context2.t0;
          configPlugins = config.plugins;
          configPluginTailwindIdx = configPlugins.findIndex(function (plugin) {
            if (typeof plugin === "function" && plugin.name === "tailwindcss") {
              return true;
            }

            if (_typeof(plugin) === "object" && plugin !== null && plugin.postcssPlugin === "tailwindcss") {
              return true;
            }

            return false;
          });
          beforePlugins = configPluginTailwindIdx === -1 ? [] : configPlugins.slice(0, configPluginTailwindIdx);
          afterPlugins = configPluginTailwindIdx === -1 ? configPlugins : configPlugins.slice(configPluginTailwindIdx + 1);
          return _context2.abrupt("return", [beforePlugins, afterPlugins, config.options]);

        case 15:
        case "end":
          return _context2.stop();
      }
    }
  });
}

function loadBuiltinPostcssPlugins() {
  var postcss = (0, _deps.loadPostcss)();
  var IMPORT_COMMENT = "__TAILWIND_RESTORE_IMPORT__: ";
  return [[function (root) {
    root.walkAtRules("import", function (rule) {
      if (rule.params.slice(1).startsWith("tailwindcss/")) {
        rule.after(postcss.comment({
          text: IMPORT_COMMENT + rule.params
        }));
        rule.remove();
      }
    });
  }, (0, _deps.loadPostcssImport)(), function (root) {
    root.walkComments(function (rule) {
      if (rule.text.startsWith(IMPORT_COMMENT)) {
        rule.after(postcss.atRule({
          name: "import",
          params: rule.text.replace(IMPORT_COMMENT, "")
        }));
        rule.remove();
      }
    });
  }], [], {}];
}

var state = {
  /** @type {any} */
  context: null,

  /** @type {ReturnType<typeof createWatcher> | null} */
  watcher: null,

  /** @type {{content: string, extension: string}[]} */
  changedContent: [],

  /** @type {{config: Config, dependencies: Set<string>, dispose: Function } | null} */
  configBag: null,
  contextDependencies: new Set(),

  /** @type {import('../../lib/content.js').ContentPath[]} */
  contentPaths: [],
  refreshContentPaths: function refreshContentPaths() {
    var _this_context;

    this.contentPaths = (0, _content.parseCandidateFiles)(this.context, (_this_context = this.context) === null || _this_context === void 0 ? void 0 : _this_context.tailwindConfig);
  },

  get config() {
    return this.context.tailwindConfig;
  },

  get contentPatterns() {
    return {
      all: this.contentPaths.map(function (contentPath) {
        return contentPath.pattern;
      }),
      dynamic: this.contentPaths.filter(function (contentPath) {
        return contentPath.glob !== undefined;
      }).map(function (contentPath) {
        return contentPath.pattern;
      })
    };
  },

  loadConfig: function loadConfig(configPath, content) {
    if (this.watcher && configPath) {
      this.refreshConfigDependencies();
    }

    var config = (0, _loadconfig.loadConfig)(configPath);
    var dependencies = (0, _getModuleDependencies["default"])(configPath);
    this.configBag = {
      config: config,
      dependencies: dependencies,
      dispose: function dispose() {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = dependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var file = _step.value;
            delete require.cache[require.resolve(file)];
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }; // @ts-ignore

    this.configBag.config = (0, _resolveConfig["default"])(this.configBag.config, {
      content: {
        files: []
      }
    }); // Override content files if `--content` has been passed explicitly

    if ((content === null || content === void 0 ? void 0 : content.length) > 0) {
      this.configBag.config.content.files = content;
    }

    return this.configBag.config;
  },
  refreshConfigDependencies: function refreshConfigDependencies(configPath) {
    var _this_configBag;

    _sharedState.env.DEBUG && console.time("Module dependencies");
    (_this_configBag = this.configBag) === null || _this_configBag === void 0 ? void 0 : _this_configBag.dispose();
    _sharedState.env.DEBUG && console.timeEnd("Module dependencies");
  },
  readContentPaths: function readContentPaths() {
    var content = []; // Resolve globs from the content config
    // TODO: When we make the postcss plugin async-capable this can become async

    var files = _fastglob["default"].sync(this.contentPatterns.all);

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = files[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var file = _step2.value;

        if (false) {
          content.push({
            file: file,
            extension: _path["default"].extname(file).slice(1)
          });
        } else {
          content.push({
            content: _fs["default"].readFileSync(_path["default"].resolve(file), "utf8"),
            extension: _path["default"].extname(file).slice(1)
          });
        }
      } // Resolve raw content in the tailwind config

    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var rawContent = this.config.content.files.filter(function (file) {
      return file !== null && _typeof(file) === "object";
    });
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = rawContent[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _step3$value = _step3.value,
            htmlContent = _step3$value.raw,
            _step3$value$extensio = _step3$value.extension,
            extension = _step3$value$extensio === void 0 ? "html" : _step3$value$extensio;
        content.push({
          content: htmlContent,
          extension: extension
        });
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return content;
  },
  getContext: function getContext(_ref2) {
    var createContext = _ref2.createContext,
        cliConfigPath = _ref2.cliConfigPath,
        root = _ref2.root,
        result = _ref2.result,
        content = _ref2.content;

    if (this.context) {
      this.context.changedContent = this.changedContent.splice(0);
      return this.context;
    }

    _sharedState.env.DEBUG && console.time("Searching for config");

    var _findAtConfigPath1;

    var configPath = (_findAtConfigPath1 = (0, _findAtConfigPath.findAtConfigPath)(root, result)) !== null && _findAtConfigPath1 !== void 0 ? _findAtConfigPath1 : cliConfigPath;
    _sharedState.env.DEBUG && console.timeEnd("Searching for config");
    _sharedState.env.DEBUG && console.time("Loading config");
    var config = this.loadConfig(configPath, content);
    _sharedState.env.DEBUG && console.timeEnd("Loading config");
    _sharedState.env.DEBUG && console.time("Creating context");
    this.context = createContext(config, []);
    Object.assign(this.context, {
      userConfigPath: configPath
    });
    _sharedState.env.DEBUG && console.timeEnd("Creating context");
    _sharedState.env.DEBUG && console.time("Resolving content paths");
    this.refreshContentPaths();
    _sharedState.env.DEBUG && console.timeEnd("Resolving content paths");

    if (this.watcher) {
      _sharedState.env.DEBUG && console.time("Watch new files");
      this.watcher.refreshWatchedFiles();
      _sharedState.env.DEBUG && console.timeEnd("Watch new files");
    }

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = this.readContentPaths()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var file = _step4.value;
        this.context.changedContent.push(file);
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
          _iterator4["return"]();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    return this.context;
  }
};

function createProcessor(args, cliConfigPath) {
  var _args_content, postcss, input, output, includePostCss, customPostCssPath, _ref3, _ref4, beforePlugins, afterPlugins, postcssOptions, _args_content_split, content, tailwindPlugin, plugins, processor, readInput, build, parseChanges;

  return regeneratorRuntime.async(function createProcessor$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          parseChanges = function _ref9(changes) {
            return regeneratorRuntime.async(function parseChanges$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    return _context7.abrupt("return", Promise.all(changes.map(function _callee2(change) {
                      return regeneratorRuntime.async(function _callee2$(_context6) {
                        while (1) {
                          switch (_context6.prev = _context6.next) {
                            case 0:
                              _context6.next = 2;
                              return regeneratorRuntime.awrap(change.content());

                            case 2:
                              _context6.t0 = _context6.sent;
                              _context6.t1 = change.extension;
                              return _context6.abrupt("return", {
                                content: _context6.t0,
                                extension: _context6.t1
                              });

                            case 5:
                            case "end":
                              return _context6.stop();
                          }
                        }
                      });
                    })));

                  case 1:
                  case "end":
                    return _context7.stop();
                }
              }
            });
          };

          build = function _ref8() {
            var start;
            return regeneratorRuntime.async(function build$(_context5) {
              while (1) {
                switch (_context5.prev = _context5.next) {
                  case 0:
                    start = process.hrtime.bigint();
                    return _context5.abrupt("return", readInput().then(function (css) {
                      return processor.process(css, _objectSpread({}, postcssOptions, {
                        from: input,
                        to: output
                      }));
                    }).then(function (result) {
                      return (0, _deps.lightningcss)(!!args["--minify"], result);
                    }).then(function (result) {
                      if (!state.watcher) {
                        return result;
                      }

                      _sharedState.env.DEBUG && console.time("Recording PostCSS dependencies");
                      var _iteratorNormalCompletion5 = true;
                      var _didIteratorError5 = false;
                      var _iteratorError5 = undefined;

                      try {
                        for (var _iterator5 = result.messages[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                          var message = _step5.value;

                          if (message.type === "dependency") {
                            state.contextDependencies.add(message.file);
                          }
                        }
                      } catch (err) {
                        _didIteratorError5 = true;
                        _iteratorError5 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                            _iterator5["return"]();
                          }
                        } finally {
                          if (_didIteratorError5) {
                            throw _iteratorError5;
                          }
                        }
                      }

                      _sharedState.env.DEBUG && console.timeEnd("Recording PostCSS dependencies"); // TODO: This needs to be in a different spot

                      _sharedState.env.DEBUG && console.time("Watch new files");
                      state.watcher.refreshWatchedFiles();
                      _sharedState.env.DEBUG && console.timeEnd("Watch new files");
                      return result;
                    }).then(function (result) {
                      if (!output) {
                        process.stdout.write(result.css);
                        return;
                      }

                      return Promise.all([(0, _utils.outputFile)(result.opts.to, result.css), result.map && (0, _utils.outputFile)(result.opts.to + ".map", result.map.toString())]);
                    }).then(function () {
                      var end = process.hrtime.bigint();
                      console.error();
                      console.error("Done in", (end - start) / BigInt(1e6) + "ms.");
                    }).then(function () {}, function (err) {
                      // TODO: If an initial build fails we can't easily pick up any PostCSS dependencies
                      // that were collected before the error occurred
                      // The result is not stored on the error so we have to store it externally
                      // and pull the messages off of it here somehow
                      // This results in a less than ideal DX because the watcher will not pick up
                      // changes to imported CSS if one of them caused an error during the initial build
                      // If you fix it and then save the main CSS file so there's no error
                      // The watcher will start watching the imported CSS files and will be
                      // resilient to future errors.
                      if (state.watcher) {
                        console.error(err);
                      } else {
                        return Promise.reject(err);
                      }
                    }));

                  case 2:
                  case "end":
                    return _context5.stop();
                }
              }
            });
          };

          readInput = function _ref7() {
            return regeneratorRuntime.async(function readInput$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!(input === "-")) {
                      _context4.next = 2;
                      break;
                    }

                    return _context4.abrupt("return", (0, _utils.drainStdin)());

                  case 2:
                    if (!input) {
                      _context4.next = 4;
                      break;
                    }

                    return _context4.abrupt("return", _fs["default"].promises.readFile(_path["default"].resolve(input), "utf8"));

                  case 4:
                    return _context4.abrupt("return", "@tailwind base; @tailwind components; @tailwind utilities");

                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            });
          };

          postcss = (0, _deps.loadPostcss)();
          input = args["--input"];
          output = args["--output"];
          includePostCss = args["--postcss"];
          customPostCssPath = typeof args["--postcss"] === "string" ? args["--postcss"] : undefined;

          if (!includePostCss) {
            _context10.next = 14;
            break;
          }

          _context10.next = 11;
          return regeneratorRuntime.awrap(loadPostCssPlugins(customPostCssPath));

        case 11:
          _context10.t0 = _context10.sent;
          _context10.next = 15;
          break;

        case 14:
          _context10.t0 = loadBuiltinPostcssPlugins();

        case 15:
          _ref3 = _context10.t0;
          _ref4 = _slicedToArray(_ref3, 3);
          beforePlugins = _ref4[0];
          afterPlugins = _ref4[1];
          postcssOptions = _ref4[2];

          if (args["--purge"]) {
            _log["default"].warn("purge-flag-deprecated", ["The `--purge` flag has been deprecated.", "Please use `--content` instead."]);

            if (!args["--content"]) {
              args["--content"] = args["--purge"];
            }
          }

          content = (_args_content_split = (_args_content = args["--content"]) === null || _args_content === void 0 ? void 0 : _args_content.split(/(?<!{[^}]+),/)) !== null && _args_content_split !== void 0 ? _args_content_split : [];

          tailwindPlugin = function tailwindPlugin() {
            return {
              postcssPlugin: "tailwindcss",
              Once: function Once(root, _ref5) {
                var result;
                return regeneratorRuntime.async(function Once$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        result = _ref5.result;
                        _sharedState.env.DEBUG && console.time("Compiling CSS");
                        _context3.next = 4;
                        return regeneratorRuntime.awrap((0, _processTailwindFeatures["default"])(function (_ref6) {
                          var createContext = _ref6.createContext;
                          console.error();
                          console.error("Rebuilding...");
                          return function () {
                            return state.getContext({
                              createContext: createContext,
                              cliConfigPath: cliConfigPath,
                              root: root,
                              result: result,
                              content: content
                            });
                          };
                        })(root, result));

                      case 4:
                        _sharedState.env.DEBUG && console.timeEnd("Compiling CSS");

                      case 5:
                      case "end":
                        return _context3.stop();
                    }
                  }
                });
              }
            };
          };

          tailwindPlugin.postcss = true;
          plugins = [].concat(_toConsumableArray(beforePlugins), [tailwindPlugin, !args["--minify"] && _utils.formatNodes], _toConsumableArray(afterPlugins)).filter(Boolean);
          /** @type {import('postcss').Processor} */
          // @ts-ignore

          processor = postcss(plugins);

          if (input !== undefined && input !== "-") {
            state.contextDependencies.add(_path["default"].resolve(input));
          }

          return _context10.abrupt("return", {
            build: build,
            watch: function watch() {
              return regeneratorRuntime.async(function watch$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      state.watcher = (0, _watching.createWatcher)(args, {
                        state: state,

                        /**
                        * @param {{file: string, content(): Promise<string>, extension: string}[]} changes
                        */
                        rebuild: function rebuild(changes) {
                          var needsNewContext, _iteratorNormalCompletion6, _didIteratorError6, _iteratorError6, _iterator6, _step6, change;

                          return regeneratorRuntime.async(function rebuild$(_context8) {
                            while (1) {
                              switch (_context8.prev = _context8.next) {
                                case 0:
                                  needsNewContext = changes.some(function (change) {
                                    var _state_configBag;

                                    return ((_state_configBag = state.configBag) === null || _state_configBag === void 0 ? void 0 : _state_configBag.dependencies.has(change.file)) || state.contextDependencies.has(change.file);
                                  });

                                  if (!needsNewContext) {
                                    _context8.next = 5;
                                    break;
                                  }

                                  state.context = null;
                                  _context8.next = 33;
                                  break;

                                case 5:
                                  _iteratorNormalCompletion6 = true;
                                  _didIteratorError6 = false;
                                  _iteratorError6 = undefined;
                                  _context8.prev = 8;
                                  _context8.next = 11;
                                  return regeneratorRuntime.awrap(parseChanges(changes));

                                case 11:
                                  _context8.t0 = Symbol.iterator;
                                  _iterator6 = _context8.sent[_context8.t0]();

                                case 13:
                                  if (_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done) {
                                    _context8.next = 19;
                                    break;
                                  }

                                  change = _step6.value;
                                  state.changedContent.push(change);

                                case 16:
                                  _iteratorNormalCompletion6 = true;
                                  _context8.next = 13;
                                  break;

                                case 19:
                                  _context8.next = 25;
                                  break;

                                case 21:
                                  _context8.prev = 21;
                                  _context8.t1 = _context8["catch"](8);
                                  _didIteratorError6 = true;
                                  _iteratorError6 = _context8.t1;

                                case 25:
                                  _context8.prev = 25;
                                  _context8.prev = 26;

                                  if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
                                    _iterator6["return"]();
                                  }

                                case 28:
                                  _context8.prev = 28;

                                  if (!_didIteratorError6) {
                                    _context8.next = 31;
                                    break;
                                  }

                                  throw _iteratorError6;

                                case 31:
                                  return _context8.finish(28);

                                case 32:
                                  return _context8.finish(25);

                                case 33:
                                  return _context8.abrupt("return", build());

                                case 34:
                                case "end":
                                  return _context8.stop();
                              }
                            }
                          }, null, null, [[8, 21, 25, 33], [26,, 28, 32]]);
                        }
                      });
                      _context9.next = 3;
                      return regeneratorRuntime.awrap(build());

                    case 3:
                    case "end":
                      return _context9.stop();
                  }
                }
              });
            }
          });

        case 28:
        case "end":
          return _context10.stop();
      }
    }
  });
}