"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "createWatcher", {
  enumerable: true,
  get: function get() {
    return createWatcher;
  }
});

var _chokidar =
/*#__PURE__*/
_interop_require_default(require("chokidar"));

var _fs =
/*#__PURE__*/
_interop_require_default(require("fs"));

var _micromatch =
/*#__PURE__*/
_interop_require_default(require("micromatch"));

var _normalizepath =
/*#__PURE__*/
_interop_require_default(require("normalize-path"));

var _path =
/*#__PURE__*/
_interop_require_default(require("path"));

var _utils = require("./utils");

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function createWatcher(args, _ref) {
  var state = _ref.state,
      rebuild = _ref.rebuild;
  var shouldPoll = args["--poll"];
  var shouldCoalesceWriteEvents = shouldPoll || process.platform === "win32"; // Polling interval in milliseconds
  // Used only when polling or coalescing add/change events on Windows

  var pollInterval = 10;

  var watcher = _chokidar["default"].watch([], {
    // Force checking for atomic writes in all situations
    // This causes chokidar to wait up to 100ms for a file to re-added after it's been unlinked
    // This only works when watching directories though
    atomic: true,
    usePolling: shouldPoll,
    interval: shouldPoll ? pollInterval : undefined,
    ignoreInitial: true,
    awaitWriteFinish: shouldCoalesceWriteEvents ? {
      stabilityThreshold: 50,
      pollInterval: pollInterval
    } : false
  }); // A queue of rebuilds, file reads, etcâ€¦ to run


  var chain = Promise.resolve();
  /**
  * A list of files that have been changed since the last rebuild
  *
  * @type {{file: string, content: () => Promise<string>, extension: string}[]}
  */

  var changedContent = [];
  /**
  * A list of files for which a rebuild has already been queued.
  * This is used to prevent duplicate rebuilds when multiple events are fired for the same file.
  * The rebuilt file is cleared from this list when it's associated rebuild has _started_
  * This is because if the file is changed during a rebuild it won't trigger a new rebuild which it should
  **/

  var pendingRebuilds = new Set();

  var _timer;

  var _reject;
  /**
  * Rebuilds the changed files and resolves when the rebuild is
  * complete regardless of whether it was successful or not
  */


  function rebuildAndContinue() {
    var changes;
    return regeneratorRuntime.async(function rebuildAndContinue$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            changes = changedContent.splice(0); // There are no changes to rebuild so we can just do nothing

            if (!(changes.length === 0)) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return", Promise.resolve());

          case 3:
            // Clear all pending rebuilds for the about-to-be-built files
            changes.forEach(function (change) {
              return pendingRebuilds["delete"](change.file);
            }); // Resolve the promise even when the rebuild fails

            return _context.abrupt("return", rebuild(changes).then(function () {}, function () {}));

          case 5:
          case "end":
            return _context.stop();
        }
      }
    });
  }
  /**
  *
  * @param {*} file
  * @param {(() => Promise<string>) | null} content
  * @param {boolean} skipPendingCheck
  * @returns {Promise<void>}
  */


  function recordChangedFile(file) {
    var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var skipPendingCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    file = _path["default"].resolve(file); // Applications like Vim/Neovim fire both rename and change events in succession for atomic writes
    // In that case rebuild has already been queued by rename, so can be skipped in change

    if (pendingRebuilds.has(file) && !skipPendingCheck) {
      return Promise.resolve();
    } // Mark that a rebuild of this file is going to happen
    // It MUST happen synchronously before the rebuild is queued for this to be effective


    pendingRebuilds.add(file);
    changedContent.push({
      file: file,
      content: content !== null && content !== void 0 ? content : function () {
        return _fs["default"].promises.readFile(file, "utf8");
      },
      extension: _path["default"].extname(file).slice(1)
    });

    if (_timer) {
      clearTimeout(_timer);

      _reject();
    } // If a rebuild is already in progress we don't want to start another one until the 10ms timer has expired


    chain = chain.then(function () {
      return new Promise(function (resolve, reject) {
        _timer = setTimeout(resolve, 10);
        _reject = reject;
      });
    }); // Resolves once this file has been rebuilt (or the rebuild for this file has failed)
    // This queues as many rebuilds as there are changed files
    // But those rebuilds happen after some delay
    // And will immediately resolve if there are no changes

    chain = chain.then(rebuildAndContinue, rebuildAndContinue);
    return chain;
  }

  watcher.on("change", function (file) {
    return recordChangedFile(file);
  });
  watcher.on("add", function (file) {
    return recordChangedFile(file);
  }); // Restore watching any files that are "removed"
  // This can happen when a file is pseudo-atomically replaced (a copy is created, overwritten, the old one is unlinked, and the new one is renamed)
  // TODO: An an optimization we should allow removal when the config changes

  watcher.on("unlink", function (file) {
    file = (0, _normalizepath["default"])(file); // Only re-add the file if it's not covered by a dynamic pattern

    if (!_micromatch["default"].some([file], state.contentPatterns.dynamic)) {
      watcher.add(file);
    }
  }); // Some applications such as Visual Studio (but not VS Code)
  // will only fire a rename event for atomic writes and not a change event
  // This is very likely a chokidar bug but it's one we need to work around
  // We treat this as a change event and rebuild the CSS

  watcher.on("raw", function (evt, filePath, meta) {
    if (evt !== "rename") {
      return;
    }

    var watchedPath = meta.watchedPath; // Watched path might be the file itself
    // Or the directory it is in

    filePath = watchedPath.endsWith(filePath) ? watchedPath : _path["default"].join(watchedPath, filePath); // Skip this event since the files it is for does not match any of the registered content globs

    if (!_micromatch["default"].some([filePath], state.contentPatterns.all)) {
      return;
    } // Skip since we've already queued a rebuild for this file that hasn't happened yet


    if (pendingRebuilds.has(filePath)) {
      return;
    } // We'll go ahead and add the file to the pending rebuilds list here
    // It'll be removed when the rebuild starts unless the read fails
    // which will be taken care of as well


    pendingRebuilds.add(filePath);

    function enqueue() {
      var content;
      return regeneratorRuntime.async(function enqueue$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return regeneratorRuntime.awrap((0, _utils.readFileWithRetries)(_path["default"].resolve(filePath)));

            case 3:
              content = _context2.sent;

              if (!(content === undefined)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("return");

            case 6:
              _context2.next = 8;
              return regeneratorRuntime.awrap(recordChangedFile(filePath, function () {
                return content;
              }, true));

            case 8:
              _context2.next = 12;
              break;

            case 10:
              _context2.prev = 10;
              _context2.t0 = _context2["catch"](0);

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, null, null, [[0, 10]]);
    }

    enqueue().then(function () {
      // If the file read fails we still need to make sure the file isn't stuck in the pending rebuilds list
      pendingRebuilds["delete"](filePath);
    });
  });
  return {
    fswatcher: watcher,
    refreshWatchedFiles: function refreshWatchedFiles() {
      watcher.add(Array.from(state.contextDependencies));
      watcher.add(Array.from(state.configBag.dependencies));
      watcher.add(state.contentPatterns.all);
    }
  };
}