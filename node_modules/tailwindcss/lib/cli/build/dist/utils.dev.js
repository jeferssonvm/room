// @ts-check
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _export(target, all) {
  for (var name in all) {
    Object.defineProperty(target, name, {
      enumerable: true,
      get: all[name]
    });
  }
}

_export(exports, {
  indentRecursive: function indentRecursive() {
    return _indentRecursive;
  },
  formatNodes: function formatNodes() {
    return _formatNodes;
  },
  readFileWithRetries: function readFileWithRetries() {
    return _readFileWithRetries;
  },
  drainStdin: function drainStdin() {
    return _drainStdin;
  },
  outputFile: function outputFile() {
    return _outputFile;
  }
});

var _fs =
/*#__PURE__*/
_interop_require_default(require("fs"));

var _path =
/*#__PURE__*/
_interop_require_default(require("path"));

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _indentRecursive(node) {
  var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  node.each && node.each(function (child, i) {
    if (!child.raws.before || !child.raws.before.trim() || child.raws.before.includes("\n")) {
      child.raws.before = "\n".concat(node.type !== "rule" && i > 0 ? "\n" : "").concat("  ".repeat(indent));
    }

    child.raws.after = "\n".concat("  ".repeat(indent));

    _indentRecursive(child, indent + 1);
  });
}

function _formatNodes(root) {
  _indentRecursive(root);

  if (root.first) {
    root.first.raws.before = "";
  }
}

function _readFileWithRetries(path) {
  var tries,
      n,
      _args = arguments;
  return regeneratorRuntime.async(function _readFileWithRetries$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          tries = _args.length > 1 && _args[1] !== undefined ? _args[1] : 5;
          n = 0;

        case 2:
          if (!(n <= tries)) {
            _context.next = 20;
            break;
          }

          _context.prev = 3;
          _context.next = 6;
          return regeneratorRuntime.awrap(_fs["default"].promises.readFile(path, "utf8"));

        case 6:
          return _context.abrupt("return", _context.sent);

        case 9:
          _context.prev = 9;
          _context.t0 = _context["catch"](3);

          if (!(n !== tries)) {
            _context.next = 16;
            break;
          }

          if (!(_context.t0.code === "ENOENT" || _context.t0.code === "EBUSY")) {
            _context.next = 16;
            break;
          }

          _context.next = 15;
          return regeneratorRuntime.awrap(new Promise(function (resolve) {
            return setTimeout(resolve, 10);
          }));

        case 15:
          return _context.abrupt("continue", 17);

        case 16:
          throw _context.t0;

        case 17:
          n++;
          _context.next = 2;
          break;

        case 20:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[3, 9]]);
}

function _drainStdin() {
  return new Promise(function (resolve, reject) {
    var result = "";
    process.stdin.on("data", function (chunk) {
      result += chunk;
    });
    process.stdin.on("end", function () {
      return resolve(result);
    });
    process.stdin.on("error", function (err) {
      return reject(err);
    });
  });
}

function _outputFile(file, newContents) {
  var currentContents;
  return regeneratorRuntime.async(function _outputFile$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          _context2.next = 3;
          return regeneratorRuntime.awrap(_fs["default"].promises.readFile(file, "utf8"));

        case 3:
          currentContents = _context2.sent;

          if (!(currentContents === newContents)) {
            _context2.next = 6;
            break;
          }

          return _context2.abrupt("return");

        case 6:
          _context2.next = 10;
          break;

        case 8:
          _context2.prev = 8;
          _context2.t0 = _context2["catch"](0);

        case 10:
          _context2.next = 12;
          return regeneratorRuntime.awrap(_fs["default"].promises.mkdir(_path["default"].dirname(file), {
            recursive: true
          }));

        case 12:
          _context2.next = 14;
          return regeneratorRuntime.awrap(_fs["default"].promises.writeFile(file, newContents, "utf8"));

        case 14:
        case "end":
          return _context2.stop();
      }
    }
  }, null, null, [[0, 8]]);
}