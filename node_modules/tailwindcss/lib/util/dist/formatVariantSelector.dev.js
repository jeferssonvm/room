"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _export(target, all) {
  for (var name in all) {
    Object.defineProperty(target, name, {
      enumerable: true,
      get: all[name]
    });
  }
}

_export(exports, {
  formatVariantSelector: function formatVariantSelector() {
    return _formatVariantSelector;
  },
  eliminateIrrelevantSelectors: function eliminateIrrelevantSelectors() {
    return _eliminateIrrelevantSelectors;
  },
  finalizeSelector: function finalizeSelector() {
    return _finalizeSelector;
  },
  handleMergePseudo: function handleMergePseudo() {
    return _handleMergePseudo;
  }
});

var _postcssselectorparser =
/*#__PURE__*/
_interop_require_default(require("postcss-selector-parser"));

var _unesc =
/*#__PURE__*/
_interop_require_default(require("postcss-selector-parser/dist/util/unesc"));

var _escapeClassName =
/*#__PURE__*/
_interop_require_default(require("../util/escapeClassName"));

var _prefixSelector =
/*#__PURE__*/
_interop_require_default(require("../util/prefixSelector"));

var _pseudoElements = require("./pseudoElements");

var _splitAtTopLevelOnly = require("./splitAtTopLevelOnly");

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/** @typedef {import('postcss-selector-parser').Root} Root */

/** @typedef {import('postcss-selector-parser').Selector} Selector */

/** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */

/** @typedef {import('postcss-selector-parser').Node} Node */

/** @typedef {{format: string, respectPrefix: boolean}[]} RawFormats */

/** @typedef {import('postcss-selector-parser').Root} ParsedFormats */

/** @typedef {RawFormats | ParsedFormats} AcceptedFormats */


var MERGE = ":merge";

function _formatVariantSelector(formats, _ref) {
  var context = _ref.context,
      candidate = _ref.candidate;

  var _context_tailwindConfig_prefix;

  var prefix = (_context_tailwindConfig_prefix = context === null || context === void 0 ? void 0 : context.tailwindConfig.prefix) !== null && _context_tailwindConfig_prefix !== void 0 ? _context_tailwindConfig_prefix : ""; // Parse the format selector into an AST

  var parsedFormats = formats.map(function (format) {
    var ast = (0, _postcssselectorparser["default"])().astSync(format.format);
    return _objectSpread({}, format, {
      ast: format.respectPrefix ? (0, _prefixSelector["default"])(prefix, ast) : ast
    });
  }); // We start with the candidate selector

  var formatAst = _postcssselectorparser["default"].root({
    nodes: [_postcssselectorparser["default"].selector({
      nodes: [_postcssselectorparser["default"].className({
        value: (0, _escapeClassName["default"])(candidate)
      })]
    })]
  }); // And iteratively merge each format selector into the candidate selector


  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = parsedFormats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var ast = _step.value.ast;

      var _handleMergePseudo2 = _handleMergePseudo(formatAst, ast);

      var _handleMergePseudo3 = _slicedToArray(_handleMergePseudo2, 2);

      formatAst = _handleMergePseudo3[0];
      ast = _handleMergePseudo3[1];
      // 2. Merge the format selector into the current selector AST
      ast.walkNesting(function (nesting) {
        return nesting.replaceWith.apply(nesting, _toConsumableArray(formatAst.nodes[0].nodes));
      }); // 3. Keep going!

      formatAst = ast;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return formatAst;
}
/**
 * Given any node in a selector this gets the "simple" selector it's a part of
 * A simple selector is just a list of nodes without any combinators
 * Technically :is(), :not(), :has(), etc… can have combinators but those are nested
 * inside the relevant node and won't be picked up so they're fine to ignore
 *
 * @param {Node} node
 * @returns {Node[]}
 **/


function simpleSelectorForNode(node) {
  /** @type {Node[]} */
  var nodes = []; // Walk backwards until we hit a combinator node (or the start)

  while (node.prev() && node.prev().type !== "combinator") {
    node = node.prev();
  } // Now record all non-combinator nodes until we hit one (or the end)


  while (node && node.type !== "combinator") {
    nodes.push(node);
    node = node.next();
  }

  return nodes;
}
/**
 * Resorts the nodes in a selector to ensure they're in the correct order
 * Tags go before classes, and pseudo classes go after classes
 *
 * @param {Selector} sel
 * @returns {Selector}
 **/


function resortSelector(sel) {
  sel.sort(function (a, b) {
    if (a.type === "tag" && b.type === "class") {
      return -1;
    } else if (a.type === "class" && b.type === "tag") {
      return 1;
    } else if (a.type === "class" && b.type === "pseudo" && b.value.startsWith("::")) {
      return -1;
    } else if (a.type === "pseudo" && a.value.startsWith("::") && b.type === "class") {
      return 1;
    }

    return sel.index(a) - sel.index(b);
  });
  return sel;
}

function _eliminateIrrelevantSelectors(sel, base) {
  var hasClassesMatchingCandidate = false;
  sel.walk(function (child) {
    if (child.type === "class" && child.value === base) {
      hasClassesMatchingCandidate = true;
      return false // Stop walking
      ;
    }
  });

  if (!hasClassesMatchingCandidate) {
    sel.remove();
  } // We do NOT recursively eliminate sub selectors that don't have the base class
  // as this is NOT a safe operation. For example, if we have:
  // `.space-x-2 > :not([hidden]) ~ :not([hidden])`
  // We cannot remove the [hidden] from the :not() because it would change the
  // meaning of the selector.
  // TODO: Can we do this for :matches, :is, and :where?

}

function _finalizeSelector(current, formats, _ref2) {
  var context = _ref2.context,
      candidate = _ref2.candidate,
      base = _ref2.base;

  var _context_tailwindConfig;

  var _context_tailwindConfig_separator;

  var separator = (_context_tailwindConfig_separator = context === null || context === void 0 ? void 0 : (_context_tailwindConfig = context.tailwindConfig) === null || _context_tailwindConfig === void 0 ? void 0 : _context_tailwindConfig.separator) !== null && _context_tailwindConfig_separator !== void 0 ? _context_tailwindConfig_separator : ":"; // Split by the separator, but ignore the separator inside square brackets:
  //
  // E.g.: dark:lg:hover:[paint-order:markers]
  //           ┬  ┬     ┬            ┬
  //           │  │     │            ╰── We will not split here
  //           ╰──┴─────┴─────────────── We will split here
  //

  base = base !== null && base !== void 0 ? base : (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(candidate, separator).pop(); // Parse the selector into an AST

  var selector = (0, _postcssselectorparser["default"])().astSync(current); // Normalize escaped classes, e.g.:
  //
  // The idea would be to replace the escaped `base` in the selector with the
  // `format`. However, in css you can escape the same selector in a few
  // different ways. This would result in different strings and therefore we
  // can't replace it properly.
  //
  //               base: bg-[rgb(255,0,0)]
  //   base in selector: bg-\\[rgb\\(255\\,0\\,0\\)\\]
  //       escaped base: bg-\\[rgb\\(255\\2c 0\\2c 0\\)\\]
  //

  selector.walkClasses(function (node) {
    if (node.raws && node.value.includes(base)) {
      node.raws.value = (0, _escapeClassName["default"])((0, _unesc["default"])(node.raws.value));
    }
  }); // Remove extraneous selectors that do not include the base candidate

  selector.each(function (sel) {
    return _eliminateIrrelevantSelectors(sel, base);
  }); // If ffter eliminating irrelevant selectors, we end up with nothing
  // Then the whole "rule" this is associated with does not need to exist
  // We use `null` as a marker value for that case

  if (selector.length === 0) {
    return null;
  } // If there are no formats that means there were no variants added to the candidate
  // so we can just return the selector as-is


  var formatAst = Array.isArray(formats) ? _formatVariantSelector(formats, {
    context: context,
    candidate: candidate
  }) : formats;

  if (formatAst === null) {
    return selector.toString();
  }

  var simpleStart = _postcssselectorparser["default"].comment({
    value: "/*__simple__*/"
  });

  var simpleEnd = _postcssselectorparser["default"].comment({
    value: "/*__simple__*/"
  }); // We can safely replace the escaped base now, since the `base` section is
  // now in a normalized escaped value.


  selector.walkClasses(function (node) {
    var _parent$nodes;

    if (node.value !== base) {
      return;
    }

    var parent = node.parent;
    var formatNodes = formatAst.nodes[0].nodes; // Perf optimization: if the parent is a single class we can just replace it and be done

    if (parent.nodes.length === 1) {
      node.replaceWith.apply(node, _toConsumableArray(formatNodes));
      return;
    }

    var simpleSelector = simpleSelectorForNode(node);
    parent.insertBefore(simpleSelector[0], simpleStart);
    parent.insertAfter(simpleSelector[simpleSelector.length - 1], simpleEnd);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = formatNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var child = _step2.value;
        parent.insertBefore(simpleSelector[0], child.clone());
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    node.remove(); // Re-sort the simple selector to ensure it's in the correct order

    simpleSelector = simpleSelectorForNode(simpleStart);
    var firstNode = parent.index(simpleStart);

    (_parent$nodes = parent.nodes).splice.apply(_parent$nodes, [firstNode, simpleSelector.length].concat(_toConsumableArray(resortSelector(_postcssselectorparser["default"].selector({
      nodes: simpleSelector
    })).nodes)));

    simpleStart.remove();
    simpleEnd.remove();
  }); // Remove unnecessary pseudo selectors that we used as placeholders

  selector.walkPseudos(function (p) {
    if (p.value === MERGE) {
      p.replaceWith(p.nodes);
    }
  }); // Move pseudo elements to the end of the selector (if necessary)

  selector.each(function (sel) {
    return (0, _pseudoElements.movePseudos)(sel);
  });
  return selector.toString();
}

function _handleMergePseudo(selector, format) {
  /** @type {{pseudo: Pseudo, value: string}[]} */
  var merges = []; // Find all :merge() pseudo-classes in `selector`

  selector.walkPseudos(function (pseudo) {
    if (pseudo.value === MERGE) {
      merges.push({
        pseudo: pseudo,
        value: pseudo.nodes[0].toString()
      });
    }
  }); // Find all :merge() "attachments" in `format` and attach them to the matching selector in `selector`

  format.walkPseudos(function (pseudo) {
    if (pseudo.value !== MERGE) {
      return;
    }

    var value = pseudo.nodes[0].toString(); // Does `selector` contain a :merge() pseudo-class with the same value?

    var existing = merges.find(function (merge) {
      return merge.value === value;
    }); // Nope so there's nothing to do

    if (!existing) {
      return;
    } // Everything after `:merge()` up to the next combinator is what is attached to the merged selector


    var attachments = [];
    var next = pseudo.next();

    while (next && next.type !== "combinator") {
      attachments.push(next);
      next = next.next();
    }

    var combinator = next;
    existing.pseudo.parent.insertAfter(existing.pseudo, _postcssselectorparser["default"].selector({
      nodes: attachments.map(function (node) {
        return node.clone();
      })
    }));
    pseudo.remove();
    attachments.forEach(function (node) {
      return node.remove();
    }); // What about this case:
    // :merge(.group):focus > &
    // :merge(.group):hover &

    if (combinator && combinator.type === "combinator") {
      combinator.remove();
    }
  });
  return [selector, format];
}