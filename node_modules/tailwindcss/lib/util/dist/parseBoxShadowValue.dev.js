"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _export(target, all) {
  for (var name in all) {
    Object.defineProperty(target, name, {
      enumerable: true,
      get: all[name]
    });
  }
}

_export(exports, {
  parseBoxShadowValue: function parseBoxShadowValue() {
    return _parseBoxShadowValue;
  },
  formatBoxShadowValue: function formatBoxShadowValue() {
    return _formatBoxShadowValue;
  }
});

var _splitAtTopLevelOnly = require("./splitAtTopLevelOnly");

var KEYWORDS = new Set(["inset", "inherit", "initial", "revert", "unset"]);
var SPACE = /\ +(?![^(]*\))/g // Similar to the one above, but with spaces instead.
;
var LENGTH = /^-?(\d+|\.\d+)(.*?)$/g;

function _parseBoxShadowValue(input) {
  var shadows = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, ",");
  return shadows.map(function (shadow) {
    var value = shadow.trim();
    var result = {
      raw: value
    };
    var parts = value.split(SPACE);
    var seen = new Set();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var part = _step.value;
        // Reset index, since the regex is stateful.
        LENGTH.lastIndex = 0; // Keyword

        if (!seen.has("KEYWORD") && KEYWORDS.has(part)) {
          result.keyword = part;
          seen.add("KEYWORD");
        } else if (LENGTH.test(part)) {
          if (!seen.has("X")) {
            result.x = part;
            seen.add("X");
          } else if (!seen.has("Y")) {
            result.y = part;
            seen.add("Y");
          } else if (!seen.has("BLUR")) {
            result.blur = part;
            seen.add("BLUR");
          } else if (!seen.has("SPREAD")) {
            result.spread = part;
            seen.add("SPREAD");
          }
        } else {
          if (!result.color) {
            result.color = part;
          } else {
            if (!result.unknown) result.unknown = [];
            result.unknown.push(part);
          }
        }
      } // Check if valid

    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    result.valid = result.x !== undefined && result.y !== undefined;
    return result;
  });
}

function _formatBoxShadowValue(shadows) {
  return shadows.map(function (shadow) {
    if (!shadow.valid) {
      return shadow.raw;
    }

    return [shadow.keyword, shadow.x, shadow.y, shadow.blur, shadow.spread, shadow.color].filter(Boolean).join(" ");
  }).join(", ");
}