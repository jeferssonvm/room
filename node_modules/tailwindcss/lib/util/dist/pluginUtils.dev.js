"use strict";

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(_getMatchingTypes);

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _export(target, all) {
  for (var name in all) {
    Object.defineProperty(target, name, {
      enumerable: true,
      get: all[name]
    });
  }
}

_export(exports, {
  updateAllClasses: function updateAllClasses() {
    return _updateAllClasses;
  },
  asValue: function asValue() {
    return _asValue;
  },
  parseColorFormat: function parseColorFormat() {
    return _parseColorFormat;
  },
  asColor: function asColor() {
    return _asColor;
  },
  asLookupValue: function asLookupValue() {
    return _asLookupValue;
  },
  typeMap: function typeMap() {
    return _typeMap;
  },
  coerceValue: function coerceValue() {
    return _coerceValue;
  },
  getMatchingTypes: function getMatchingTypes() {
    return _getMatchingTypes;
  }
});

var _escapeCommas =
/*#__PURE__*/
_interop_require_default(require("./escapeCommas"));

var _withAlphaVariable = require("./withAlphaVariable");

var _dataTypes = require("./dataTypes");

var _negateValue =
/*#__PURE__*/
_interop_require_default(require("./negateValue"));

var _validateFormalSyntax = require("./validateFormalSyntax");

var _featureFlags = require("../featureFlags.js");

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _updateAllClasses(selectors, updateClass) {
  selectors.walkClasses(function (sel) {
    sel.value = updateClass(sel.value);

    if (sel.raws && sel.raws.value) {
      sel.raws.value = (0, _escapeCommas["default"])(sel.raws.value);
    }
  });
}

function resolveArbitraryValue(modifier, validate) {
  if (!isArbitraryValue(modifier)) {
    return undefined;
  }

  var value = modifier.slice(1, -1);

  if (!validate(value)) {
    return undefined;
  }

  return (0, _dataTypes.normalize)(value);
}

function asNegativeValue(modifier) {
  var lookup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var validate = arguments.length > 2 ? arguments[2] : undefined;
  var positiveValue = lookup[modifier];

  if (positiveValue !== undefined) {
    return (0, _negateValue["default"])(positiveValue);
  }

  if (isArbitraryValue(modifier)) {
    var resolved = resolveArbitraryValue(modifier, validate);

    if (resolved === undefined) {
      return undefined;
    }

    return (0, _negateValue["default"])(resolved);
  }
}

function _asValue(modifier) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$validate = _ref.validate,
      validate = _ref$validate === void 0 ? function () {
    return true;
  } : _ref$validate;

  var _options_values;

  var value = (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];

  if (value !== undefined) {
    return value;
  }

  if (options.supportsNegativeValues && modifier.startsWith("-")) {
    return asNegativeValue(modifier.slice(1), options.values, validate);
  }

  return resolveArbitraryValue(modifier, validate);
}

function isArbitraryValue(input) {
  return input.startsWith("[") && input.endsWith("]");
}

function splitUtilityModifier(modifier) {
  var slashIdx = modifier.lastIndexOf("/");

  if (slashIdx === -1 || slashIdx === modifier.length - 1) {
    return [modifier, undefined];
  }

  var arbitrary = isArbitraryValue(modifier); // The modifier could be of the form `[foo]/[bar]`
  // We want to handle this case properly
  // without affecting `[foo/bar]`

  if (arbitrary && !modifier.includes("]/[")) {
    return [modifier, undefined];
  }

  return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)];
}

function _parseColorFormat(value) {
  if (typeof value === "string" && value.includes("<alpha-value>")) {
    var oldValue = value;
    return function (_ref2) {
      var _ref2$opacityValue = _ref2.opacityValue,
          opacityValue = _ref2$opacityValue === void 0 ? 1 : _ref2$opacityValue;
      return oldValue.replace("<alpha-value>", opacityValue);
    };
  }

  return value;
}

function unwrapArbitraryModifier(modifier) {
  return (0, _dataTypes.normalize)(modifier.slice(1, -1));
}

function _asColor(modifier) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref3$tailwindConfig = _ref3.tailwindConfig,
      tailwindConfig = _ref3$tailwindConfig === void 0 ? {} : _ref3$tailwindConfig;

  var _options_values;

  if (((_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier]) !== undefined) {
    var _options_values1;

    return _parseColorFormat((_options_values1 = options.values) === null || _options_values1 === void 0 ? void 0 : _options_values1[modifier]);
  } // TODO: Hoist this up to getMatchingTypes or something
  // We do this here because we need the alpha value (if any)


  var _splitUtilityModifier = splitUtilityModifier(modifier),
      _splitUtilityModifier2 = _slicedToArray(_splitUtilityModifier, 2),
      color = _splitUtilityModifier2[0],
      alpha = _splitUtilityModifier2[1];

  if (alpha !== undefined) {
    var _options_values2, _tailwindConfig_theme, _tailwindConfig_theme_opacity;

    var _options_values_color;

    var normalizedColor = (_options_values_color = (_options_values2 = options.values) === null || _options_values2 === void 0 ? void 0 : _options_values2[color]) !== null && _options_values_color !== void 0 ? _options_values_color : isArbitraryValue(color) ? color.slice(1, -1) : undefined;

    if (normalizedColor === undefined) {
      return undefined;
    }

    normalizedColor = _parseColorFormat(normalizedColor);

    if (isArbitraryValue(alpha)) {
      return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, unwrapArbitraryModifier(alpha));
    }

    if (((_tailwindConfig_theme = tailwindConfig.theme) === null || _tailwindConfig_theme === void 0 ? void 0 : (_tailwindConfig_theme_opacity = _tailwindConfig_theme.opacity) === null || _tailwindConfig_theme_opacity === void 0 ? void 0 : _tailwindConfig_theme_opacity[alpha]) === undefined) {
      return undefined;
    }

    return (0, _withAlphaVariable.withAlphaValue)(normalizedColor, tailwindConfig.theme.opacity[alpha]);
  }

  return _asValue(modifier, options, {
    validate: _dataTypes.color
  });
}

function _asLookupValue(modifier) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _options_values;

  return (_options_values = options.values) === null || _options_values === void 0 ? void 0 : _options_values[modifier];
}

function guess(validate) {
  return function (modifier, options) {
    return _asValue(modifier, options, {
      validate: validate
    });
  };
}

var _typeMap = {
  any: _asValue,
  color: _asColor,
  url: guess(_dataTypes.url),
  image: guess(_dataTypes.image),
  length: guess(_dataTypes.length),
  percentage: guess(_dataTypes.percentage),
  position: guess(_dataTypes.position),
  lookup: _asLookupValue,
  "generic-name": guess(_dataTypes.genericName),
  "family-name": guess(_dataTypes.familyName),
  number: guess(_dataTypes.number),
  "line-width": guess(_dataTypes.lineWidth),
  "absolute-size": guess(_dataTypes.absoluteSize),
  "relative-size": guess(_dataTypes.relativeSize),
  shadow: guess(_dataTypes.shadow),
  size: guess(_validateFormalSyntax.backgroundSize)
};
var supportedTypes = Object.keys(_typeMap);

function splitAtFirst(input, delim) {
  var idx = input.indexOf(delim);
  if (idx === -1) return [undefined, input];
  return [input.slice(0, idx), input.slice(idx + 1)];
}

function _coerceValue(types, modifier, options, tailwindConfig) {
  if (options.values && modifier in options.values) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (types !== null && types !== void 0 ? types : [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var type = _step.value.type;

        var result = _typeMap[type](modifier, options, {
          tailwindConfig: tailwindConfig
        });

        if (result === undefined) {
          continue;
        }

        return [result, type, null];
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  if (isArbitraryValue(modifier)) {
    var arbitraryValue = modifier.slice(1, -1);

    var _splitAtFirst = splitAtFirst(arbitraryValue, ":"),
        _splitAtFirst2 = _slicedToArray(_splitAtFirst, 2),
        explicitType = _splitAtFirst2[0],
        value = _splitAtFirst2[1]; // It could be that this resolves to `url(https` which is not a valid
    // identifier. We currently only support "simple" words with dashes or
    // underscores. E.g.: family-name


    if (!/^[\w-_]+$/g.test(explicitType)) {
      value = arbitraryValue;
    } else if (explicitType !== undefined && !supportedTypes.includes(explicitType)) {
      return [];
    }

    if (value.length > 0 && supportedTypes.includes(explicitType)) {
      return [_asValue("[".concat(value, "]"), options), explicitType, null];
    }
  }

  var matches = _getMatchingTypes(types, modifier, options, tailwindConfig); // Find first matching type


  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = matches[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var match = _step2.value;
      return match;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return [];
}

function _getMatchingTypes(types, rawModifier, options, tailwindConfig) {
  var modifiersEnabled, _splitUtilityModifier3, _splitUtilityModifier4, modifier, utilityModifier, canUseUtilityModifier, _options_modifiers, _options_modifiers_utilityModifier, configValue, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, type, result;

  return regeneratorRuntime.wrap(function _getMatchingTypes$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          modifiersEnabled = (0, _featureFlags.flagEnabled)(tailwindConfig, "generalizedModifiers");
          _splitUtilityModifier3 = splitUtilityModifier(rawModifier), _splitUtilityModifier4 = _slicedToArray(_splitUtilityModifier3, 2), modifier = _splitUtilityModifier4[0], utilityModifier = _splitUtilityModifier4[1];
          canUseUtilityModifier = modifiersEnabled && options.modifiers != null && (options.modifiers === "any" || _typeof(options.modifiers) === "object" && (utilityModifier && isArbitraryValue(utilityModifier) || utilityModifier in options.modifiers));

          if (!canUseUtilityModifier) {
            modifier = rawModifier;
            utilityModifier = undefined;
          }

          if (utilityModifier !== undefined && modifier === "") {
            modifier = "DEFAULT";
          } // Check the full value first
          // TODO: Move to asValue… somehow


          if (utilityModifier !== undefined) {
            if (_typeof(options.modifiers) === "object") {
              configValue = (_options_modifiers_utilityModifier = (_options_modifiers = options.modifiers) === null || _options_modifiers === void 0 ? void 0 : _options_modifiers[utilityModifier]) !== null && _options_modifiers_utilityModifier !== void 0 ? _options_modifiers_utilityModifier : null;

              if (configValue !== null) {
                utilityModifier = configValue;
              } else if (isArbitraryValue(utilityModifier)) {
                utilityModifier = unwrapArbitraryModifier(utilityModifier);
              }
            }
          }

          _iteratorNormalCompletion3 = true;
          _didIteratorError3 = false;
          _iteratorError3 = undefined;
          _context.prev = 9;
          _iterator3 = (types !== null && types !== void 0 ? types : [])[Symbol.iterator]();

        case 11:
          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
            _context.next = 21;
            break;
          }

          type = _step3.value.type;
          result = _typeMap[type](modifier, options, {
            tailwindConfig: tailwindConfig
          });

          if (!(result === undefined)) {
            _context.next = 16;
            break;
          }

          return _context.abrupt("continue", 18);

        case 16:
          _context.next = 18;
          return [result, type, utilityModifier !== null && utilityModifier !== void 0 ? utilityModifier : null];

        case 18:
          _iteratorNormalCompletion3 = true;
          _context.next = 11;
          break;

        case 21:
          _context.next = 27;
          break;

        case 23:
          _context.prev = 23;
          _context.t0 = _context["catch"](9);
          _didIteratorError3 = true;
          _iteratorError3 = _context.t0;

        case 27:
          _context.prev = 27;
          _context.prev = 28;

          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }

        case 30:
          _context.prev = 30;

          if (!_didIteratorError3) {
            _context.next = 33;
            break;
          }

          throw _iteratorError3;

        case 33:
          return _context.finish(30);

        case 34:
          return _context.finish(27);

        case 35:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[9, 23, 27, 35], [28,, 30, 34]]);
}