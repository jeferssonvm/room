/** @typedef {import('postcss-selector-parser').Root} Root */

/** @typedef {import('postcss-selector-parser').Selector} Selector */

/** @typedef {import('postcss-selector-parser').Pseudo} Pseudo */

/** @typedef {import('postcss-selector-parser').Node} Node */
// There are some pseudo-elements that may or may not be:
// **Actionable**
// Zero or more user-action pseudo-classes may be attached to the pseudo-element itself
// structural-pseudo-classes are NOT allowed but we don't make
// The spec is not clear on whether this is allowed or not â€” but in practice it is.
// **Terminal**
// It MUST be placed at the end of a selector
//
// This is the required in the spec. However, some pseudo elements are not "terminal" because
// they represent a "boundary piercing" that is compiled out by a build step.
// **Jumpable**
// Any terminal element may "jump" over combinators when moving to the end of the selector
//
// This is a backwards-compat quirk of pseudo element variants from earlier versions of Tailwind CSS.

/** @typedef {'terminal' | 'actionable' | 'jumpable'} PseudoProperty */

/** @type {Record<string, PseudoProperty[]>} */
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "movePseudos", {
  enumerable: true,
  get: function get() {
    return movePseudos;
  }
});
var elementProperties = {
  // Pseudo elements from the spec
  "::after": ["terminal", "jumpable"],
  "::backdrop": ["terminal", "jumpable"],
  "::before": ["terminal", "jumpable"],
  "::cue": ["terminal"],
  "::cue-region": ["terminal"],
  "::first-letter": ["terminal", "jumpable"],
  "::first-line": ["terminal", "jumpable"],
  "::grammar-error": ["terminal"],
  "::marker": ["terminal", "jumpable"],
  "::part": ["terminal", "actionable"],
  "::placeholder": ["terminal", "jumpable"],
  "::selection": ["terminal", "jumpable"],
  "::slotted": ["terminal"],
  "::spelling-error": ["terminal"],
  "::target-text": ["terminal"],
  // Pseudo elements from the spec with special rules
  "::file-selector-button": ["terminal", "actionable"],
  // Library-specific pseudo elements used by component libraries
  // These are Shadow DOM-like
  "::deep": ["actionable"],
  "::v-deep": ["actionable"],
  "::ng-deep": ["actionable"],
  // Note: As a rule, double colons (::) should be used instead of a single colon
  // (:). This distinguishes pseudo-classes from pseudo-elements. However, since
  // this distinction was not present in older versions of the W3C spec, most
  // browsers support both syntaxes for the original pseudo-elements.
  ":after": ["terminal", "jumpable"],
  ":before": ["terminal", "jumpable"],
  ":first-letter": ["terminal", "jumpable"],
  ":first-line": ["terminal", "jumpable"],
  // The default value is used when the pseudo-element is not recognized
  // Because it's not recognized, we don't know if it's terminal or not
  // So we assume it can be moved AND can have user-action pseudo classes attached to it
  __default__: ["terminal", "actionable"]
};

function movePseudos(sel) {
  var _sel$nodes;

  var _movablePseudos = movablePseudos(sel),
      _movablePseudos2 = _slicedToArray(_movablePseudos, 1),
      pseudos = _movablePseudos2[0]; // Remove all pseudo elements from their respective selectors


  pseudos.forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        sel = _ref2[0],
        pseudo = _ref2[1];

    return sel.removeChild(pseudo);
  }); // Re-add them to the end of the selector in the correct order.
  // This moves terminal pseudo elements to the end of the
  // selector otherwise the selector will not be valid.
  //
  // Examples:
  //  - `before:hover:text-center` would result in `.before\:hover\:text-center:hover::before`
  //  - `hover:before:text-center` would result in `.hover\:before\:text-center:hover::before`
  //
  // The selector `::before:hover` does not work but we
  // can make it work for you by flipping the order.

  (_sel$nodes = sel.nodes).push.apply(_sel$nodes, _toConsumableArray(pseudos.map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        pseudo = _ref4[1];

    return pseudo;
  })));

  return sel;
}
/** @typedef {[sel: Selector, pseudo: Pseudo, attachedTo: Pseudo | null]} MovablePseudo */

/** @typedef {[pseudos: MovablePseudo[], lastSeenElement: Pseudo | null]} MovablePseudosResult */

/**
* @param {Selector} sel
* @returns {MovablePseudosResult}
*/


function movablePseudos(sel) {
  /** @type {MovablePseudo[]} */
  var buffer = [];
  /** @type {Pseudo | null} */

  var lastSeenElement = null;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = sel.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var node = _step.value;

      if (node.type === "combinator") {
        buffer = buffer.filter(function (_ref5) {
          var _ref6 = _slicedToArray(_ref5, 2),
              node = _ref6[1];

          return propertiesForPseudo(node).includes("jumpable");
        });
        lastSeenElement = null;
      } else if (node.type === "pseudo") {
        if (isMovablePseudoElement(node)) {
          lastSeenElement = node;
          buffer.push([sel, node, null]);
        } else if (lastSeenElement && isAttachablePseudoClass(node, lastSeenElement)) {
          buffer.push([sel, node, lastSeenElement]);
        } else {
          lastSeenElement = null;
        }

        var _node_nodes;

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = ((_node_nodes = node.nodes) !== null && _node_nodes !== void 0 ? _node_nodes : [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _buffer;

            var sub = _step2.value;

            var _movablePseudos3 = movablePseudos(sub),
                _movablePseudos4 = _slicedToArray(_movablePseudos3, 2),
                movable = _movablePseudos4[0],
                lastSeenElementInSub = _movablePseudos4[1];

            lastSeenElement = lastSeenElementInSub || lastSeenElement;

            (_buffer = buffer).push.apply(_buffer, _toConsumableArray(movable));
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return [buffer, lastSeenElement];
}
/**
 * @param {Node} node
 * @returns {boolean}
 */


function isPseudoElement(node) {
  return node.value.startsWith("::") || elementProperties[node.value] !== undefined;
}
/**
 * @param {Node} node
 * @returns {boolean}
 */


function isMovablePseudoElement(node) {
  return isPseudoElement(node) && propertiesForPseudo(node).includes("terminal");
}
/**
 * @param {Node} node
 * @param {Pseudo} pseudo
 * @returns {boolean}
 */


function isAttachablePseudoClass(node, pseudo) {
  if (node.type !== "pseudo") return false;
  if (isPseudoElement(node)) return false;
  return propertiesForPseudo(pseudo).includes("actionable");
}
/**
 * @param {Pseudo} pseudo
 * @returns {PseudoProperty[]}
 */


function propertiesForPseudo(pseudo) {
  var _elementProperties_pseudo_value;

  return (_elementProperties_pseudo_value = elementProperties[pseudo.value]) !== null && _elementProperties_pseudo_value !== void 0 ? _elementProperties_pseudo_value : elementProperties.__default__;
}