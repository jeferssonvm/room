"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _export(target, all) {
  for (var name in all) {
    Object.defineProperty(target, name, {
      enumerable: true,
      get: all[name]
    });
  }
}

_export(exports, {
  normalize: function normalize() {
    return _normalize;
  },
  url: function url() {
    return _url;
  },
  number: function number() {
    return _number;
  },
  percentage: function percentage() {
    return _percentage;
  },
  length: function length() {
    return _length;
  },
  lineWidth: function lineWidth() {
    return _lineWidth;
  },
  shadow: function shadow() {
    return _shadow;
  },
  color: function color() {
    return _color2;
  },
  image: function image() {
    return _image;
  },
  gradient: function gradient() {
    return _gradient;
  },
  position: function position() {
    return _position;
  },
  familyName: function familyName() {
    return _familyName;
  },
  genericName: function genericName() {
    return _genericName;
  },
  absoluteSize: function absoluteSize() {
    return _absoluteSize;
  },
  relativeSize: function relativeSize() {
    return _relativeSize;
  }
});

var _color = require("./color");

var _parseBoxShadowValue = require("./parseBoxShadowValue");

var _splitAtTopLevelOnly = require("./splitAtTopLevelOnly");

var cssFunctions = ["min", "max", "clamp", "calc"]; // Ref: https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Types

function isCSSFunction(value) {
  return cssFunctions.some(function (fn) {
    return new RegExp("^".concat(fn, "\\(.*\\)")).test(value);
  });
} // These properties accept a `<dashed-ident>` as one of the values. This means that you can use them
// as: `timeline-scope: --tl;`
//
// Without the `var(--tl)`, in these cases we don't want to normalize the value, and you should add
// the `var()` yourself.
//
// More info:
// - https://drafts.csswg.org/scroll-animations/#propdef-timeline-scope
// - https://developer.mozilla.org/en-US/docs/Web/CSS/timeline-scope#dashed-ident
//


var AUTO_VAR_INJECTION_EXCEPTIONS = new Set([// Concrete properties
"scroll-timeline-name", "timeline-scope", "view-timeline-name", "font-palette", // Shorthand properties
"scroll-timeline", "animation-timeline", "view-timeline"]);

function _normalize(value) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var isVarException = context && AUTO_VAR_INJECTION_EXCEPTIONS.has(context.property);

  if (value.startsWith("--") && !isVarException) {
    return "var(".concat(value, ")");
  } // Keep raw strings if it starts with `url(`


  if (value.includes("url(")) {
    return value.split(/(url\(.*?\))/g).filter(Boolean).map(function (part) {
      if (/^url\(.*?\)$/.test(part)) {
        return part;
      }

      return _normalize(part, context, false);
    }).join("");
  } // Convert `_` to ` `, except for escaped underscores `\_`


  value = value.replace(/([^\\])_+/g, function (fullMatch, characterBefore) {
    return characterBefore + " ".repeat(fullMatch.length - 1);
  }).replace(/^_/g, " ").replace(/\\_/g, "_"); // Remove leftover whitespace

  if (isRoot) {
    value = value.trim();
  }

  value = normalizeMathOperatorSpacing(value);
  return value;
}
/**
 * Add spaces around operators inside math functions
 * like calc() that do not follow an operator or '('.
 *
 * @param {string} value
 * @returns {string}
 */


function normalizeMathOperatorSpacing(value) {
  var preventFormattingInFunctions = ["theme"];
  var preventFormattingKeywords = ["min-content", "max-content", "fit-content", // Env
  "safe-area-inset-top", "safe-area-inset-right", "safe-area-inset-bottom", "safe-area-inset-left", "titlebar-area-x", "titlebar-area-y", "titlebar-area-width", "titlebar-area-height", "keyboard-inset-top", "keyboard-inset-right", "keyboard-inset-bottom", "keyboard-inset-left", "keyboard-inset-width", "keyboard-inset-height"];
  return value.replace(/(calc|min|max|clamp)\(.+\)/g, function (match) {
    var result = "";

    function lastChar() {
      var _char = result.trimEnd();

      return _char[_char.length - 1];
    }

    var _loop = function _loop(_i) {
      function peek(word) {
        i = _i;
        return word.split("").every(function (_char2, j) {
          return match[_i + j] === _char2;
        });
      }

      function consumeUntil(chars) {
        var minIndex = Infinity;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = chars[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _char3 = _step.value;
            var index = match.indexOf(_char3, _i);

            if (index !== -1 && index < minIndex) {
              minIndex = index;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var result = match.slice(_i, minIndex);
        _i += result.length - 1;
        i = _i;
        return result;
      }

      var _char4 = match[_i]; // Handle `var(--variable)`

      if (peek("var")) {
        // When we consume until `)`, then we are dealing with this scenario:
        //   `var(--example)`
        //
        // When we consume until `,`, then we are dealing with this scenario:
        //   `var(--example, 1rem)`
        //
        //   In this case we do want to "format", the default value as well
        result += consumeUntil([")", ","]);
      } else if (preventFormattingKeywords.some(function (keyword) {
        return peek(keyword);
      })) {
        var keyword = preventFormattingKeywords.find(function (keyword) {
          return peek(keyword);
        });
        result += keyword;
        _i += keyword.length - 1;
      } else if (preventFormattingInFunctions.some(function (fn) {
        return peek(fn);
      })) {
        result += consumeUntil([")"]);
      } else if (["+", "-", "*", "/"].includes(_char4) && !["(", "+", "-", "*", "/"].includes(lastChar())) {
        result += " ".concat(_char4, " ");
      } else {
        result += _char4;
      }

      i = _i;
    };

    for (var i = 0; i < match.length; i++) {
      _loop(i);
    } // Simplify multiple spaces


    return result.replace(/\s+/g, " ");
  });
}

function _url(value) {
  return value.startsWith("url(");
}

function _number(value) {
  return !isNaN(Number(value)) || isCSSFunction(value);
}

function _percentage(value) {
  return value.endsWith("%") && _number(value.slice(0, -1)) || isCSSFunction(value);
} // Please refer to MDN when updating this list:
// https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Values_and_units
// https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Container_Queries#container_query_length_units


var lengthUnits = ["cm", "mm", "Q", "in", "pc", "pt", "px", "em", "ex", "ch", "rem", "lh", "rlh", "vw", "vh", "vmin", "vmax", "vb", "vi", "svw", "svh", "lvw", "lvh", "dvw", "dvh", "cqw", "cqh", "cqi", "cqb", "cqmin", "cqmax"];
var lengthUnitsPattern = "(?:".concat(lengthUnits.join("|"), ")");

function _length(value) {
  return value === "0" || new RegExp("^[+-]?[0-9]*.?[0-9]+(?:[eE][+-]?[0-9]+)?".concat(lengthUnitsPattern, "$")).test(value) || isCSSFunction(value);
}

var lineWidths = new Set(["thin", "medium", "thick"]);

function _lineWidth(value) {
  return lineWidths.has(value);
}

function _shadow(value) {
  var parsedShadows = (0, _parseBoxShadowValue.parseBoxShadowValue)(_normalize(value));
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = parsedShadows[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var parsedShadow = _step2.value;

      if (!parsedShadow.valid) {
        return false;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return true;
}

function _color2(value) {
  var colors = 0;
  var result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, "_").every(function (part) {
    part = _normalize(part);
    if (part.startsWith("var(")) return true;
    if ((0, _color.parseColor)(part, {
      loose: true
    }) !== null) return colors++, true;
    return false;
  });
  if (!result) return false;
  return colors > 0;
}

function _image(value) {
  var images = 0;
  var result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every(function (part) {
    part = _normalize(part);
    if (part.startsWith("var(")) return true;

    if (_url(part) || _gradient(part) || ["element(", "image(", "cross-fade(", "image-set("].some(function (fn) {
      return part.startsWith(fn);
    })) {
      images++;
      return true;
    }

    return false;
  });
  if (!result) return false;
  return images > 0;
}

var gradientTypes = new Set(["conic-gradient", "linear-gradient", "radial-gradient", "repeating-conic-gradient", "repeating-linear-gradient", "repeating-radial-gradient"]);

function _gradient(value) {
  value = _normalize(value);
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = gradientTypes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var type = _step3.value;

      if (value.startsWith("".concat(type, "("))) {
        return true;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return false;
}

var validPositions = new Set(["center", "top", "right", "bottom", "left"]);

function _position(value) {
  var positions = 0;
  var result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, "_").every(function (part) {
    part = _normalize(part);
    if (part.startsWith("var(")) return true;

    if (validPositions.has(part) || _length(part) || _percentage(part)) {
      positions++;
      return true;
    }

    return false;
  });
  if (!result) return false;
  return positions > 0;
}

function _familyName(value) {
  var fonts = 0;
  var result = (0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(value, ",").every(function (part) {
    part = _normalize(part);
    if (part.startsWith("var(")) return true; // If it contains spaces, then it should be quoted

    if (part.includes(" ")) {
      if (!/(['"])([^"']+)\1/g.test(part)) {
        return false;
      }
    } // If it starts with a number, it's invalid


    if (/^\d/g.test(part)) {
      return false;
    }

    fonts++;
    return true;
  });
  if (!result) return false;
  return fonts > 0;
}

var genericNames = new Set(["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]);

function _genericName(value) {
  return genericNames.has(value);
}

var absoluteSizes = new Set(["xx-small", "x-small", "small", "medium", "large", "x-large", "x-large", "xxx-large"]);

function _absoluteSize(value) {
  return absoluteSizes.has(value);
}

var relativeSizes = new Set(["larger", "smaller"]);

function _relativeSize(value) {
  return relativeSizes.has(value);
}