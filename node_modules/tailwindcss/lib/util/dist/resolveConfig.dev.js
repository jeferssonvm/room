"use strict";

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(toPaths);

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "default", {
  enumerable: true,
  get: function get() {
    return resolveConfig;
  }
});

var _negateValue =
/*#__PURE__*/
_interop_require_default(require("./negateValue"));

var _corePluginList =
/*#__PURE__*/
_interop_require_default(require("../corePluginList"));

var _configurePlugins =
/*#__PURE__*/
_interop_require_default(require("./configurePlugins"));

var _colors =
/*#__PURE__*/
_interop_require_default(require("../public/colors"));

var _defaults = require("./defaults");

var _toPath = require("./toPath");

var _normalizeConfig = require("./normalizeConfig");

var _isPlainObject =
/*#__PURE__*/
_interop_require_default(require("./isPlainObject"));

var _cloneDeep = require("./cloneDeep");

var _pluginUtils = require("./pluginUtils");

var _withAlphaVariable = require("./withAlphaVariable");

var _toColorValue =
/*#__PURE__*/
_interop_require_default(require("./toColorValue"));

function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function isFunction(input) {
  return typeof input === "function";
}

function mergeWith(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  var customizer = sources.pop();

  for (var _i = 0, _sources = sources; _i < _sources.length; _i++) {
    var source = _sources[_i];

    for (var k in source) {
      var merged = customizer(target[k], source[k]);

      if (merged === undefined) {
        if ((0, _isPlainObject["default"])(target[k]) && (0, _isPlainObject["default"])(source[k])) {
          target[k] = mergeWith({}, target[k], source[k], customizer);
        } else {
          target[k] = source[k];
        }
      } else {
        target[k] = merged;
      }
    }
  }

  return target;
}

var configUtils = {
  colors: _colors["default"],
  negative: function negative(scale) {
    // TODO: Log that this function isn't really needed anymore?
    return Object.keys(scale).filter(function (key) {
      return scale[key] !== "0";
    }).reduce(function (negativeScale, key) {
      var negativeValue = (0, _negateValue["default"])(scale[key]);

      if (negativeValue !== undefined) {
        negativeScale["-".concat(key)] = negativeValue;
      }

      return negativeScale;
    }, {});
  },
  breakpoints: function breakpoints(screens) {
    return Object.keys(screens).filter(function (key) {
      return typeof screens[key] === "string";
    }).reduce(function (breakpoints, key) {
      return _objectSpread({}, breakpoints, _defineProperty({}, "screen-".concat(key), screens[key]));
    }, {});
  }
};

function value(valueToResolve) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return isFunction(valueToResolve) ? valueToResolve.apply(void 0, args) : valueToResolve;
}

function collectExtends(items) {
  return items.reduce(function (merged, _ref) {
    var extend = _ref.extend;
    return mergeWith(merged, extend, function (mergedValue, extendValue) {
      if (mergedValue === undefined) {
        return [extendValue];
      }

      if (Array.isArray(mergedValue)) {
        return [extendValue].concat(_toConsumableArray(mergedValue));
      }

      return [extendValue, mergedValue];
    });
  }, {});
}

function mergeThemes(themes) {
  return _objectSpread({}, themes.reduce(function (merged, theme) {
    return (0, _defaults.defaults)(merged, theme);
  }, {}), {
    // In order to resolve n config objects, we combine all of their `extend` properties
    // into arrays instead of objects so they aren't overridden.
    extend: collectExtends(themes)
  });
}

function mergeExtensionCustomizer(merged, value) {
  // When we have an array of objects, we do want to merge it
  if (Array.isArray(merged) && (0, _isPlainObject["default"])(merged[0])) {
    return merged.concat(value);
  } // When the incoming value is an array, and the existing config is an object, prepend the existing object


  if (Array.isArray(value) && (0, _isPlainObject["default"])(value[0]) && (0, _isPlainObject["default"])(merged)) {
    return [merged].concat(_toConsumableArray(value));
  } // Override arrays (for example for font-families, box-shadows, ...)


  if (Array.isArray(value)) {
    return value;
  } // Execute default behaviour


  return undefined;
}

function mergeExtensions(_ref2) {
  var extend = _ref2.extend,
      theme = _objectWithoutProperties(_ref2, ["extend"]);

  return mergeWith(theme, extend, function (themeValue, extensions) {
    // The `extend` property is an array, so we need to check if it contains any functions
    if (!isFunction(themeValue) && !extensions.some(isFunction)) {
      return mergeWith.apply(void 0, [{}, themeValue].concat(_toConsumableArray(extensions), [mergeExtensionCustomizer]));
    }

    return function (resolveThemePath, utils) {
      return mergeWith.apply(void 0, [{}].concat(_toConsumableArray([themeValue].concat(_toConsumableArray(extensions)).map(function (e) {
        return value(e, resolveThemePath, utils);
      })), [mergeExtensionCustomizer]));
    };
  });
}
/**
 *
 * @param {string} key
 * @return {Iterable<string[] & {alpha: string | undefined}>}
 */


function toPaths(key) {
  var path, pattern, matches, _matches, prefix, alpha, newPath;

  return regeneratorRuntime.wrap(function toPaths$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          path = (0, _toPath.toPath)(key);

          if (!(path.length === 0)) {
            _context.next = 3;
            break;
          }

          return _context.abrupt("return");

        case 3:
          _context.next = 5;
          return path;

        case 5:
          if (!Array.isArray(key)) {
            _context.next = 7;
            break;
          }

          return _context.abrupt("return");

        case 7:
          pattern = /^(.*?)\s*\/\s*([^/]+)$/;
          matches = key.match(pattern);

          if (!(matches !== null)) {
            _context.next = 15;
            break;
          }

          _matches = _slicedToArray(matches, 3), prefix = _matches[1], alpha = _matches[2];
          newPath = (0, _toPath.toPath)(prefix);
          newPath.alpha = alpha;
          _context.next = 15;
          return newPath;

        case 15:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

function resolveFunctionKeys(object) {
  // theme('colors.red.500 / 0.5') -> ['colors', 'red', '500 / 0', '5]
  var resolvePath = function resolvePath(key, defaultValue) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = toPaths(key)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var path = _step.value;
        var index = 0;
        var val = object;

        while (val !== undefined && val !== null && index < path.length) {
          val = val[path[index++]];
          var shouldResolveAsFn = isFunction(val) && (path.alpha === undefined || index <= path.length - 1);
          val = shouldResolveAsFn ? val(resolvePath, configUtils) : val;
        }

        if (val !== undefined) {
          if (path.alpha !== undefined) {
            var normalized = (0, _pluginUtils.parseColorFormat)(val);
            return (0, _withAlphaVariable.withAlphaValue)(normalized, path.alpha, (0, _toColorValue["default"])(normalized));
          }

          if ((0, _isPlainObject["default"])(val)) {
            return (0, _cloneDeep.cloneDeep)(val);
          }

          return val;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return defaultValue;
  };

  Object.assign(resolvePath, _objectSpread({
    theme: resolvePath
  }, configUtils));
  return Object.keys(object).reduce(function (resolved, key) {
    resolved[key] = isFunction(object[key]) ? object[key](resolvePath, configUtils) : object[key];
    return resolved;
  }, {});
}

function extractPluginConfigs(configs) {
  var allConfigs = [];
  configs.forEach(function (config) {
    allConfigs = [].concat(_toConsumableArray(allConfigs), [config]);

    var _config_plugins;

    var plugins = (_config_plugins = config === null || config === void 0 ? void 0 : config.plugins) !== null && _config_plugins !== void 0 ? _config_plugins : [];

    if (plugins.length === 0) {
      return;
    }

    plugins.forEach(function (plugin) {
      if (plugin.__isOptionsFunction) {
        plugin = plugin();
      }

      var _plugin_config;

      allConfigs = [].concat(_toConsumableArray(allConfigs), _toConsumableArray(extractPluginConfigs([(_plugin_config = plugin === null || plugin === void 0 ? void 0 : plugin.config) !== null && _plugin_config !== void 0 ? _plugin_config : {}])));
    });
  });
  return allConfigs;
}

function resolveCorePlugins(corePluginConfigs) {
  var result = _toConsumableArray(corePluginConfigs).reduceRight(function (resolved, corePluginConfig) {
    if (isFunction(corePluginConfig)) {
      return corePluginConfig({
        corePlugins: resolved
      });
    }

    return (0, _configurePlugins["default"])(corePluginConfig, resolved);
  }, _corePluginList["default"]);

  return result;
}

function resolvePluginLists(pluginLists) {
  var result = _toConsumableArray(pluginLists).reduceRight(function (resolved, pluginList) {
    return [].concat(_toConsumableArray(resolved), _toConsumableArray(pluginList));
  }, []);

  return result;
}

function resolveConfig(configs) {
  var allConfigs = [].concat(_toConsumableArray(extractPluginConfigs(configs)), [{
    prefix: "",
    important: false,
    separator: ":"
  }]);

  var _t_theme, _c_plugins;

  return (0, _normalizeConfig.normalizeConfig)((0, _defaults.defaults).apply(void 0, [{
    theme: resolveFunctionKeys(mergeExtensions(mergeThemes(allConfigs.map(function (t) {
      return (_t_theme = t === null || t === void 0 ? void 0 : t.theme) !== null && _t_theme !== void 0 ? _t_theme : {};
    })))),
    corePlugins: resolveCorePlugins(allConfigs.map(function (c) {
      return c.corePlugins;
    })),
    plugins: resolvePluginLists(configs.map(function (c) {
      return (_c_plugins = c === null || c === void 0 ? void 0 : c.plugins) !== null && _c_plugins !== void 0 ? _c_plugins : [];
    }))
  }].concat(_toConsumableArray(allConfigs))));
}