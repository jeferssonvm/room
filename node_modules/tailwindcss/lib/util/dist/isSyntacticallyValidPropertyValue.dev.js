"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, // Arbitrary values must contain balanced brackets (), [] and {}. Escaped
// values don't count, and brackets inside quotes also don't count.
//
// E.g.: w-[this-is]w-[weird-and-invalid]
// E.g.: w-[this-is\\]w-\\[weird-but-valid]
// E.g.: content-['this-is-also-valid]-weirdly-enough']
"default", {
  enumerable: true,
  get: function get() {
    return isSyntacticallyValidPropertyValue;
  }
});
var matchingBrackets = new Map([["{", "}"], ["[", "]"], ["(", ")"]]);
var inverseMatchingBrackets = new Map(Array.from(matchingBrackets.entries()).map(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      k = _ref2[0],
      v = _ref2[1];

  return [v, k];
}));
var quotes = new Set(['"', "'", "`"]);

function isSyntacticallyValidPropertyValue(value) {
  var stack = [];
  var inQuotes = false;

  for (var i = 0; i < value.length; i++) {
    var _char = value[i];

    if (_char === ":" && !inQuotes && stack.length === 0) {
      return false;
    } // Non-escaped quotes allow us to "allow" anything in between


    if (quotes.has(_char) && value[i - 1] !== "\\") {
      inQuotes = !inQuotes;
    }

    if (inQuotes) continue;
    if (value[i - 1] === "\\") continue; // Escaped

    if (matchingBrackets.has(_char)) {
      stack.push(_char);
    } else if (inverseMatchingBrackets.has(_char)) {
      var inverse = inverseMatchingBrackets.get(_char); // Nothing to pop from, therefore it is unbalanced

      if (stack.length <= 0) {
        return false;
      } // Popped value must match the inverse value, otherwise it is unbalanced


      if (stack.pop() !== inverse) {
        return false;
      }
    }
  } // If there is still something on the stack, it is also unbalanced


  if (stack.length > 0) {
    return false;
  } // All good, totally balanced!


  return true;
}