"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.random = exports.customAlphabet = exports.nanoid = void 0;

var random = function random(bytes) {
  return regeneratorRuntime.async(function random$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", crypto.getRandomValues(new Uint8Array(bytes)));

        case 1:
        case "end":
          return _context.stop();
      }
    }
  });
};

exports.random = random;

var customAlphabet = function customAlphabet(alphabet) {
  var defaultSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 21;
  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  var step = -~(1.6 * mask * defaultSize / alphabet.length);
  return function _callee() {
    var size,
        id,
        bytes,
        i,
        _args2 = arguments;
    return regeneratorRuntime.async(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            size = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : defaultSize;
            id = '';

          case 2:
            if (!true) {
              _context2.next = 13;
              break;
            }

            bytes = crypto.getRandomValues(new Uint8Array(step));
            i = step;

          case 5:
            if (!i--) {
              _context2.next = 11;
              break;
            }

            id += alphabet[bytes[i] & mask] || '';

            if (!(id.length === size)) {
              _context2.next = 9;
              break;
            }

            return _context2.abrupt("return", id);

          case 9:
            _context2.next = 5;
            break;

          case 11:
            _context2.next = 2;
            break;

          case 13:
          case "end":
            return _context2.stop();
        }
      }
    });
  };
};

exports.customAlphabet = customAlphabet;

var nanoid = function nanoid() {
  var size,
      id,
      bytes,
      _byte,
      _args3 = arguments;

  return regeneratorRuntime.async(function nanoid$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          size = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 21;
          id = '';
          bytes = crypto.getRandomValues(new Uint8Array(size));

          while (size--) {
            _byte = bytes[size] & 63;

            if (_byte < 36) {
              id += _byte.toString(36);
            } else if (_byte < 62) {
              id += (_byte - 26).toString(36).toUpperCase();
            } else if (_byte < 63) {
              id += '_';
            } else {
              id += '-';
            }
          }

          return _context3.abrupt("return", id);

        case 5:
        case "end":
          return _context3.stop();
      }
    }
  });
};

exports.nanoid = nanoid;