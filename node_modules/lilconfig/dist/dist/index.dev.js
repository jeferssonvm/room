"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;

var path = require("path");

var fs = require("fs");

var os = require("os");

var fsReadFileAsync = fs.promises.readFile;

function getDefaultSearchPlaces(name) {
  return ['package.json', ".".concat(name, "rc.json"), ".".concat(name, "rc.js"), ".".concat(name, "rc.cjs"), ".config/".concat(name, "rc"), ".config/".concat(name, "rc.json"), ".config/".concat(name, "rc.js"), ".config/".concat(name, "rc.cjs"), "".concat(name, ".config.js"), "".concat(name, ".config.cjs")];
}

function getSearchPaths(startDir, stopDir) {
  return startDir.split(path.sep).reduceRight(function (acc, _, ind, arr) {
    var currentPath = arr.slice(0, ind + 1).join(path.sep);
    if (!acc.passedStopDir) acc.searchPlaces.push(currentPath || path.sep);
    if (currentPath === stopDir) acc.passedStopDir = true;
    return acc;
  }, {
    searchPlaces: [],
    passedStopDir: false
  }).searchPlaces;
}

exports.defaultLoaders = Object.freeze({
  '.js': require,
  '.json': require,
  '.cjs': require,
  noExt: function noExt(_, content) {
    return JSON.parse(content);
  }
});

function getExtDesc(ext) {
  return ext === 'noExt' ? 'files without extensions' : "extension \"".concat(ext, "\"");
}

function getOptions(name) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var conf = _objectSpread({
    stopDir: os.homedir(),
    searchPlaces: getDefaultSearchPlaces(name),
    ignoreEmptySearchPlaces: true,
    transform: function transform(x) {
      return x;
    },
    packageProp: [name]
  }, options, {
    loaders: _objectSpread({}, exports.defaultLoaders, {}, options.loaders)
  });

  conf.searchPlaces.forEach(function (place) {
    var key = path.extname(place) || 'noExt';
    var loader = conf.loaders[key];

    if (!loader) {
      throw new Error("No loader specified for ".concat(getExtDesc(key), ", so searchPlaces item \"").concat(place, "\" is invalid"));
    }

    if (typeof loader !== 'function') {
      throw new Error("loader for ".concat(getExtDesc(key), " is not a function (type provided: \"").concat(_typeof(loader), "\"), so searchPlaces item \"").concat(place, "\" is invalid"));
    }
  });
  return conf;
}

function getPackageProp(props, obj) {
  if (typeof props === 'string' && props in obj) return obj[props];
  return (Array.isArray(props) ? props : props.split('.')).reduce(function (acc, prop) {
    return acc === undefined ? acc : acc[prop];
  }, obj) || null;
}

function getSearchItems(searchPlaces, searchPaths) {
  return searchPaths.reduce(function (acc, searchPath) {
    searchPlaces.forEach(function (sp) {
      return acc.push({
        searchPlace: sp,
        filepath: path.join(searchPath, sp),
        loaderKey: path.extname(sp) || 'noExt'
      });
    });
    return acc;
  }, []);
}

function validateFilePath(filepath) {
  if (!filepath) throw new Error('load must pass a non-empty string');
}

function validateLoader(loader, ext) {
  if (!loader) throw new Error("No loader specified for extension \"".concat(ext, "\""));
  if (typeof loader !== 'function') throw new Error('loader is not a function');
}

function lilconfig(name, options) {
  var _getOptions = getOptions(name, options),
      ignoreEmptySearchPlaces = _getOptions.ignoreEmptySearchPlaces,
      loaders = _getOptions.loaders,
      packageProp = _getOptions.packageProp,
      searchPlaces = _getOptions.searchPlaces,
      stopDir = _getOptions.stopDir,
      transform = _getOptions.transform;

  return {
    search: function search() {
      var searchFrom,
          searchPaths,
          result,
          searchItems,
          _iteratorNormalCompletion,
          _didIteratorError,
          _iteratorError,
          _iterator,
          _step,
          _step$value,
          searchPlace,
          filepath,
          loaderKey,
          content,
          loader,
          pkg,
          maybeConfig,
          isEmpty,
          _args = arguments;

      return regeneratorRuntime.async(function search$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              searchFrom = _args.length > 0 && _args[0] !== undefined ? _args[0] : process.cwd();
              searchPaths = getSearchPaths(searchFrom, stopDir);
              result = {
                config: null,
                filepath: ''
              };
              searchItems = getSearchItems(searchPlaces, searchPaths);
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context.prev = 7;
              _iterator = searchItems[Symbol.iterator]();

            case 9:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context.next = 52;
                break;
              }

              _step$value = _step.value, searchPlace = _step$value.searchPlace, filepath = _step$value.filepath, loaderKey = _step$value.loaderKey;
              _context.prev = 11;
              _context.next = 14;
              return regeneratorRuntime.awrap(fs.promises.access(filepath));

            case 14:
              _context.next = 19;
              break;

            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](11);
              return _context.abrupt("continue", 49);

            case 19:
              _context.t1 = String;
              _context.next = 22;
              return regeneratorRuntime.awrap(fsReadFileAsync(filepath));

            case 22:
              _context.t2 = _context.sent;
              content = (0, _context.t1)(_context.t2);
              loader = loaders[loaderKey];

              if (!(searchPlace === 'package.json')) {
                _context.next = 35;
                break;
              }

              _context.next = 28;
              return regeneratorRuntime.awrap(loader(filepath, content));

            case 28:
              pkg = _context.sent;
              maybeConfig = getPackageProp(packageProp, pkg);

              if (!(maybeConfig != null)) {
                _context.next = 34;
                break;
              }

              result.config = maybeConfig;
              result.filepath = filepath;
              return _context.abrupt("break", 52);

            case 34:
              return _context.abrupt("continue", 49);

            case 35:
              isEmpty = content.trim() === '';

              if (!(isEmpty && ignoreEmptySearchPlaces)) {
                _context.next = 38;
                break;
              }

              return _context.abrupt("continue", 49);

            case 38:
              if (!isEmpty) {
                _context.next = 43;
                break;
              }

              result.isEmpty = true;
              result.config = undefined;
              _context.next = 47;
              break;

            case 43:
              validateLoader(loader, loaderKey);
              _context.next = 46;
              return regeneratorRuntime.awrap(loader(filepath, content));

            case 46:
              result.config = _context.sent;

            case 47:
              result.filepath = filepath;
              return _context.abrupt("break", 52);

            case 49:
              _iteratorNormalCompletion = true;
              _context.next = 9;
              break;

            case 52:
              _context.next = 58;
              break;

            case 54:
              _context.prev = 54;
              _context.t3 = _context["catch"](7);
              _didIteratorError = true;
              _iteratorError = _context.t3;

            case 58:
              _context.prev = 58;
              _context.prev = 59;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 61:
              _context.prev = 61;

              if (!_didIteratorError) {
                _context.next = 64;
                break;
              }

              throw _iteratorError;

            case 64:
              return _context.finish(61);

            case 65:
              return _context.finish(58);

            case 66:
              if (!(result.filepath === '' && result.config === null)) {
                _context.next = 68;
                break;
              }

              return _context.abrupt("return", transform(null));

            case 68:
              return _context.abrupt("return", transform(result));

            case 69:
            case "end":
              return _context.stop();
          }
        }
      }, null, null, [[7, 54, 58, 66], [11, 16], [59,, 61, 65]]);
    },
    load: function load(filepath) {
      var absPath, _path$parse, base, ext, loaderKey, loader, content, pkg, result, isEmpty;

      return regeneratorRuntime.async(function load$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              validateFilePath(filepath);
              absPath = path.resolve(process.cwd(), filepath);
              _path$parse = path.parse(absPath), base = _path$parse.base, ext = _path$parse.ext;
              loaderKey = ext || 'noExt';
              loader = loaders[loaderKey];
              validateLoader(loader, loaderKey);
              _context2.t0 = String;
              _context2.next = 9;
              return regeneratorRuntime.awrap(fsReadFileAsync(absPath));

            case 9:
              _context2.t1 = _context2.sent;
              content = (0, _context2.t0)(_context2.t1);

              if (!(base === 'package.json')) {
                _context2.next = 16;
                break;
              }

              _context2.next = 14;
              return regeneratorRuntime.awrap(loader(absPath, content));

            case 14:
              pkg = _context2.sent;
              return _context2.abrupt("return", transform({
                config: getPackageProp(packageProp, pkg),
                filepath: absPath
              }));

            case 16:
              result = {
                config: null,
                filepath: absPath
              };
              isEmpty = content.trim() === '';

              if (!(isEmpty && ignoreEmptySearchPlaces)) {
                _context2.next = 20;
                break;
              }

              return _context2.abrupt("return", transform({
                config: undefined,
                filepath: absPath,
                isEmpty: true
              }));

            case 20:
              if (!isEmpty) {
                _context2.next = 24;
                break;
              }

              _context2.t2 = undefined;
              _context2.next = 27;
              break;

            case 24:
              _context2.next = 26;
              return regeneratorRuntime.awrap(loader(absPath, content));

            case 26:
              _context2.t2 = _context2.sent;

            case 27:
              result.config = _context2.t2;
              return _context2.abrupt("return", transform(isEmpty ? _objectSpread({}, result, {
                isEmpty: isEmpty,
                config: undefined
              }) : result));

            case 29:
            case "end":
              return _context2.stop();
          }
        }
      });
    }
  };
}

exports.lilconfig = lilconfig;

function lilconfigSync(name, options) {
  var _getOptions2 = getOptions(name, options),
      ignoreEmptySearchPlaces = _getOptions2.ignoreEmptySearchPlaces,
      loaders = _getOptions2.loaders,
      packageProp = _getOptions2.packageProp,
      searchPlaces = _getOptions2.searchPlaces,
      stopDir = _getOptions2.stopDir,
      transform = _getOptions2.transform;

  return {
    search: function search() {
      var searchFrom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();
      var searchPaths = getSearchPaths(searchFrom, stopDir);
      var result = {
        config: null,
        filepath: ''
      };
      var searchItems = getSearchItems(searchPlaces, searchPaths);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = searchItems[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = _step2.value,
              searchPlace = _step2$value.searchPlace,
              filepath = _step2$value.filepath,
              loaderKey = _step2$value.loaderKey;

          try {
            fs.accessSync(filepath);
          } catch (_a) {
            continue;
          }

          var loader = loaders[loaderKey];
          var content = String(fs.readFileSync(filepath));

          if (searchPlace === 'package.json') {
            var pkg = loader(filepath, content);
            var maybeConfig = getPackageProp(packageProp, pkg);

            if (maybeConfig != null) {
              result.config = maybeConfig;
              result.filepath = filepath;
              break;
            }

            continue;
          }

          var isEmpty = content.trim() === '';
          if (isEmpty && ignoreEmptySearchPlaces) continue;

          if (isEmpty) {
            result.isEmpty = true;
            result.config = undefined;
          } else {
            validateLoader(loader, loaderKey);
            result.config = loader(filepath, content);
          }

          result.filepath = filepath;
          break;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (result.filepath === '' && result.config === null) return transform(null);
      return transform(result);
    },
    load: function load(filepath) {
      validateFilePath(filepath);
      var absPath = path.resolve(process.cwd(), filepath);

      var _path$parse2 = path.parse(absPath),
          base = _path$parse2.base,
          ext = _path$parse2.ext;

      var loaderKey = ext || 'noExt';
      var loader = loaders[loaderKey];
      validateLoader(loader, loaderKey);
      var content = String(fs.readFileSync(absPath));

      if (base === 'package.json') {
        var pkg = loader(absPath, content);
        return transform({
          config: getPackageProp(packageProp, pkg),
          filepath: absPath
        });
      }

      var result = {
        config: null,
        filepath: absPath
      };
      var isEmpty = content.trim() === '';
      if (isEmpty && ignoreEmptySearchPlaces) return transform({
        filepath: absPath,
        config: undefined,
        isEmpty: true
      });
      result.config = isEmpty ? undefined : loader(absPath, content);
      return transform(isEmpty ? _objectSpread({}, result, {
        isEmpty: isEmpty,
        config: undefined
      }) : result);
    }
  };
}

exports.lilconfigSync = lilconfigSync;