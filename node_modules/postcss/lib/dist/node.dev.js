'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require('./symbols'),
    isClean = _require.isClean,
    my = _require.my;

var CssSyntaxError = require('./css-syntax-error');

var Stringifier = require('./stringifier');

var stringify = require('./stringify');

function cloneNode(obj, parent) {
  var cloned = new obj.constructor();

  for (var i in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
      /* c8 ignore next 2 */
      continue;
    }

    if (i === 'proxyCache') continue;
    var value = obj[i];

    var type = _typeof(value);

    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent;
    } else if (i === 'source') {
      cloned[i] = value;
    } else if (Array.isArray(value)) {
      cloned[i] = value.map(function (j) {
        return cloneNode(j, cloned);
      });
    } else {
      if (type === 'object' && value !== null) value = cloneNode(value);
      cloned[i] = value;
    }
  }

  return cloned;
}

var Node =
/*#__PURE__*/
function () {
  function Node() {
    var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Node);

    this.raws = {};
    this[isClean] = false;
    this[my] = true;

    for (var name in defaults) {
      if (name === 'nodes') {
        this.nodes = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = defaults[name][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;

            if (typeof node.clone === 'function') {
              this.append(node.clone());
            } else {
              this.append(node);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else {
        this[name] = defaults[name];
      }
    }
  }

  _createClass(Node, [{
    key: "addToError",
    value: function addToError(error) {
      error.postcssNode = this;

      if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
        var s = this.source;
        error.stack = error.stack.replace(/\n\s{4}at /, "$&".concat(s.input.from, ":").concat(s.start.line, ":").concat(s.start.column, "$&"));
      }

      return error;
    }
  }, {
    key: "after",
    value: function after(add) {
      this.parent.insertAfter(this, add);
      return this;
    }
  }, {
    key: "assign",
    value: function assign() {
      var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      for (var name in overrides) {
        this[name] = overrides[name];
      }

      return this;
    }
  }, {
    key: "before",
    value: function before(add) {
      this.parent.insertBefore(this, add);
      return this;
    }
  }, {
    key: "cleanRaws",
    value: function cleanRaws(keepBetween) {
      delete this.raws.before;
      delete this.raws.after;
      if (!keepBetween) delete this.raws.between;
    }
  }, {
    key: "clone",
    value: function clone() {
      var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var cloned = cloneNode(this);

      for (var name in overrides) {
        cloned[name] = overrides[name];
      }

      return cloned;
    }
  }, {
    key: "cloneAfter",
    value: function cloneAfter() {
      var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var cloned = this.clone(overrides);
      this.parent.insertAfter(this, cloned);
      return cloned;
    }
  }, {
    key: "cloneBefore",
    value: function cloneBefore() {
      var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var cloned = this.clone(overrides);
      this.parent.insertBefore(this, cloned);
      return cloned;
    }
  }, {
    key: "error",
    value: function error(message) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.source) {
        var _this$rangeBy = this.rangeBy(opts),
            end = _this$rangeBy.end,
            start = _this$rangeBy.start;

        return this.source.input.error(message, {
          column: start.column,
          line: start.line
        }, {
          column: end.column,
          line: end.line
        }, opts);
      }

      return new CssSyntaxError(message);
    }
  }, {
    key: "getProxyProcessor",
    value: function getProxyProcessor() {
      return {
        get: function get(node, prop) {
          if (prop === 'proxyOf') {
            return node;
          } else if (prop === 'root') {
            return function () {
              return node.root().toProxy();
            };
          } else {
            return node[prop];
          }
        },
        set: function set(node, prop, value) {
          if (node[prop] === value) return true;
          node[prop] = value;

          if (prop === 'prop' || prop === 'value' || prop === 'name' || prop === 'params' || prop === 'important' ||
          /* c8 ignore next */
          prop === 'text') {
            node.markDirty();
          }

          return true;
        }
      };
    }
  }, {
    key: "markDirty",
    value: function markDirty() {
      if (this[isClean]) {
        this[isClean] = false;
        var next = this;

        while (next = next.parent) {
          next[isClean] = false;
        }
      }
    }
  }, {
    key: "next",
    value: function next() {
      if (!this.parent) return undefined;
      var index = this.parent.index(this);
      return this.parent.nodes[index + 1];
    }
  }, {
    key: "positionBy",
    value: function positionBy(opts, stringRepresentation) {
      var pos = this.source.start;

      if (opts.index) {
        pos = this.positionInside(opts.index, stringRepresentation);
      } else if (opts.word) {
        stringRepresentation = this.toString();
        var index = stringRepresentation.indexOf(opts.word);
        if (index !== -1) pos = this.positionInside(index, stringRepresentation);
      }

      return pos;
    }
  }, {
    key: "positionInside",
    value: function positionInside(index, stringRepresentation) {
      var string = stringRepresentation || this.toString();
      var column = this.source.start.column;
      var line = this.source.start.line;

      for (var i = 0; i < index; i++) {
        if (string[i] === '\n') {
          column = 1;
          line += 1;
        } else {
          column += 1;
        }
      }

      return {
        column: column,
        line: line
      };
    }
  }, {
    key: "prev",
    value: function prev() {
      if (!this.parent) return undefined;
      var index = this.parent.index(this);
      return this.parent.nodes[index - 1];
    }
  }, {
    key: "rangeBy",
    value: function rangeBy(opts) {
      var start = {
        column: this.source.start.column,
        line: this.source.start.line
      };
      var end = this.source.end ? {
        column: this.source.end.column + 1,
        line: this.source.end.line
      } : {
        column: start.column + 1,
        line: start.line
      };

      if (opts.word) {
        var stringRepresentation = this.toString();
        var index = stringRepresentation.indexOf(opts.word);

        if (index !== -1) {
          start = this.positionInside(index, stringRepresentation);
          end = this.positionInside(index + opts.word.length, stringRepresentation);
        }
      } else {
        if (opts.start) {
          start = {
            column: opts.start.column,
            line: opts.start.line
          };
        } else if (opts.index) {
          start = this.positionInside(opts.index);
        }

        if (opts.end) {
          end = {
            column: opts.end.column,
            line: opts.end.line
          };
        } else if (opts.endIndex) {
          end = this.positionInside(opts.endIndex);
        } else if (opts.index) {
          end = this.positionInside(opts.index + 1);
        }
      }

      if (end.line < start.line || end.line === start.line && end.column <= start.column) {
        end = {
          column: start.column + 1,
          line: start.line
        };
      }

      return {
        end: end,
        start: start
      };
    }
  }, {
    key: "raw",
    value: function raw(prop, defaultType) {
      var str = new Stringifier();
      return str.raw(this, prop, defaultType);
    }
  }, {
    key: "remove",
    value: function remove() {
      if (this.parent) {
        this.parent.removeChild(this);
      }

      this.parent = undefined;
      return this;
    }
  }, {
    key: "replaceWith",
    value: function replaceWith() {
      if (this.parent) {
        var bookmark = this;
        var foundSelf = false;

        for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {
          nodes[_key] = arguments[_key];
        }

        for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {
          var node = _nodes[_i];

          if (node === this) {
            foundSelf = true;
          } else if (foundSelf) {
            this.parent.insertAfter(bookmark, node);
            bookmark = node;
          } else {
            this.parent.insertBefore(bookmark, node);
          }
        }

        if (!foundSelf) {
          this.remove();
        }
      }

      return this;
    }
  }, {
    key: "root",
    value: function root() {
      var result = this;

      while (result.parent && result.parent.type !== 'document') {
        result = result.parent;
      }

      return result;
    }
  }, {
    key: "toJSON",
    value: function toJSON(_, inputs) {
      var fixed = {};
      var emitInputs = inputs == null;
      inputs = inputs || new Map();
      var inputsNextIndex = 0;

      for (var name in this) {
        if (!Object.prototype.hasOwnProperty.call(this, name)) {
          /* c8 ignore next 2 */
          continue;
        }

        if (name === 'parent' || name === 'proxyCache') continue;
        var value = this[name];

        if (Array.isArray(value)) {
          fixed[name] = value.map(function (i) {
            if (_typeof(i) === 'object' && i.toJSON) {
              return i.toJSON(null, inputs);
            } else {
              return i;
            }
          });
        } else if (_typeof(value) === 'object' && value.toJSON) {
          fixed[name] = value.toJSON(null, inputs);
        } else if (name === 'source') {
          var inputId = inputs.get(value.input);

          if (inputId == null) {
            inputId = inputsNextIndex;
            inputs.set(value.input, inputsNextIndex);
            inputsNextIndex++;
          }

          fixed[name] = {
            end: value.end,
            inputId: inputId,
            start: value.start
          };
        } else {
          fixed[name] = value;
        }
      }

      if (emitInputs) {
        fixed.inputs = _toConsumableArray(inputs.keys()).map(function (input) {
          return input.toJSON();
        });
      }

      return fixed;
    }
  }, {
    key: "toProxy",
    value: function toProxy() {
      if (!this.proxyCache) {
        this.proxyCache = new Proxy(this, this.getProxyProcessor());
      }

      return this.proxyCache;
    }
  }, {
    key: "toString",
    value: function toString() {
      var stringifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : stringify;
      if (stringifier.stringify) stringifier = stringifier.stringify;
      var result = '';
      stringifier(this, function (i) {
        result += i;
      });
      return result;
    }
  }, {
    key: "warn",
    value: function warn(result, text, opts) {
      var data = {
        node: this
      };

      for (var i in opts) {
        data[i] = opts[i];
      }

      return result.warn(text, data);
    }
  }, {
    key: "proxyOf",
    get: function get() {
      return this;
    }
  }]);

  return Node;
}();

module.exports = Node;
Node["default"] = Node;