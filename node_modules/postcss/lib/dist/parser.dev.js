'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Declaration = require('./declaration');

var tokenizer = require('./tokenize');

var Comment = require('./comment');

var AtRule = require('./at-rule');

var Root = require('./root');

var Rule = require('./rule');

var SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
};

function findLastWithPosition(tokens) {
  for (var i = tokens.length - 1; i >= 0; i--) {
    var token = tokens[i];
    var pos = token[3] || token[2];
    if (pos) return pos;
  }
}

var Parser =
/*#__PURE__*/
function () {
  function Parser(input) {
    _classCallCheck(this, Parser);

    this.input = input;
    this.root = new Root();
    this.current = this.root;
    this.spaces = '';
    this.semicolon = false;
    this.customProperty = false;
    this.createTokenizer();
    this.root.source = {
      input: input,
      start: {
        column: 1,
        line: 1,
        offset: 0
      }
    };
  }

  _createClass(Parser, [{
    key: "atrule",
    value: function atrule(token) {
      var node = new AtRule();
      node.name = token[1].slice(1);

      if (node.name === '') {
        this.unnamedAtrule(node, token);
      }

      this.init(node, token[2]);
      var type;
      var prev;
      var shift;
      var last = false;
      var open = false;
      var params = [];
      var brackets = [];

      while (!this.tokenizer.endOfFile()) {
        token = this.tokenizer.nextToken();
        type = token[0];

        if (type === '(' || type === '[') {
          brackets.push(type === '(' ? ')' : ']');
        } else if (type === '{' && brackets.length > 0) {
          brackets.push('}');
        } else if (type === brackets[brackets.length - 1]) {
          brackets.pop();
        }

        if (brackets.length === 0) {
          if (type === ';') {
            node.source.end = this.getPosition(token[2]);
            node.source.end.offset++;
            this.semicolon = true;
            break;
          } else if (type === '{') {
            open = true;
            break;
          } else if (type === '}') {
            if (params.length > 0) {
              shift = params.length - 1;
              prev = params[shift];

              while (prev && prev[0] === 'space') {
                prev = params[--shift];
              }

              if (prev) {
                node.source.end = this.getPosition(prev[3] || prev[2]);
                node.source.end.offset++;
              }
            }

            this.end(token);
            break;
          } else {
            params.push(token);
          }
        } else {
          params.push(token);
        }

        if (this.tokenizer.endOfFile()) {
          last = true;
          break;
        }
      }

      node.raws.between = this.spacesAndCommentsFromEnd(params);

      if (params.length) {
        node.raws.afterName = this.spacesAndCommentsFromStart(params);
        this.raw(node, 'params', params);

        if (last) {
          token = params[params.length - 1];
          node.source.end = this.getPosition(token[3] || token[2]);
          node.source.end.offset++;
          this.spaces = node.raws.between;
          node.raws.between = '';
        }
      } else {
        node.raws.afterName = '';
        node.params = '';
      }

      if (open) {
        node.nodes = [];
        this.current = node;
      }
    }
  }, {
    key: "checkMissedSemicolon",
    value: function checkMissedSemicolon(tokens) {
      var colon = this.colon(tokens);
      if (colon === false) return;
      var founded = 0;
      var token;

      for (var j = colon - 1; j >= 0; j--) {
        token = tokens[j];

        if (token[0] !== 'space') {
          founded += 1;
          if (founded === 2) break;
        }
      } // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
      // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
      // And because we need it after that one we do +1 to get the next one.


      throw this.input.error('Missed semicolon', token[0] === 'word' ? token[3] + 1 : token[2]);
    }
  }, {
    key: "colon",
    value: function colon(tokens) {
      var brackets = 0;
      var token, type, prev;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = tokens.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              i = _step$value[0],
              element = _step$value[1];

          token = element;
          type = token[0];

          if (type === '(') {
            brackets += 1;
          }

          if (type === ')') {
            brackets -= 1;
          }

          if (brackets === 0 && type === ':') {
            if (!prev) {
              this.doubleColon(token);
            } else if (prev[0] === 'word' && prev[1] === 'progid') {
              continue;
            } else {
              return i;
            }
          }

          prev = token;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return false;
    }
  }, {
    key: "comment",
    value: function comment(token) {
      var node = new Comment();
      this.init(node, token[2]);
      node.source.end = this.getPosition(token[3] || token[2]);
      node.source.end.offset++;
      var text = token[1].slice(2, -2);

      if (/^\s*$/.test(text)) {
        node.text = '';
        node.raws.left = text;
        node.raws.right = '';
      } else {
        var match = text.match(/^(\s*)([^]*\S)(\s*)$/);
        node.text = match[2];
        node.raws.left = match[1];
        node.raws.right = match[3];
      }
    }
  }, {
    key: "createTokenizer",
    value: function createTokenizer() {
      this.tokenizer = tokenizer(this.input);
    }
  }, {
    key: "decl",
    value: function decl(tokens, customProperty) {
      var node = new Declaration();
      this.init(node, tokens[0][2]);
      var last = tokens[tokens.length - 1];

      if (last[0] === ';') {
        this.semicolon = true;
        tokens.pop();
      }

      node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));
      node.source.end.offset++;

      while (tokens[0][0] !== 'word') {
        if (tokens.length === 1) this.unknownWord(tokens);
        node.raws.before += tokens.shift()[1];
      }

      node.source.start = this.getPosition(tokens[0][2]);
      node.prop = '';

      while (tokens.length) {
        var type = tokens[0][0];

        if (type === ':' || type === 'space' || type === 'comment') {
          break;
        }

        node.prop += tokens.shift()[1];
      }

      node.raws.between = '';
      var token;

      while (tokens.length) {
        token = tokens.shift();

        if (token[0] === ':') {
          node.raws.between += token[1];
          break;
        } else {
          if (token[0] === 'word' && /\w/.test(token[1])) {
            this.unknownWord([token]);
          }

          node.raws.between += token[1];
        }
      }

      if (node.prop[0] === '_' || node.prop[0] === '*') {
        node.raws.before += node.prop[0];
        node.prop = node.prop.slice(1);
      }

      var firstSpaces = [];
      var next;

      while (tokens.length) {
        next = tokens[0][0];
        if (next !== 'space' && next !== 'comment') break;
        firstSpaces.push(tokens.shift());
      }

      this.precheckMissedSemicolon(tokens);

      for (var i = tokens.length - 1; i >= 0; i--) {
        token = tokens[i];

        if (token[1].toLowerCase() === '!important') {
          node.important = true;
          var string = this.stringFrom(tokens, i);
          string = this.spacesFromEnd(tokens) + string;
          if (string !== ' !important') node.raws.important = string;
          break;
        } else if (token[1].toLowerCase() === 'important') {
          var cache = tokens.slice(0);
          var str = '';

          for (var j = i; j > 0; j--) {
            var _type = cache[j][0];

            if (str.trim().indexOf('!') === 0 && _type !== 'space') {
              break;
            }

            str = cache.pop()[1] + str;
          }

          if (str.trim().indexOf('!') === 0) {
            node.important = true;
            node.raws.important = str;
            tokens = cache;
          }
        }

        if (token[0] !== 'space' && token[0] !== 'comment') {
          break;
        }
      }

      var hasWord = tokens.some(function (i) {
        return i[0] !== 'space' && i[0] !== 'comment';
      });

      if (hasWord) {
        node.raws.between += firstSpaces.map(function (i) {
          return i[1];
        }).join('');
        firstSpaces = [];
      }

      this.raw(node, 'value', firstSpaces.concat(tokens), customProperty);

      if (node.value.includes(':') && !customProperty) {
        this.checkMissedSemicolon(tokens);
      }
    }
  }, {
    key: "doubleColon",
    value: function doubleColon(token) {
      throw this.input.error('Double colon', {
        offset: token[2]
      }, {
        offset: token[2] + token[1].length
      });
    }
  }, {
    key: "emptyRule",
    value: function emptyRule(token) {
      var node = new Rule();
      this.init(node, token[2]);
      node.selector = '';
      node.raws.between = '';
      this.current = node;
    }
  }, {
    key: "end",
    value: function end(token) {
      if (this.current.nodes && this.current.nodes.length) {
        this.current.raws.semicolon = this.semicolon;
      }

      this.semicolon = false;
      this.current.raws.after = (this.current.raws.after || '') + this.spaces;
      this.spaces = '';

      if (this.current.parent) {
        this.current.source.end = this.getPosition(token[2]);
        this.current.source.end.offset++;
        this.current = this.current.parent;
      } else {
        this.unexpectedClose(token);
      }
    }
  }, {
    key: "endFile",
    value: function endFile() {
      if (this.current.parent) this.unclosedBlock();

      if (this.current.nodes && this.current.nodes.length) {
        this.current.raws.semicolon = this.semicolon;
      }

      this.current.raws.after = (this.current.raws.after || '') + this.spaces;
      this.root.source.end = this.getPosition(this.tokenizer.position());
    }
  }, {
    key: "freeSemicolon",
    value: function freeSemicolon(token) {
      this.spaces += token[1];

      if (this.current.nodes) {
        var prev = this.current.nodes[this.current.nodes.length - 1];

        if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
          prev.raws.ownSemicolon = this.spaces;
          this.spaces = '';
        }
      }
    } // Helpers

  }, {
    key: "getPosition",
    value: function getPosition(offset) {
      var pos = this.input.fromOffset(offset);
      return {
        column: pos.col,
        line: pos.line,
        offset: offset
      };
    }
  }, {
    key: "init",
    value: function init(node, offset) {
      this.current.push(node);
      node.source = {
        input: this.input,
        start: this.getPosition(offset)
      };
      node.raws.before = this.spaces;
      this.spaces = '';
      if (node.type !== 'comment') this.semicolon = false;
    }
  }, {
    key: "other",
    value: function other(start) {
      var end = false;
      var type = null;
      var colon = false;
      var bracket = null;
      var brackets = [];
      var customProperty = start[1].startsWith('--');
      var tokens = [];
      var token = start;

      while (token) {
        type = token[0];
        tokens.push(token);

        if (type === '(' || type === '[') {
          if (!bracket) bracket = token;
          brackets.push(type === '(' ? ')' : ']');
        } else if (customProperty && colon && type === '{') {
          if (!bracket) bracket = token;
          brackets.push('}');
        } else if (brackets.length === 0) {
          if (type === ';') {
            if (colon) {
              this.decl(tokens, customProperty);
              return;
            } else {
              break;
            }
          } else if (type === '{') {
            this.rule(tokens);
            return;
          } else if (type === '}') {
            this.tokenizer.back(tokens.pop());
            end = true;
            break;
          } else if (type === ':') {
            colon = true;
          }
        } else if (type === brackets[brackets.length - 1]) {
          brackets.pop();
          if (brackets.length === 0) bracket = null;
        }

        token = this.tokenizer.nextToken();
      }

      if (this.tokenizer.endOfFile()) end = true;
      if (brackets.length > 0) this.unclosedBracket(bracket);

      if (end && colon) {
        if (!customProperty) {
          while (tokens.length) {
            token = tokens[tokens.length - 1][0];
            if (token !== 'space' && token !== 'comment') break;
            this.tokenizer.back(tokens.pop());
          }
        }

        this.decl(tokens, customProperty);
      } else {
        this.unknownWord(tokens);
      }
    }
  }, {
    key: "parse",
    value: function parse() {
      var token;

      while (!this.tokenizer.endOfFile()) {
        token = this.tokenizer.nextToken();

        switch (token[0]) {
          case 'space':
            this.spaces += token[1];
            break;

          case ';':
            this.freeSemicolon(token);
            break;

          case '}':
            this.end(token);
            break;

          case 'comment':
            this.comment(token);
            break;

          case 'at-word':
            this.atrule(token);
            break;

          case '{':
            this.emptyRule(token);
            break;

          default:
            this.other(token);
            break;
        }
      }

      this.endFile();
    }
  }, {
    key: "precheckMissedSemicolon",
    value: function precheckMissedSemicolon()
    /* tokens */
    {// Hook for Safe Parser
    }
  }, {
    key: "raw",
    value: function raw(node, prop, tokens, customProperty) {
      var token, type;
      var length = tokens.length;
      var value = '';
      var clean = true;
      var next, prev;

      for (var i = 0; i < length; i += 1) {
        token = tokens[i];
        type = token[0];

        if (type === 'space' && i === length - 1 && !customProperty) {
          clean = false;
        } else if (type === 'comment') {
          prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty';
          next = tokens[i + 1] ? tokens[i + 1][0] : 'empty';

          if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
            if (value.slice(-1) === ',') {
              clean = false;
            } else {
              value += token[1];
            }
          } else {
            clean = false;
          }
        } else {
          value += token[1];
        }
      }

      if (!clean) {
        var raw = tokens.reduce(function (all, i) {
          return all + i[1];
        }, '');
        node.raws[prop] = {
          raw: raw,
          value: value
        };
      }

      node[prop] = value;
    }
  }, {
    key: "rule",
    value: function rule(tokens) {
      tokens.pop();
      var node = new Rule();
      this.init(node, tokens[0][2]);
      node.raws.between = this.spacesAndCommentsFromEnd(tokens);
      this.raw(node, 'selector', tokens);
      this.current = node;
    }
  }, {
    key: "spacesAndCommentsFromEnd",
    value: function spacesAndCommentsFromEnd(tokens) {
      var lastTokenType;
      var spaces = '';

      while (tokens.length) {
        lastTokenType = tokens[tokens.length - 1][0];
        if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;
        spaces = tokens.pop()[1] + spaces;
      }

      return spaces;
    } // Errors

  }, {
    key: "spacesAndCommentsFromStart",
    value: function spacesAndCommentsFromStart(tokens) {
      var next;
      var spaces = '';

      while (tokens.length) {
        next = tokens[0][0];
        if (next !== 'space' && next !== 'comment') break;
        spaces += tokens.shift()[1];
      }

      return spaces;
    }
  }, {
    key: "spacesFromEnd",
    value: function spacesFromEnd(tokens) {
      var lastTokenType;
      var spaces = '';

      while (tokens.length) {
        lastTokenType = tokens[tokens.length - 1][0];
        if (lastTokenType !== 'space') break;
        spaces = tokens.pop()[1] + spaces;
      }

      return spaces;
    }
  }, {
    key: "stringFrom",
    value: function stringFrom(tokens, from) {
      var result = '';

      for (var i = from; i < tokens.length; i++) {
        result += tokens[i][1];
      }

      tokens.splice(from, tokens.length - from);
      return result;
    }
  }, {
    key: "unclosedBlock",
    value: function unclosedBlock() {
      var pos = this.current.source.start;
      throw this.input.error('Unclosed block', pos.line, pos.column);
    }
  }, {
    key: "unclosedBracket",
    value: function unclosedBracket(bracket) {
      throw this.input.error('Unclosed bracket', {
        offset: bracket[2]
      }, {
        offset: bracket[2] + 1
      });
    }
  }, {
    key: "unexpectedClose",
    value: function unexpectedClose(token) {
      throw this.input.error('Unexpected }', {
        offset: token[2]
      }, {
        offset: token[2] + 1
      });
    }
  }, {
    key: "unknownWord",
    value: function unknownWord(tokens) {
      throw this.input.error('Unknown word', {
        offset: tokens[0][2]
      }, {
        offset: tokens[0][2] + tokens[0][1].length
      });
    }
  }, {
    key: "unnamedAtrule",
    value: function unnamedAtrule(node, token) {
      throw this.input.error('At-rule without name', {
        offset: token[2]
      }, {
        offset: token[2] + token[1].length
      });
    }
  }]);

  return Parser;
}();

module.exports = Parser;