'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('source-map-js'),
    SourceMapConsumer = _require.SourceMapConsumer,
    SourceMapGenerator = _require.SourceMapGenerator;

var _require2 = require('path'),
    dirname = _require2.dirname,
    relative = _require2.relative,
    resolve = _require2.resolve,
    sep = _require2.sep;

var _require3 = require('url'),
    pathToFileURL = _require3.pathToFileURL;

var Input = require('./input');

var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
var pathAvailable = Boolean(dirname && resolve && relative && sep);

var MapGenerator =
/*#__PURE__*/
function () {
  function MapGenerator(stringify, root, opts, cssString) {
    _classCallCheck(this, MapGenerator);

    this.stringify = stringify;
    this.mapOpts = opts.map || {};
    this.root = root;
    this.opts = opts;
    this.css = cssString;
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
    this.memoizedFileURLs = new Map();
    this.memoizedPaths = new Map();
    this.memoizedURLs = new Map();
  }

  _createClass(MapGenerator, [{
    key: "addAnnotation",
    value: function addAnnotation() {
      var content;

      if (this.isInline()) {
        content = 'data:application/json;base64,' + this.toBase64(this.map.toString());
      } else if (typeof this.mapOpts.annotation === 'string') {
        content = this.mapOpts.annotation;
      } else if (typeof this.mapOpts.annotation === 'function') {
        content = this.mapOpts.annotation(this.opts.to, this.root);
      } else {
        content = this.outputFile() + '.map';
      }

      var eol = '\n';
      if (this.css.includes('\r\n')) eol = '\r\n';
      this.css += eol + '/*# sourceMappingURL=' + content + ' */';
    }
  }, {
    key: "applyPrevMaps",
    value: function applyPrevMaps() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.previous()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var prev = _step.value;
          var from = this.toUrl(this.path(prev.file));
          var root = prev.root || dirname(prev.file);
          var map = void 0;

          if (this.mapOpts.sourcesContent === false) {
            map = new SourceMapConsumer(prev.text);

            if (map.sourcesContent) {
              map.sourcesContent = map.sourcesContent.map(function () {
                return null;
              });
            }
          } else {
            map = prev.consumer();
          }

          this.map.applySourceMap(map, from, this.toUrl(this.path(root)));
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "clearAnnotation",
    value: function clearAnnotation() {
      if (this.mapOpts.annotation === false) return;

      if (this.root) {
        var node;

        for (var i = this.root.nodes.length - 1; i >= 0; i--) {
          node = this.root.nodes[i];
          if (node.type !== 'comment') continue;

          if (node.text.indexOf('# sourceMappingURL=') === 0) {
            this.root.removeChild(i);
          }
        }
      } else if (this.css) {
        this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, '');
      }
    }
  }, {
    key: "generate",
    value: function generate() {
      this.clearAnnotation();

      if (pathAvailable && sourceMapAvailable && this.isMap()) {
        return this.generateMap();
      } else {
        var result = '';
        this.stringify(this.root, function (i) {
          result += i;
        });
        return [result];
      }
    }
  }, {
    key: "generateMap",
    value: function generateMap() {
      if (this.root) {
        this.generateString();
      } else if (this.previous().length === 1) {
        var prev = this.previous()[0].consumer();
        prev.file = this.outputFile();
        this.map = SourceMapGenerator.fromSourceMap(prev);
      } else {
        this.map = new SourceMapGenerator({
          file: this.outputFile()
        });
        this.map.addMapping({
          generated: {
            column: 0,
            line: 1
          },
          original: {
            column: 0,
            line: 1
          },
          source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>'
        });
      }

      if (this.isSourcesContent()) this.setSourcesContent();
      if (this.root && this.previous().length > 0) this.applyPrevMaps();
      if (this.isAnnotation()) this.addAnnotation();

      if (this.isInline()) {
        return [this.css];
      } else {
        return [this.css, this.map];
      }
    }
  }, {
    key: "generateString",
    value: function generateString() {
      var _this = this;

      this.css = '';
      this.map = new SourceMapGenerator({
        file: this.outputFile()
      });
      var line = 1;
      var column = 1;
      var noSource = '<no source>';
      var mapping = {
        generated: {
          column: 0,
          line: 0
        },
        original: {
          column: 0,
          line: 0
        },
        source: ''
      };
      var lines, last;
      this.stringify(this.root, function (str, node, type) {
        _this.css += str;

        if (node && type !== 'end') {
          mapping.generated.line = line;
          mapping.generated.column = column - 1;

          if (node.source && node.source.start) {
            mapping.source = _this.sourcePath(node);
            mapping.original.line = node.source.start.line;
            mapping.original.column = node.source.start.column - 1;

            _this.map.addMapping(mapping);
          } else {
            mapping.source = noSource;
            mapping.original.line = 1;
            mapping.original.column = 0;

            _this.map.addMapping(mapping);
          }
        }

        lines = str.match(/\n/g);

        if (lines) {
          line += lines.length;
          last = str.lastIndexOf('\n');
          column = str.length - last;
        } else {
          column += str.length;
        }

        if (node && type !== 'start') {
          var p = node.parent || {
            raws: {}
          };
          var childless = node.type === 'decl' || node.type === 'atrule' && !node.nodes;

          if (!childless || node !== p.last || p.raws.semicolon) {
            if (node.source && node.source.end) {
              mapping.source = _this.sourcePath(node);
              mapping.original.line = node.source.end.line;
              mapping.original.column = node.source.end.column - 1;
              mapping.generated.line = line;
              mapping.generated.column = column - 2;

              _this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              mapping.generated.line = line;
              mapping.generated.column = column - 1;

              _this.map.addMapping(mapping);
            }
          }
        }
      });
    }
  }, {
    key: "isAnnotation",
    value: function isAnnotation() {
      if (this.isInline()) {
        return true;
      }

      if (typeof this.mapOpts.annotation !== 'undefined') {
        return this.mapOpts.annotation;
      }

      if (this.previous().length) {
        return this.previous().some(function (i) {
          return i.annotation;
        });
      }

      return true;
    }
  }, {
    key: "isInline",
    value: function isInline() {
      if (typeof this.mapOpts.inline !== 'undefined') {
        return this.mapOpts.inline;
      }

      var annotation = this.mapOpts.annotation;

      if (typeof annotation !== 'undefined' && annotation !== true) {
        return false;
      }

      if (this.previous().length) {
        return this.previous().some(function (i) {
          return i.inline;
        });
      }

      return true;
    }
  }, {
    key: "isMap",
    value: function isMap() {
      if (typeof this.opts.map !== 'undefined') {
        return !!this.opts.map;
      }

      return this.previous().length > 0;
    }
  }, {
    key: "isSourcesContent",
    value: function isSourcesContent() {
      if (typeof this.mapOpts.sourcesContent !== 'undefined') {
        return this.mapOpts.sourcesContent;
      }

      if (this.previous().length) {
        return this.previous().some(function (i) {
          return i.withContent();
        });
      }

      return true;
    }
  }, {
    key: "outputFile",
    value: function outputFile() {
      if (this.opts.to) {
        return this.path(this.opts.to);
      } else if (this.opts.from) {
        return this.path(this.opts.from);
      } else {
        return 'to.css';
      }
    }
  }, {
    key: "path",
    value: function path(file) {
      if (this.mapOpts.absolute) return file;
      if (file.charCodeAt(0) === 60
      /* `<` */
      ) return file;
      if (/^\w+:\/\//.test(file)) return file;
      var cached = this.memoizedPaths.get(file);
      if (cached) return cached;
      var from = this.opts.to ? dirname(this.opts.to) : '.';

      if (typeof this.mapOpts.annotation === 'string') {
        from = dirname(resolve(from, this.mapOpts.annotation));
      }

      var path = relative(from, file);
      this.memoizedPaths.set(file, path);
      return path;
    }
  }, {
    key: "previous",
    value: function previous() {
      var _this2 = this;

      if (!this.previousMaps) {
        this.previousMaps = [];

        if (this.root) {
          this.root.walk(function (node) {
            if (node.source && node.source.input.map) {
              var map = node.source.input.map;

              if (!_this2.previousMaps.includes(map)) {
                _this2.previousMaps.push(map);
              }
            }
          });
        } else {
          var input = new Input(this.css, this.opts);
          if (input.map) this.previousMaps.push(input.map);
        }
      }

      return this.previousMaps;
    }
  }, {
    key: "setSourcesContent",
    value: function setSourcesContent() {
      var _this3 = this;

      var already = {};

      if (this.root) {
        this.root.walk(function (node) {
          if (node.source) {
            var from = node.source.input.from;

            if (from && !already[from]) {
              already[from] = true;
              var fromUrl = _this3.usesFileUrls ? _this3.toFileUrl(from) : _this3.toUrl(_this3.path(from));

              _this3.map.setSourceContent(fromUrl, node.source.input.css);
            }
          }
        });
      } else if (this.css) {
        var from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : '<no source>';
        this.map.setSourceContent(from, this.css);
      }
    }
  }, {
    key: "sourcePath",
    value: function sourcePath(node) {
      if (this.mapOpts.from) {
        return this.toUrl(this.mapOpts.from);
      } else if (this.usesFileUrls) {
        return this.toFileUrl(node.source.input.from);
      } else {
        return this.toUrl(this.path(node.source.input.from));
      }
    }
  }, {
    key: "toBase64",
    value: function toBase64(str) {
      if (Buffer) {
        return Buffer.from(str).toString('base64');
      } else {
        return window.btoa(unescape(encodeURIComponent(str)));
      }
    }
  }, {
    key: "toFileUrl",
    value: function toFileUrl(path) {
      var cached = this.memoizedFileURLs.get(path);
      if (cached) return cached;

      if (pathToFileURL) {
        var fileURL = pathToFileURL(path).toString();
        this.memoizedFileURLs.set(path, fileURL);
        return fileURL;
      } else {
        throw new Error('`map.absolute` option is not available in this PostCSS build');
      }
    }
  }, {
    key: "toUrl",
    value: function toUrl(path) {
      var cached = this.memoizedURLs.get(path);
      if (cached) return cached;

      if (sep === '\\') {
        path = path.replace(/\\/g, '/');
      }

      var url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
      this.memoizedURLs.set(path, url);
      return url;
    }
  }]);

  return MapGenerator;
}();

module.exports = MapGenerator;