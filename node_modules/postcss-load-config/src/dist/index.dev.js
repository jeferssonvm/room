'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var resolve = require('path').resolve;

var url = require('url');

var config = require('lilconfig');

var _yaml = require('yaml');

var loadOptions = require('./options.js');

var loadPlugins = require('./plugins.js');
/* istanbul ignore next */


var interopRequireDefault = function interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
};
/**
 * Process the result from cosmiconfig
 *
 * @param  {Object} ctx Config Context
 * @param  {Object} result Cosmiconfig result
 *
 * @return {Object} PostCSS Config
 */


var processResult = function processResult(ctx, result) {
  var file = result.filepath || '';
  var config = interopRequireDefault(result.config)["default"] || {};

  if (typeof config === 'function') {
    config = config(ctx);
  } else {
    config = Object.assign({}, config, ctx);
  }

  if (!config.plugins) {
    config.plugins = [];
  }

  return {
    plugins: loadPlugins(config, file),
    options: loadOptions(config, file),
    file: file
  };
};
/**
 * Builds the Config Context
 *
 * @param  {Object} ctx Config Context
 *
 * @return {Object} Config Context
 */


var createContext = function createContext(ctx) {
  /**
   * @type {Object}
   *
   * @prop {String} cwd=process.cwd() Config search start location
   * @prop {String} env=process.env.NODE_ENV Config Enviroment, will be set to `development` by `postcss-load-config` if `process.env.NODE_ENV` is `undefined`
   */
  ctx = Object.assign({
    cwd: process.cwd(),
    env: process.env.NODE_ENV
  }, ctx);

  if (!ctx.env) {
    process.env.NODE_ENV = 'development';
  }

  return ctx;
};

var importDefault = function importDefault(filepath) {
  var module;
  return regeneratorRuntime.async(function importDefault$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap(Promise.resolve().then(function () {
            return _interopRequireWildcard(require("".concat(url.pathToFileURL(filepath).href)));
          }));

        case 2:
          module = _context.sent;
          return _context.abrupt("return", module["default"]);

        case 4:
        case "end":
          return _context.stop();
      }
    }
  });
};

var addTypeScriptLoader = function addTypeScriptLoader() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var loader = arguments.length > 1 ? arguments[1] : undefined;
  var moduleName = 'postcss';
  return _objectSpread({}, options, {
    searchPlaces: [].concat(_toConsumableArray(options.searchPlaces || []), ['package.json', ".".concat(moduleName, "rc"), ".".concat(moduleName, "rc.json"), ".".concat(moduleName, "rc.yaml"), ".".concat(moduleName, "rc.yml"), ".".concat(moduleName, "rc.ts"), ".".concat(moduleName, "rc.cts"), ".".concat(moduleName, "rc.js"), ".".concat(moduleName, "rc.cjs"), ".".concat(moduleName, "rc.mjs"), "".concat(moduleName, ".config.ts"), "".concat(moduleName, ".config.cts"), "".concat(moduleName, ".config.js"), "".concat(moduleName, ".config.cjs"), "".concat(moduleName, ".config.mjs")]),
    loaders: _objectSpread({}, options.loaders, {
      '.yaml': function yaml(filepath, content) {
        return _yaml.parse(content);
      },
      '.yml': function yml(filepath, content) {
        return _yaml.parse(content);
      },
      '.js': importDefault,
      '.cjs': importDefault,
      '.mjs': importDefault,
      '.ts': loader,
      '.cts': loader
    })
  });
};

var withTypeScriptLoader = function withTypeScriptLoader(rcFunc) {
  return function (ctx, path, options) {
    return rcFunc(ctx, path, addTypeScriptLoader(options, function (configFile) {
      var registerer = {
        enabled: function enabled() {}
      };

      try {
        // Register TypeScript compiler instance
        registerer = require('ts-node').register({
          // transpile to cjs even if compilerOptions.module in tsconfig is not Node16/NodeNext.
          moduleTypes: {
            '**/*.cts': 'cjs'
          }
        });
        return require(configFile);
      } catch (err) {
        if (err.code === 'MODULE_NOT_FOUND') {
          throw new Error("'ts-node' is required for the TypeScript configuration files. Make sure it is installed\nError: ".concat(err.message));
        }

        throw err;
      } finally {
        registerer.enabled(false);
      }
    }));
  };
};
/**
 * Load Config
 *
 * @method rc
 *
 * @param  {Object} ctx Config Context
 * @param  {String} path Config Path
 * @param  {Object} options Config Options
 *
 * @return {Promise} config PostCSS Config
 */


var rc = withTypeScriptLoader(function (ctx, path, options) {
  /**
   * @type {Object} The full Config Context
   */
  ctx = createContext(ctx);
  /**
   * @type {String} `process.cwd()`
   */

  path = path ? resolve(path) : process.cwd();
  return config.lilconfig('postcss', options).search(path).then(function (result) {
    if (!result) {
      throw new Error("No PostCSS Config found in: ".concat(path));
    }

    return processResult(ctx, result);
  });
});
/**
 * Autoload Config for PostCSS
 *
 * @author Michael Ciniawsky @michael-ciniawsky <michael.ciniawsky@gmail.com>
 * @license MIT
 *
 * @module postcss-load-config
 * @version 2.1.0
 *
 * @requires comsiconfig
 * @requires ./options
 * @requires ./plugins
 */

module.exports = rc;