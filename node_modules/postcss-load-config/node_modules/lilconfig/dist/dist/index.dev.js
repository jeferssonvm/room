"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;

var path = require("path");

var fs = require("fs");

var os = require("os");

var fsReadFileAsync = fs.promises.readFile;

function getDefaultSearchPlaces(name) {
  return ['package.json', ".".concat(name, "rc.json"), ".".concat(name, "rc.js"), ".".concat(name, "rc.cjs"), ".config/".concat(name, "rc"), ".config/".concat(name, "rc.json"), ".config/".concat(name, "rc.js"), ".config/".concat(name, "rc.cjs"), "".concat(name, ".config.js"), "".concat(name, ".config.cjs")];
}

function parentDir(p) {
  return path.dirname(p) || path.sep;
}

exports.defaultLoaders = Object.freeze({
  '.js': require,
  '.json': require,
  '.cjs': require,
  noExt: function noExt(_, content) {
    return JSON.parse(content);
  }
});

function getExtDesc(ext) {
  return ext === 'noExt' ? 'files without extensions' : "extension \"".concat(ext, "\"");
}

function getOptions(name) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var conf = _objectSpread({
    stopDir: os.homedir(),
    searchPlaces: getDefaultSearchPlaces(name),
    ignoreEmptySearchPlaces: true,
    cache: true,
    transform: function transform(x) {
      return x;
    },
    packageProp: [name]
  }, options, {
    loaders: _objectSpread({}, exports.defaultLoaders, {}, options.loaders)
  });

  conf.searchPlaces.forEach(function (place) {
    var key = path.extname(place) || 'noExt';
    var loader = conf.loaders[key];

    if (!loader) {
      throw new Error("No loader specified for ".concat(getExtDesc(key), ", so searchPlaces item \"").concat(place, "\" is invalid"));
    }

    if (typeof loader !== 'function') {
      throw new Error("loader for ".concat(getExtDesc(key), " is not a function (type provided: \"").concat(_typeof(loader), "\"), so searchPlaces item \"").concat(place, "\" is invalid"));
    }
  });
  return conf;
}

function getPackageProp(props, obj) {
  if (typeof props === 'string' && props in obj) return obj[props];
  return (Array.isArray(props) ? props : props.split('.')).reduce(function (acc, prop) {
    return acc === undefined ? acc : acc[prop];
  }, obj) || null;
}

function validateFilePath(filepath) {
  if (!filepath) throw new Error('load must pass a non-empty string');
}

function validateLoader(loader, ext) {
  if (!loader) throw new Error("No loader specified for extension \"".concat(ext, "\""));
  if (typeof loader !== 'function') throw new Error('loader is not a function');
}

var makeEmplace = function makeEmplace(enableCache) {
  return function (c, filepath, res) {
    if (enableCache) c.set(filepath, res);
    return res;
  };
};

function lilconfig(name, options) {
  var _getOptions = getOptions(name, options),
      ignoreEmptySearchPlaces = _getOptions.ignoreEmptySearchPlaces,
      loaders = _getOptions.loaders,
      packageProp = _getOptions.packageProp,
      searchPlaces = _getOptions.searchPlaces,
      stopDir = _getOptions.stopDir,
      transform = _getOptions.transform,
      cache = _getOptions.cache;

  var searchCache = new Map();
  var loadCache = new Map();
  var emplace = makeEmplace(cache);
  return {
    search: function search() {
      var searchFrom,
          result,
          visited,
          dir,
          r,
          _iteratorNormalCompletion,
          _didIteratorError,
          _iteratorError,
          _iterator,
          _step,
          p,
          _iteratorNormalCompletion2,
          _didIteratorError2,
          _iteratorError2,
          _iterator2,
          _step2,
          searchPlace,
          filepath,
          content,
          loaderKey,
          loader,
          pkg,
          maybeConfig,
          isEmpty,
          transformed,
          _iteratorNormalCompletion3,
          _didIteratorError3,
          _iteratorError3,
          _iterator3,
          _step3,
          _p,
          _args = arguments;

      return regeneratorRuntime.async(function search$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              searchFrom = _args.length > 0 && _args[0] !== undefined ? _args[0] : process.cwd();
              result = {
                config: null,
                filepath: ''
              };
              visited = new Set();
              dir = searchFrom;

            case 4:
              if (!true) {
                _context.next = 98;
                break;
              }

              if (!cache) {
                _context.next = 29;
                break;
              }

              r = searchCache.get(dir);

              if (!(r !== undefined)) {
                _context.next = 28;
                break;
              }

              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context.prev = 11;

              for (_iterator = visited[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                p = _step.value;
                searchCache.set(p, r);
              }

              _context.next = 19;
              break;

            case 15:
              _context.prev = 15;
              _context.t0 = _context["catch"](11);
              _didIteratorError = true;
              _iteratorError = _context.t0;

            case 19:
              _context.prev = 19;
              _context.prev = 20;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 22:
              _context.prev = 22;

              if (!_didIteratorError) {
                _context.next = 25;
                break;
              }

              throw _iteratorError;

            case 25:
              return _context.finish(22);

            case 26:
              return _context.finish(19);

            case 27:
              return _context.abrupt("return", r);

            case 28:
              visited.add(dir);

            case 29:
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context.prev = 32;
              _iterator2 = searchPlaces[Symbol.iterator]();

            case 34:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context.next = 79;
                break;
              }

              searchPlace = _step2.value;
              filepath = path.join(dir, searchPlace);
              _context.prev = 37;
              _context.next = 40;
              return regeneratorRuntime.awrap(fs.promises.access(filepath));

            case 40:
              _context.next = 45;
              break;

            case 42:
              _context.prev = 42;
              _context.t1 = _context["catch"](37);
              return _context.abrupt("continue", 76);

            case 45:
              _context.t2 = String;
              _context.next = 48;
              return regeneratorRuntime.awrap(fsReadFileAsync(filepath));

            case 48:
              _context.t3 = _context.sent;
              content = (0, _context.t2)(_context.t3);
              loaderKey = path.extname(searchPlace) || 'noExt';
              loader = loaders[loaderKey];

              if (!(searchPlace === 'package.json')) {
                _context.next = 62;
                break;
              }

              _context.next = 55;
              return regeneratorRuntime.awrap(loader(filepath, content));

            case 55:
              pkg = _context.sent;
              maybeConfig = getPackageProp(packageProp, pkg);

              if (!(maybeConfig != null)) {
                _context.next = 61;
                break;
              }

              result.config = maybeConfig;
              result.filepath = filepath;
              return _context.abrupt("break", 98);

            case 61:
              return _context.abrupt("continue", 76);

            case 62:
              isEmpty = content.trim() === '';

              if (!(isEmpty && ignoreEmptySearchPlaces)) {
                _context.next = 65;
                break;
              }

              return _context.abrupt("continue", 76);

            case 65:
              if (!isEmpty) {
                _context.next = 70;
                break;
              }

              result.isEmpty = true;
              result.config = undefined;
              _context.next = 74;
              break;

            case 70:
              validateLoader(loader, loaderKey);
              _context.next = 73;
              return regeneratorRuntime.awrap(loader(filepath, content));

            case 73:
              result.config = _context.sent;

            case 74:
              result.filepath = filepath;
              return _context.abrupt("break", 98);

            case 76:
              _iteratorNormalCompletion2 = true;
              _context.next = 34;
              break;

            case 79:
              _context.next = 85;
              break;

            case 81:
              _context.prev = 81;
              _context.t4 = _context["catch"](32);
              _didIteratorError2 = true;
              _iteratorError2 = _context.t4;

            case 85:
              _context.prev = 85;
              _context.prev = 86;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 88:
              _context.prev = 88;

              if (!_didIteratorError2) {
                _context.next = 91;
                break;
              }

              throw _iteratorError2;

            case 91:
              return _context.finish(88);

            case 92:
              return _context.finish(85);

            case 93:
              if (!(dir === stopDir || dir === parentDir(dir))) {
                _context.next = 95;
                break;
              }

              return _context.abrupt("break", 98);

            case 95:
              dir = parentDir(dir);
              _context.next = 4;
              break;

            case 98:
              transformed = result.filepath === '' && result.config === null ? transform(null) : transform(result);

              if (!cache) {
                _context.next = 119;
                break;
              }

              _iteratorNormalCompletion3 = true;
              _didIteratorError3 = false;
              _iteratorError3 = undefined;
              _context.prev = 103;

              for (_iterator3 = visited[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                _p = _step3.value;
                searchCache.set(_p, transformed);
              }

              _context.next = 111;
              break;

            case 107:
              _context.prev = 107;
              _context.t5 = _context["catch"](103);
              _didIteratorError3 = true;
              _iteratorError3 = _context.t5;

            case 111:
              _context.prev = 111;
              _context.prev = 112;

              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }

            case 114:
              _context.prev = 114;

              if (!_didIteratorError3) {
                _context.next = 117;
                break;
              }

              throw _iteratorError3;

            case 117:
              return _context.finish(114);

            case 118:
              return _context.finish(111);

            case 119:
              return _context.abrupt("return", transformed);

            case 120:
            case "end":
              return _context.stop();
          }
        }
      }, null, null, [[11, 15, 19, 27], [20,, 22, 26], [32, 81, 85, 93], [37, 42], [86,, 88, 92], [103, 107, 111, 119], [112,, 114, 118]]);
    },
    load: function load(filepath) {
      var absPath, _path$parse, base, ext, loaderKey, loader, content, pkg, result, isEmpty;

      return regeneratorRuntime.async(function load$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              validateFilePath(filepath);
              absPath = path.resolve(process.cwd(), filepath);

              if (!(cache && loadCache.has(absPath))) {
                _context2.next = 4;
                break;
              }

              return _context2.abrupt("return", loadCache.get(absPath));

            case 4:
              _path$parse = path.parse(absPath), base = _path$parse.base, ext = _path$parse.ext;
              loaderKey = ext || 'noExt';
              loader = loaders[loaderKey];
              validateLoader(loader, loaderKey);
              _context2.t0 = String;
              _context2.next = 11;
              return regeneratorRuntime.awrap(fsReadFileAsync(absPath));

            case 11:
              _context2.t1 = _context2.sent;
              content = (0, _context2.t0)(_context2.t1);

              if (!(base === 'package.json')) {
                _context2.next = 18;
                break;
              }

              _context2.next = 16;
              return regeneratorRuntime.awrap(loader(absPath, content));

            case 16:
              pkg = _context2.sent;
              return _context2.abrupt("return", emplace(loadCache, absPath, transform({
                config: getPackageProp(packageProp, pkg),
                filepath: absPath
              })));

            case 18:
              result = {
                config: null,
                filepath: absPath
              };
              isEmpty = content.trim() === '';

              if (!(isEmpty && ignoreEmptySearchPlaces)) {
                _context2.next = 22;
                break;
              }

              return _context2.abrupt("return", emplace(loadCache, absPath, transform({
                config: undefined,
                filepath: absPath,
                isEmpty: true
              })));

            case 22:
              if (!isEmpty) {
                _context2.next = 26;
                break;
              }

              _context2.t2 = undefined;
              _context2.next = 29;
              break;

            case 26:
              _context2.next = 28;
              return regeneratorRuntime.awrap(loader(absPath, content));

            case 28:
              _context2.t2 = _context2.sent;

            case 29:
              result.config = _context2.t2;
              return _context2.abrupt("return", emplace(loadCache, absPath, transform(isEmpty ? _objectSpread({}, result, {
                isEmpty: isEmpty,
                config: undefined
              }) : result)));

            case 31:
            case "end":
              return _context2.stop();
          }
        }
      });
    },
    clearLoadCache: function clearLoadCache() {
      if (cache) loadCache.clear();
    },
    clearSearchCache: function clearSearchCache() {
      if (cache) searchCache.clear();
    },
    clearCaches: function clearCaches() {
      if (cache) {
        loadCache.clear();
        searchCache.clear();
      }
    }
  };
}

exports.lilconfig = lilconfig;

function lilconfigSync(name, options) {
  var _getOptions2 = getOptions(name, options),
      ignoreEmptySearchPlaces = _getOptions2.ignoreEmptySearchPlaces,
      loaders = _getOptions2.loaders,
      packageProp = _getOptions2.packageProp,
      searchPlaces = _getOptions2.searchPlaces,
      stopDir = _getOptions2.stopDir,
      transform = _getOptions2.transform,
      cache = _getOptions2.cache;

  var searchCache = new Map();
  var loadCache = new Map();
  var emplace = makeEmplace(cache);
  return {
    search: function search() {
      var searchFrom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();
      var result = {
        config: null,
        filepath: ''
      };
      var visited = new Set();
      var dir = searchFrom;

      dirLoop: while (true) {
        if (cache) {
          var r = searchCache.get(dir);

          if (r !== undefined) {
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = visited[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var p = _step4.value;
                searchCache.set(p, r);
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                  _iterator4["return"]();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }

            return r;
          }

          visited.add(dir);
        }

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = searchPlaces[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var searchPlace = _step5.value;
            var filepath = path.join(dir, searchPlace);

            try {
              fs.accessSync(filepath);
            } catch (_a) {
              continue;
            }

            var loaderKey = path.extname(searchPlace) || 'noExt';
            var loader = loaders[loaderKey];
            var content = String(fs.readFileSync(filepath));

            if (searchPlace === 'package.json') {
              var pkg = loader(filepath, content);
              var maybeConfig = getPackageProp(packageProp, pkg);

              if (maybeConfig != null) {
                result.config = maybeConfig;
                result.filepath = filepath;
                break dirLoop;
              }

              continue;
            }

            var isEmpty = content.trim() === '';
            if (isEmpty && ignoreEmptySearchPlaces) continue;

            if (isEmpty) {
              result.isEmpty = true;
              result.config = undefined;
            } else {
              validateLoader(loader, loaderKey);
              result.config = loader(filepath, content);
            }

            result.filepath = filepath;
            break dirLoop;
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        if (dir === stopDir || dir === parentDir(dir)) break dirLoop;
        dir = parentDir(dir);
      }

      var transformed = result.filepath === '' && result.config === null ? transform(null) : transform(result);

      if (cache) {
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = visited[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var _p2 = _step6.value;
            searchCache.set(_p2, transformed);
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      }

      return transformed;
    },
    load: function load(filepath) {
      validateFilePath(filepath);
      var absPath = path.resolve(process.cwd(), filepath);

      if (cache && loadCache.has(absPath)) {
        return loadCache.get(absPath);
      }

      var _path$parse2 = path.parse(absPath),
          base = _path$parse2.base,
          ext = _path$parse2.ext;

      var loaderKey = ext || 'noExt';
      var loader = loaders[loaderKey];
      validateLoader(loader, loaderKey);
      var content = String(fs.readFileSync(absPath));

      if (base === 'package.json') {
        var pkg = loader(absPath, content);
        return transform({
          config: getPackageProp(packageProp, pkg),
          filepath: absPath
        });
      }

      var result = {
        config: null,
        filepath: absPath
      };
      var isEmpty = content.trim() === '';
      if (isEmpty && ignoreEmptySearchPlaces) return emplace(loadCache, absPath, transform({
        filepath: absPath,
        config: undefined,
        isEmpty: true
      }));
      result.config = isEmpty ? undefined : loader(absPath, content);
      return emplace(loadCache, absPath, transform(isEmpty ? _objectSpread({}, result, {
        isEmpty: isEmpty,
        config: undefined
      }) : result));
    },
    clearLoadCache: function clearLoadCache() {
      if (cache) loadCache.clear();
    },
    clearSearchCache: function clearSearchCache() {
      if (cache) searchCache.clear();
    },
    clearCaches: function clearCaches() {
      if (cache) {
        loadCache.clear();
        searchCache.clear();
      }
    }
  };
}

exports.lilconfigSync = lilconfigSync;