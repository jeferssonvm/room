"use strict";

var _require = require('postcss'),
    Rule = _require.Rule,
    AtRule = _require.AtRule;

var parser = require('postcss-selector-parser');
/**
 * Run a selector string through postcss-selector-parser
 */


function parse(rawSelector, rule) {
  var nodes;

  try {
    parser(function (parsed) {
      nodes = parsed;
    }).processSync(rawSelector);
  } catch (e) {
    if (rawSelector.includes(':')) {
      throw rule ? rule.error('Missed semicolon') : e;
    } else {
      throw rule ? rule.error(e.message) : e;
    }
  }

  return nodes.at(0);
}
/**
 * Replaces the "&" token in a node's selector with the parent selector
 * similar to what SCSS does.
 *
 * Mutates the nodes list
 */


function interpolateAmpInSelector(nodes, parent) {
  var replaced = false;
  nodes.each(function (node) {
    if (node.type === 'nesting') {
      var clonedParent = parent.clone({});

      if (node.value !== '&') {
        node.replaceWith(parse(node.value.replace('&', clonedParent.toString())));
      } else {
        node.replaceWith(clonedParent);
      }

      replaced = true;
    } else if ('nodes' in node && node.nodes) {
      if (interpolateAmpInSelector(node, parent)) {
        replaced = true;
      }
    }
  });
  return replaced;
}
/**
 * Combines parent and child selectors, in a SCSS-like way
 */


function mergeSelectors(parent, child) {
  var merged = [];
  parent.selectors.forEach(function (sel) {
    var parentNode = parse(sel, parent);
    child.selectors.forEach(function (selector) {
      if (!selector) {
        return;
      }

      var node = parse(selector, child);
      var replaced = interpolateAmpInSelector(node, parentNode);

      if (!replaced) {
        node.prepend(parser.combinator({
          value: ' '
        }));
        node.prepend(parentNode.clone({}));
      }

      merged.push(node.toString());
    });
  });
  return merged;
}
/**
 * Move a child and its preceeding comment(s) to after "after"
 */


function breakOut(child, after) {
  var prev = child.prev();
  after.after(child);

  while (prev && prev.type === 'comment') {
    var nextPrev = prev.prev();
    after.after(prev);
    prev = nextPrev;
  }

  return child;
}

function createFnAtruleChilds(bubble) {
  return function atruleChilds(rule, atrule, bubbling) {
    var mergeSels = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : bubbling;
    var children = [];
    atrule.each(function (child) {
      if (child.type === 'rule' && bubbling) {
        if (mergeSels) {
          child.selectors = mergeSelectors(rule, child);
        }
      } else if (child.type === 'atrule' && child.nodes) {
        if (bubble[child.name]) {
          atruleChilds(rule, child, mergeSels);
        } else if (atrule[rootRuleMergeSel] !== false) {
          children.push(child);
        }
      } else {
        children.push(child);
      }
    });

    if (bubbling) {
      if (children.length) {
        var clone = rule.clone({
          nodes: []
        });
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var child = _step.value;
            clone.append(child);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        atrule.prepend(clone);
      }
    }
  };
}

function pickDeclarations(selector, declarations, after) {
  var parent = new Rule({
    selector: selector,
    nodes: []
  });
  parent.append(declarations);
  after.after(parent);
  return parent;
}

function atruleNames(defaults, custom) {
  var list = {};
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = defaults[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _name = _step2.value;
      list[_name] = true;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (custom) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = custom[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var name = _step3.value;
        list[name.replace(/^@/, '')] = true;
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }

  return list;
}

function parseRootRuleParams(params) {
  params = params.trim();
  var braceBlock = params.match(/^\((.*)\)$/);

  if (!braceBlock) {
    return {
      type: 'basic',
      selector: params
    };
  }

  var bits = braceBlock[1].match(/^(with(?:out)?):(.+)$/);

  if (bits) {
    var allowlist = bits[1] === 'with';
    var rules = Object.fromEntries(bits[2].trim().split(/\s+/).map(function (name) {
      return [name, true];
    }));

    if (allowlist && rules.all) {
      return {
        type: 'noop'
      };
    }

    var escapes = function escapes(rule) {
      return !!rules[rule];
    };

    if (rules.all) {
      escapes = function escapes() {
        return true;
      };
    } else if (allowlist) {
      escapes = function escapes(rule) {
        return rule === 'all' ? false : !rules[rule];
      };
    }

    return {
      type: 'withrules',
      escapes: escapes
    };
  } // Unrecognized brace block


  return {
    type: 'unknown'
  };
}

function getAncestorRules(leaf) {
  var lineage = [];
  var parent = leaf.parent;

  while (parent && parent instanceof AtRule) {
    lineage.push(parent);
    parent = parent.parent;
  }

  return lineage;
}

function unwrapRootRule(rule) {
  var escapes = rule[rootRuleEscapes];

  if (!escapes) {
    rule.after(rule.nodes);
  } else {
    var nodes = rule.nodes;
    var topEscaped;
    var topEscapedIdx = -1;
    var breakoutLeaf;
    var breakoutRoot;
    var clone;
    var lineage = getAncestorRules(rule);
    lineage.forEach(function (parent, i) {
      if (escapes(parent.name)) {
        topEscaped = parent;
        topEscapedIdx = i;
        breakoutRoot = clone;
      } else {
        var oldClone = clone;
        clone = parent.clone({
          nodes: []
        });
        oldClone && clone.append(oldClone);
        breakoutLeaf = breakoutLeaf || clone;
      }
    });

    if (!topEscaped) {
      rule.after(nodes);
    } else if (!breakoutRoot) {
      topEscaped.after(nodes);
    } else {
      var leaf = breakoutLeaf;
      leaf.append(nodes);
      topEscaped.after(breakoutRoot);
    }

    if (rule.next() && topEscaped) {
      var restRoot;
      lineage.slice(0, topEscapedIdx + 1).forEach(function (parent, i, arr) {
        var oldRoot = restRoot;
        restRoot = parent.clone({
          nodes: []
        });
        oldRoot && restRoot.append(oldRoot);
        var nextSibs = [];

        var _child = arr[i - 1] || rule;

        var next = _child.next();

        while (next) {
          nextSibs.push(next);
          next = next.next();
        }

        restRoot.append(nextSibs);
      });
      restRoot && (breakoutRoot || nodes[nodes.length - 1]).after(restRoot);
    }
  }

  rule.remove();
}

var rootRuleMergeSel = Symbol('rootRuleMergeSel');
var rootRuleEscapes = Symbol('rootRuleEscapes');

function normalizeRootRule(rule) {
  var params = rule.params;

  var _parseRootRuleParams = parseRootRuleParams(params),
      type = _parseRootRuleParams.type,
      selector = _parseRootRuleParams.selector,
      escapes = _parseRootRuleParams.escapes;

  if (type === 'unknown') {
    throw rule.error("Unknown @".concat(rule.name, " parameter ").concat(JSON.stringify(params)));
  }

  if (type === 'basic' && selector) {
    var selectorBlock = new Rule({
      selector: selector,
      nodes: rule.nodes
    });
    rule.removeAll();
    rule.append(selectorBlock);
  }

  rule[rootRuleEscapes] = escapes;
  rule[rootRuleMergeSel] = escapes ? !escapes('all') : type === 'noop';
}

var hasRootRule = Symbol('hasRootRule');

module.exports = function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var bubble = atruleNames(['media', 'supports', 'layer', 'container'], opts.bubble);
  var atruleChilds = createFnAtruleChilds(bubble);
  var unwrap = atruleNames(['document', 'font-face', 'keyframes', '-webkit-keyframes', '-moz-keyframes'], opts.unwrap);
  var rootRuleName = (opts.rootRuleName || 'at-root').replace(/^@/, '');
  var preserveEmpty = opts.preserveEmpty;
  return {
    postcssPlugin: 'postcss-nested',
    Once: function Once(root) {
      root.walkAtRules(rootRuleName, function (node) {
        normalizeRootRule(node);
        root[hasRootRule] = true;
      });
    },
    Rule: function Rule(rule) {
      var unwrapped = false;
      var after = rule;
      var copyDeclarations = false;
      var declarations = [];
      rule.each(function (child) {
        if (child.type === 'rule') {
          if (declarations.length) {
            after = pickDeclarations(rule.selector, declarations, after);
            declarations = [];
          }

          copyDeclarations = true;
          unwrapped = true;
          child.selectors = mergeSelectors(rule, child);
          after = breakOut(child, after);
        } else if (child.type === 'atrule') {
          if (declarations.length) {
            after = pickDeclarations(rule.selector, declarations, after);
            declarations = [];
          }

          if (child.name === rootRuleName) {
            unwrapped = true;
            atruleChilds(rule, child, true, child[rootRuleMergeSel]);
            after = breakOut(child, after);
          } else if (bubble[child.name]) {
            copyDeclarations = true;
            unwrapped = true;
            atruleChilds(rule, child, true);
            after = breakOut(child, after);
          } else if (unwrap[child.name]) {
            copyDeclarations = true;
            unwrapped = true;
            atruleChilds(rule, child, false);
            after = breakOut(child, after);
          } else if (copyDeclarations) {
            declarations.push(child);
          }
        } else if (child.type === 'decl' && copyDeclarations) {
          declarations.push(child);
        }
      });

      if (declarations.length) {
        after = pickDeclarations(rule.selector, declarations, after);
      }

      if (unwrapped && preserveEmpty !== true) {
        rule.raws.semicolon = true;
        if (rule.nodes.length === 0) rule.remove();
      }
    },
    RootExit: function RootExit(root) {
      if (root[hasRootRule]) {
        root.walkAtRules(rootRuleName, unwrapRootRule);
        root[hasRootRule] = false;
      }
    }
  };
};

module.exports.postcss = true;