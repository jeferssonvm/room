"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var postcss = require('postcss');

var IMPORTANT = /\s*!important\s*$/i;
var UNITLESS = {
  'box-flex': true,
  'box-flex-group': true,
  'column-count': true,
  'flex': true,
  'flex-grow': true,
  'flex-positive': true,
  'flex-shrink': true,
  'flex-negative': true,
  'font-weight': true,
  'line-clamp': true,
  'line-height': true,
  'opacity': true,
  'order': true,
  'orphans': true,
  'tab-size': true,
  'widows': true,
  'z-index': true,
  'zoom': true,
  'fill-opacity': true,
  'stroke-dashoffset': true,
  'stroke-opacity': true,
  'stroke-width': true
};

function dashify(str) {
  return str.replace(/([A-Z])/g, '-$1').replace(/^ms-/, '-ms-').toLowerCase();
}

function decl(parent, name, value) {
  if (value === false || value === null) return;

  if (!name.startsWith('--')) {
    name = dashify(name);
  }

  if (typeof value === 'number') {
    if (value === 0 || UNITLESS[name]) {
      value = value.toString();
    } else {
      value += 'px';
    }
  }

  if (name === 'css-float') name = 'float';

  if (IMPORTANT.test(value)) {
    value = value.replace(IMPORTANT, '');
    parent.push(postcss.decl({
      prop: name,
      value: value,
      important: true
    }));
  } else {
    parent.push(postcss.decl({
      prop: name,
      value: value
    }));
  }
}

function atRule(parent, parts, value) {
  var node = postcss.atRule({
    name: parts[1],
    params: parts[3] || ''
  });

  if (_typeof(value) === 'object') {
    node.nodes = [];
    parse(value, node);
  }

  parent.push(node);
}

function parse(obj, parent) {
  var name, value, node;

  for (name in obj) {
    value = obj[name];

    if (value === null || typeof value === 'undefined') {
      continue;
    } else if (name[0] === '@') {
      var parts = name.match(/@(\S+)(\s+([\W\w]*)\s*)?/);

      if (Array.isArray(value)) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var i = _step.value;
            atRule(parent, parts, i);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else {
        atRule(parent, parts, value);
      }
    } else if (Array.isArray(value)) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _i = _step2.value;
          decl(parent, name, _i);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    } else if (_typeof(value) === 'object') {
      node = postcss.rule({
        selector: name
      });
      parse(value, node);
      parent.push(node);
    } else {
      decl(parent, name, value);
    }
  }
}

module.exports = function (obj) {
  var root = postcss.root();
  parse(obj, root);
  return root;
};